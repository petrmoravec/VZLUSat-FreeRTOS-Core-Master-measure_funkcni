
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005db6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011e  00802000  00005db6  00005e4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001e78  0080211e  0080211e  00005f68  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00005f68  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000e20  00000000  00000000  00005fc8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0001629c  00000000  00000000  00006de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00005452  00000000  00000000  0001d084  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00009278  00000000  00000000  000224d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00002d94  00000000  00000000  0002b750  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000059d2  00000000  00000000  0002e4e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000d3cc  00000000  00000000  00033eb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000bf0  00000000  00000000  00041288  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	85 c3       	rjmp	.+1802   	; 0x70c <__ctors_end>
       2:	00 00       	nop
       4:	a4 c3       	rjmp	.+1864   	; 0x74e <__bad_interrupt>
       6:	00 00       	nop
       8:	a2 c3       	rjmp	.+1860   	; 0x74e <__bad_interrupt>
       a:	00 00       	nop
       c:	a0 c3       	rjmp	.+1856   	; 0x74e <__bad_interrupt>
       e:	00 00       	nop
      10:	9e c3       	rjmp	.+1852   	; 0x74e <__bad_interrupt>
      12:	00 00       	nop
      14:	9c c3       	rjmp	.+1848   	; 0x74e <__bad_interrupt>
      16:	00 00       	nop
      18:	9a c3       	rjmp	.+1844   	; 0x74e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	98 c3       	rjmp	.+1840   	; 0x74e <__bad_interrupt>
      1e:	00 00       	nop
      20:	96 c3       	rjmp	.+1836   	; 0x74e <__bad_interrupt>
      22:	00 00       	nop
      24:	94 c3       	rjmp	.+1832   	; 0x74e <__bad_interrupt>
      26:	00 00       	nop
      28:	92 c3       	rjmp	.+1828   	; 0x74e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	90 c3       	rjmp	.+1824   	; 0x74e <__bad_interrupt>
      2e:	00 00       	nop
      30:	8e c3       	rjmp	.+1820   	; 0x74e <__bad_interrupt>
      32:	00 00       	nop
      34:	8c c3       	rjmp	.+1816   	; 0x74e <__bad_interrupt>
      36:	00 00       	nop
      38:	10 c6       	rjmp	.+3104   	; 0xc5a <__vector_14>
      3a:	00 00       	nop
      3c:	88 c3       	rjmp	.+1808   	; 0x74e <__bad_interrupt>
      3e:	00 00       	nop
      40:	86 c3       	rjmp	.+1804   	; 0x74e <__bad_interrupt>
      42:	00 00       	nop
      44:	84 c3       	rjmp	.+1800   	; 0x74e <__bad_interrupt>
      46:	00 00       	nop
      48:	82 c3       	rjmp	.+1796   	; 0x74e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	80 c3       	rjmp	.+1792   	; 0x74e <__bad_interrupt>
      4e:	00 00       	nop
      50:	0c 94 b3 26 	jmp	0x4d66	; 0x4d66 <__vector_20>
      54:	7c c3       	rjmp	.+1784   	; 0x74e <__bad_interrupt>
      56:	00 00       	nop
      58:	7a c3       	rjmp	.+1780   	; 0x74e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	78 c3       	rjmp	.+1776   	; 0x74e <__bad_interrupt>
      5e:	00 00       	nop
      60:	76 c3       	rjmp	.+1772   	; 0x74e <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 f2 23 	jmp	0x47e4	; 0x47e4 <__vector_25>
      68:	0c 94 12 25 	jmp	0x4a24	; 0x4a24 <__vector_26>
      6c:	70 c3       	rjmp	.+1760   	; 0x74e <__bad_interrupt>
      6e:	00 00       	nop
      70:	6e c3       	rjmp	.+1756   	; 0x74e <__bad_interrupt>
      72:	00 00       	nop
      74:	6c c3       	rjmp	.+1752   	; 0x74e <__bad_interrupt>
      76:	00 00       	nop
      78:	6a c3       	rjmp	.+1748   	; 0x74e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	68 c3       	rjmp	.+1744   	; 0x74e <__bad_interrupt>
      7e:	00 00       	nop
      80:	66 c3       	rjmp	.+1740   	; 0x74e <__bad_interrupt>
      82:	00 00       	nop
      84:	64 c3       	rjmp	.+1736   	; 0x74e <__bad_interrupt>
      86:	00 00       	nop
      88:	62 c3       	rjmp	.+1732   	; 0x74e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	60 c3       	rjmp	.+1728   	; 0x74e <__bad_interrupt>
      8e:	00 00       	nop
      90:	5e c3       	rjmp	.+1724   	; 0x74e <__bad_interrupt>
      92:	00 00       	nop
      94:	5c c3       	rjmp	.+1720   	; 0x74e <__bad_interrupt>
      96:	00 00       	nop
      98:	5a c3       	rjmp	.+1716   	; 0x74e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	58 c3       	rjmp	.+1712   	; 0x74e <__bad_interrupt>
      9e:	00 00       	nop
      a0:	56 c3       	rjmp	.+1708   	; 0x74e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	54 c3       	rjmp	.+1704   	; 0x74e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	52 c3       	rjmp	.+1700   	; 0x74e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	50 c3       	rjmp	.+1696   	; 0x74e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4e c3       	rjmp	.+1692   	; 0x74e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	72 c4       	rjmp	.+2276   	; 0x99a <__vector_45>
      b6:	00 00       	nop
      b8:	46 c4       	rjmp	.+2188   	; 0x946 <__vector_46>
      ba:	00 00       	nop
      bc:	48 c3       	rjmp	.+1680   	; 0x74e <__bad_interrupt>
      be:	00 00       	nop
      c0:	46 c3       	rjmp	.+1676   	; 0x74e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	44 c3       	rjmp	.+1672   	; 0x74e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	42 c3       	rjmp	.+1668   	; 0x74e <__bad_interrupt>
      ca:	00 00       	nop
      cc:	40 c3       	rjmp	.+1664   	; 0x74e <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3e c3       	rjmp	.+1660   	; 0x74e <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3c c3       	rjmp	.+1656   	; 0x74e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	3a c3       	rjmp	.+1652   	; 0x74e <__bad_interrupt>
      da:	00 00       	nop
      dc:	38 c3       	rjmp	.+1648   	; 0x74e <__bad_interrupt>
      de:	00 00       	nop
      e0:	36 c3       	rjmp	.+1644   	; 0x74e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	34 c3       	rjmp	.+1640   	; 0x74e <__bad_interrupt>
      e6:	00 00       	nop
      e8:	0c 94 82 24 	jmp	0x4904	; 0x4904 <__vector_58>
      ec:	0c 94 b8 25 	jmp	0x4b70	; 0x4b70 <__vector_59>
      f0:	2e c3       	rjmp	.+1628   	; 0x74e <__bad_interrupt>
      f2:	00 00       	nop
      f4:	2c c3       	rjmp	.+1624   	; 0x74e <__bad_interrupt>
      f6:	00 00       	nop
      f8:	2a c3       	rjmp	.+1620   	; 0x74e <__bad_interrupt>
      fa:	00 00       	nop
      fc:	28 c3       	rjmp	.+1616   	; 0x74e <__bad_interrupt>
      fe:	00 00       	nop
     100:	26 c3       	rjmp	.+1612   	; 0x74e <__bad_interrupt>
     102:	00 00       	nop
     104:	24 c3       	rjmp	.+1608   	; 0x74e <__bad_interrupt>
     106:	00 00       	nop
     108:	22 c3       	rjmp	.+1604   	; 0x74e <__bad_interrupt>
     10a:	00 00       	nop
     10c:	20 c3       	rjmp	.+1600   	; 0x74e <__bad_interrupt>
     10e:	00 00       	nop
     110:	1e c3       	rjmp	.+1596   	; 0x74e <__bad_interrupt>
     112:	00 00       	nop
     114:	1c c3       	rjmp	.+1592   	; 0x74e <__bad_interrupt>
     116:	00 00       	nop
     118:	1a c3       	rjmp	.+1588   	; 0x74e <__bad_interrupt>
     11a:	00 00       	nop
     11c:	18 c3       	rjmp	.+1584   	; 0x74e <__bad_interrupt>
     11e:	00 00       	nop
     120:	16 c3       	rjmp	.+1580   	; 0x74e <__bad_interrupt>
     122:	00 00       	nop
     124:	14 c3       	rjmp	.+1576   	; 0x74e <__bad_interrupt>
     126:	00 00       	nop
     128:	12 c3       	rjmp	.+1572   	; 0x74e <__bad_interrupt>
     12a:	00 00       	nop
     12c:	10 c3       	rjmp	.+1568   	; 0x74e <__bad_interrupt>
     12e:	00 00       	nop
     130:	0e c3       	rjmp	.+1564   	; 0x74e <__bad_interrupt>
     132:	00 00       	nop
     134:	0c c3       	rjmp	.+1560   	; 0x74e <__bad_interrupt>
     136:	00 00       	nop
     138:	0a c3       	rjmp	.+1556   	; 0x74e <__bad_interrupt>
     13a:	00 00       	nop
     13c:	08 c3       	rjmp	.+1552   	; 0x74e <__bad_interrupt>
     13e:	00 00       	nop
     140:	06 c3       	rjmp	.+1548   	; 0x74e <__bad_interrupt>
     142:	00 00       	nop
     144:	04 c3       	rjmp	.+1544   	; 0x74e <__bad_interrupt>
     146:	00 00       	nop
     148:	02 c3       	rjmp	.+1540   	; 0x74e <__bad_interrupt>
     14a:	00 00       	nop
     14c:	00 c3       	rjmp	.+1536   	; 0x74e <__bad_interrupt>
     14e:	00 00       	nop
     150:	fe c2       	rjmp	.+1532   	; 0x74e <__bad_interrupt>
     152:	00 00       	nop
     154:	fc c2       	rjmp	.+1528   	; 0x74e <__bad_interrupt>
     156:	00 00       	nop
     158:	fa c2       	rjmp	.+1524   	; 0x74e <__bad_interrupt>
     15a:	00 00       	nop
     15c:	f8 c2       	rjmp	.+1520   	; 0x74e <__bad_interrupt>
     15e:	00 00       	nop
     160:	0c 94 3a 24 	jmp	0x4874	; 0x4874 <__vector_88>
     164:	0c 94 65 25 	jmp	0x4aca	; 0x4aca <__vector_89>
     168:	f2 c2       	rjmp	.+1508   	; 0x74e <__bad_interrupt>
     16a:	00 00       	nop
     16c:	f0 c2       	rjmp	.+1504   	; 0x74e <__bad_interrupt>
     16e:	00 00       	nop
     170:	ee c2       	rjmp	.+1500   	; 0x74e <__bad_interrupt>
     172:	00 00       	nop
     174:	ec c2       	rjmp	.+1496   	; 0x74e <__bad_interrupt>
     176:	00 00       	nop
     178:	ea c2       	rjmp	.+1492   	; 0x74e <__bad_interrupt>
     17a:	00 00       	nop
     17c:	e8 c2       	rjmp	.+1488   	; 0x74e <__bad_interrupt>
     17e:	00 00       	nop
     180:	e6 c2       	rjmp	.+1484   	; 0x74e <__bad_interrupt>
     182:	00 00       	nop
     184:	e4 c2       	rjmp	.+1480   	; 0x74e <__bad_interrupt>
     186:	00 00       	nop
     188:	e2 c2       	rjmp	.+1476   	; 0x74e <__bad_interrupt>
     18a:	00 00       	nop
     18c:	e0 c2       	rjmp	.+1472   	; 0x74e <__bad_interrupt>
     18e:	00 00       	nop
     190:	de c2       	rjmp	.+1468   	; 0x74e <__bad_interrupt>
     192:	00 00       	nop
     194:	dc c2       	rjmp	.+1464   	; 0x74e <__bad_interrupt>
     196:	00 00       	nop
     198:	da c2       	rjmp	.+1460   	; 0x74e <__bad_interrupt>
     19a:	00 00       	nop
     19c:	d8 c2       	rjmp	.+1456   	; 0x74e <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	d6 c2       	rjmp	.+1452   	; 0x74e <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	d4 c2       	rjmp	.+1448   	; 0x74e <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	d2 c2       	rjmp	.+1444   	; 0x74e <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	d0 c2       	rjmp	.+1440   	; 0x74e <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	ce c2       	rjmp	.+1436   	; 0x74e <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	cc c2       	rjmp	.+1432   	; 0x74e <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	ca c2       	rjmp	.+1428   	; 0x74e <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	c8 c2       	rjmp	.+1424   	; 0x74e <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	c6 c2       	rjmp	.+1420   	; 0x74e <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	c4 c2       	rjmp	.+1416   	; 0x74e <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	c2 c2       	rjmp	.+1412   	; 0x74e <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	c0 c2       	rjmp	.+1408   	; 0x74e <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	be c2       	rjmp	.+1404   	; 0x74e <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	bc c2       	rjmp	.+1400   	; 0x74e <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	ba c2       	rjmp	.+1396   	; 0x74e <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	0c 94 ca 24 	jmp	0x4994	; 0x4994 <__vector_119>
     1e0:	0c 94 0b 26 	jmp	0x4c16	; 0x4c16 <__vector_120>
     1e4:	b4 c2       	rjmp	.+1384   	; 0x74e <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	b2 c2       	rjmp	.+1380   	; 0x74e <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	b0 c2       	rjmp	.+1376   	; 0x74e <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	ae c2       	rjmp	.+1372   	; 0x74e <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	ac c2       	rjmp	.+1368   	; 0x74e <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	aa c2       	rjmp	.+1364   	; 0x74e <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	94 1d       	adc	r25, r4
     1fe:	23 1e       	adc	r2, r19
     200:	9e 1d       	adc	r25, r14
     202:	e2 1d       	adc	r30, r2
     204:	ee 1d       	adc	r30, r14
     206:	02 1e       	adc	r0, r18
     208:	13 1e       	adc	r1, r19

0000020a <__trampolines_end>:
     20a:	00 00       	nop
     20c:	00 00       	nop
     20e:	03 83       	std	Z+3, r16	; 0x03
     210:	6b f2       	brvs	.-102    	; 0x1ac <__SREG__+0x16d>
     212:	f7 70       	andi	r31, 0x07	; 7
     214:	3b e1       	ldi	r19, 0x1B	; 27
     216:	f4 f3       	brlt	.-4      	; 0x214 <__trampolines_end+0xa>
     218:	50 13       	cpse	r21, r16
     21a:	1f 97       	sbiw	r26, 0x0f	; 15
     21c:	9a c7       	rjmp	.+3892   	; 0x1152 <xQueueCreateMutex+0x16>
     21e:	1c 14       	cp	r1, r12
     220:	f1 35       	cpi	r31, 0x51	; 81
     222:	e8 e7       	ldi	r30, 0x78	; 120
     224:	a1 26       	eor	r10, r17
     226:	eb 64       	ori	r30, 0x4B	; 75
     228:	ca d4       	rcall	.+2452   	; 0xbbe <vPortYield+0x14>
     22a:	cf 58       	subi	r28, 0x8F	; 143
     22c:	d9 8a       	std	Y+17, r13	; 0x11
     22e:	cc db       	rcall	.-2152   	; 0xfffff9c8 <__eeprom_end+0xff7ef9c8>
     230:	b2 78       	andi	r27, 0x82	; 130
     232:	38 28       	or	r3, r8
     234:	e2 6b       	ori	r30, 0xB2	; 178
     236:	3b ab       	std	Y+51, r19	; 0x33
     238:	89 99       	sbic	0x11, 1	; 17
     23a:	d0 cf       	rjmp	.-96     	; 0x1dc <__SREG__+0x19d>
     23c:	43 4d       	sbci	r20, 0xD3	; 211
     23e:	d3 4c       	sbci	r29, 0xC3	; 195
     240:	28 bf       	out	0x38, r18	; 56
     242:	27 bf       	out	0x37, r18	; 55
     244:	78 ac       	ldd	r7, Y+56	; 0x38
     246:	24 3c       	cpi	r18, 0xC4	; 196
     248:	13 5e       	subi	r17, 0xE3	; 227
     24a:	6f c7       	rjmp	.+3806   	; 0x112a <xQueueGenericSend+0xfe>
     24c:	5e 10       	cpse	r5, r14
     24e:	6c 44       	sbci	r22, 0x4C	; 76
     250:	35 e2       	ldi	r19, 0x25	; 37
     252:	98 b7       	in	r25, 0x38	; 56
     254:	65 f1       	brhs	.+88     	; 0x2ae <__trampolines_end+0xa4>
     256:	9b 34       	cpi	r25, 0x4B	; 75
     258:	0e 03       	fmul	r16, r22
     25a:	70 50       	subi	r23, 0x00	; 0
     25c:	c4 d7       	rcall	.+3976   	; 0x11e6 <xQueueGenericReceive+0x6>
     25e:	73 d3       	rcall	.+1766   	; 0x946 <__vector_46>
     260:	af 25       	eor	r26, r15
     262:	87 20       	and	r8, r7
     264:	ff 36       	cpi	r31, 0x6F	; 111
     266:	84 a3       	std	Z+36, r24	; 0x24
     268:	94 c4       	rjmp	.+2344   	; 0xb92 <xPortStartScheduler+0x6c>
     26a:	a0 9f       	mul	r26, r16
     26c:	87 9a       	sbi	0x10, 7	; 16
     26e:	a3 1c       	adc	r10, r3
     270:	ec 68       	ori	r30, 0x8C	; 140
     272:	57 ef       	ldi	r21, 0xF7	; 247
     274:	bc 7b       	andi	r27, 0xBC	; 188
     276:	54 6c       	ori	r21, 0xC4	; 196
     278:	d7 89       	ldd	r29, Z+23	; 0x17
     27a:	bf 08       	sbc	r11, r15
     27c:	1d 5d       	subi	r17, 0xDD	; 221
     27e:	bc 8b       	std	Y+20, r27	; 0x14
     280:	76 af       	std	Z+62, r23	; 0x3e
     282:	48 78       	andi	r20, 0x88	; 136
     284:	26 bc       	out	0x26, r2	; 38
     286:	4b fb       	.word	0xfb4b	; ????
     288:	4d 4e       	sbci	r20, 0xED	; 237
     28a:	de 8e       	std	Y+30, r13	; 0x1e
     28c:	bd 20       	and	r11, r13
     28e:	dd 0d       	add	r29, r13
     290:	d6 d2       	rcall	.+1452   	; 0x83e <cspTask+0xee>
     292:	29 fe       	.word	0xfe29	; ????
     294:	86 c1       	rjmp	.+780    	; 0x5a2 <__trampolines_end+0x398>
     296:	2a 7d       	andi	r18, 0xDA	; 218
     298:	ed 33       	cpi	r30, 0x3D	; 61
     29a:	c1 19       	sub	r28, r1
     29c:	27 e7       	ldi	r18, 0x77	; 119
     29e:	c2 9a       	sbi	0x18, 2	; 24
     2a0:	4c 15       	cp	r20, r12
     2a2:	36 69       	ori	r19, 0x96	; 150
     2a4:	1c 06       	cpc	r1, r28
     2a6:	35 ea       	ldi	r19, 0xA5	; 165
     2a8:	77 f4       	brid	.+28     	; 0x2c6 <__trampolines_end+0xbc>
     2aa:	11 d6       	rcall	.+3106   	; 0xece <prvCopyDataToQueue+0x8e>
     2ac:	64 aa       	std	Z+52, r6	; 0x34
     2ae:	12 55       	subi	r17, 0x52	; 82
     2b0:	0f 58       	subi	r16, 0x8F	; 143
     2b2:	e6 a6       	std	Z+46, r14	; 0x2e
     2b4:	5f 4b       	sbci	r21, 0xBF	; 191
     2b6:	e5 25       	eor	r30, r5
     2b8:	34 b9       	out	0x04, r19	; 4
     2ba:	0e 41       	sbci	r16, 0x1E	; 30
     2bc:	fe 6d       	ori	r31, 0xDE	; 222
     2be:	0d c2       	rjmp	.+1050   	; 0x6da <__c.2159+0xcc>
     2c0:	95 9f       	mul	r25, r21
     2c2:	f9 31       	cpi	r31, 0x19	; 25
     2c4:	c5 8c       	ldd	r12, Z+29	; 0x1d
     2c6:	fa b2       	in	r15, 0x1a	; 26
     2c8:	ae 7e       	andi	r26, 0xEE	; 238
     2ca:	b1 49       	sbci	r27, 0x91	; 145
     2cc:	e3 30       	cpi	r30, 0x03	; 3
     2ce:	b2 ca       	rjmp	.-2716   	; 0xfffff834 <__eeprom_end+0xff7ef834>
     2d0:	88 c2       	rjmp	.+1296   	; 0x7e2 <cspTask+0x92>
     2d2:	46 39       	cpi	r20, 0x96	; 150
     2d4:	d8 d1       	rcall	.+944    	; 0x686 <__c.2159+0x78>
     2d6:	45 ba       	out	0x15, r4	; 21
     2d8:	b3 23       	and	r27, r19
     2da:	ae de       	rcall	.-676    	; 0x38 <__CCP__+0x4>
     2dc:	79 f7       	brne	.-34     	; 0x2bc <__trampolines_end+0xb2>
     2de:	ad 5d       	subi	r26, 0xDD	; 221
     2e0:	12 05       	cpc	r17, r2
     2e2:	59 ae       	std	Y+57, r5	; 0x39
     2e4:	42 16       	cp	r4, r18
     2e6:	5a 2d       	mov	r21, r10
     2e8:	29 e4       	ldi	r18, 0x49	; 73
     2ea:	7e 11       	cpse	r23, r14
     2ec:	3a ba       	out	0x1a, r3	; 26
     2ee:	7d 92       	st	X+, r7
     2f0:	51 48       	sbci	r21, 0x81	; 129
     2f2:	89 61       	ori	r24, 0x19	; 25
     2f4:	01 5b       	subi	r16, 0xB1	; 177
     2f6:	8a e2       	ldi	r24, 0x2A	; 42
     2f8:	6a a9       	ldd	r22, Y+50	; 0x32
     2fa:	61 86       	std	Z+9, r6	; 0x09
     2fc:	a0 7d       	andi	r26, 0xD0	; 208
     2fe:	62 05       	cpc	r22, r2
     300:	cb 8f       	std	Y+27, r28	; 0x1b
     302:	96 f6       	brtc	.-92     	; 0x2a8 <__trampolines_end+0x9e>
     304:	9b 9c       	mul	r9, r11
     306:	95 75       	andi	r25, 0x55	; 85
     308:	f0 6e       	ori	r31, 0xE0	; 224
     30a:	bc 1d       	adc	r27, r12
     30c:	7b 41       	sbci	r23, 0x1B	; 27
     30e:	bf 9e       	mul	r11, r31
     310:	10 b3       	in	r17, 0x10	; 16
     312:	4b 6d       	ori	r20, 0xDB	; 219
     314:	40 a0       	ldd	r4, Z+32	; 0x20
     316:	48 ee       	ldi	r20, 0xE8	; 232
     318:	2b 52       	subi	r18, 0x2B	; 43
     31a:	a3 8a       	std	Z+19, r10	; 0x13
     31c:	e1 86       	std	Z+9, r14	; 0x09
     31e:	a0 09       	sbc	r26, r0
     320:	8a 74       	andi	r24, 0x4A	; 74
     322:	54 fa       	bst	r5, 4
     324:	da 67       	ori	r29, 0x7A	; 122
     326:	57 79       	andi	r21, 0x97	; 151
     328:	b1 95       	neg	r27
     32a:	73 45       	sbci	r23, 0x53	; 83
     32c:	a2 cb       	rjmp	.-2236   	; 0xfffffa72 <__eeprom_end+0xff7efa72>
     32e:	70 c6       	rjmp	.+3296   	; 0x1010 <xQueueCreate+0x7c>
     330:	c9 39       	cpi	r28, 0x99	; 153
     332:	84 35       	cpi	r24, 0x54	; 84
     334:	99 2a       	or	r9, r25
     336:	87 b6       	in	r8, 0x37	; 55
     338:	f2 d8       	rcall	.-3612   	; 0xfffff51e <__eeprom_end+0xff7ef51e>
     33a:	6c d2       	rcall	.+1240   	; 0x814 <cspTask+0xc4>
     33c:	38 0c       	add	r3, r8
     33e:	6f 51       	subi	r22, 0x1F	; 31
     340:	53 fe       	sbrs	r5, 3
     342:	9b a2       	std	Y+35, r9	; 0x23
     344:	03 ed       	ldi	r16, 0xD3	; 211
     346:	98 21       	and	r25, r8
     348:	68 1f       	adc	r22, r24
     34a:	d3 da       	rcall	.-2650   	; 0xfffff8f2 <__eeprom_end+0xff7ef8f2>
     34c:	25 51       	subi	r18, 0x15	; 21
     34e:	d0 59       	subi	r29, 0x90	; 144
     350:	4e a3       	std	Y+38, r20	; 0x26
     352:	24 aa       	std	Z+52, r2	; 0x34
     354:	1e b0       	in	r1, 0x0e	; 14
     356:	27 29       	or	r18, r7
     358:	75 42       	sbci	r23, 0x25	; 37
     35a:	cc 4d       	sbci	r28, 0xDC	; 220
     35c:	bf 96       	adiw	r30, 0x2f	; 47
     35e:	cf ce       	rjmp	.-610    	; 0xfe <__SREG__+0xbf>
     360:	d4 64       	ori	r29, 0x44	; 68
     362:	3b 3d       	cpi	r19, 0xDB	; 219
     364:	84 77       	andi	r24, 0x74	; 116
     366:	38 be       	out	0x38, r3	; 56
     368:	ef 85       	ldd	r30, Y+15	; 0x0f
     36a:	1c 82       	std	Y+4, r1	; 0x04
     36c:	fc db       	rcall	.-2056   	; 0xfffffb66 <__eeprom_end+0xff7efb66>
     36e:	1f 01       	movw	r2, r30
     370:	97 29       	or	r25, r7
     372:	eb f2       	brvs	.-70     	; 0x32e <__trampolines_end+0x124>
     374:	c7 3a       	cpi	r28, 0xA7	; 167
     376:	e8 71       	andi	r30, 0x18	; 24
     378:	ac c8       	rjmp	.-3752   	; 0xfffff4d2 <__eeprom_end+0xff7ef4d2>
     37a:	03 15       	cp	r16, r3
     37c:	66 1c       	adc	r6, r6
     37e:	00 96       	adiw	r24, 0x00	; 0
     380:	0d ee       	ldi	r16, 0xED	; 237
     382:	f4 65       	ori	r31, 0x54	; 84
     384:	5d fd       	.word	0xfd5d	; ????
     386:	f7 e6       	ldi	r31, 0x67	; 103
     388:	36 0f       	add	r19, r22
     38a:	62 93       	st	-Z, r22
     38c:	c6 61       	ori	r28, 0x16	; 22
     38e:	61 10       	cpse	r6, r1
     390:	ad 93       	st	X+, r26	; undefined
     392:	95 e3       	ldi	r25, 0x35	; 53
     394:	fd 80       	ldd	r15, Y+5	; 0x05
     396:	96 60       	ori	r25, 0x06	; 6
     398:	96 72       	andi	r25, 0x26	; 38
     39a:	7d 04       	cpc	r7, r13
     39c:	5c a6       	std	Y+44, r5	; 0x2c
     39e:	7e 87       	std	Y+14, r23	; 0x0e
     3a0:	37 54       	subi	r19, 0x47	; 71
     3a2:	8a 74       	andi	r24, 0x4A	; 74
     3a4:	67 47       	sbci	r22, 0x77	; 119
     3a6:	89 f7       	brne	.-30     	; 0x38a <__trampolines_end+0x180>
     3a8:	0c b5       	in	r16, 0x2c	; 44
     3aa:	ad cb       	rjmp	.-2214   	; 0xfffffb06 <__eeprom_end+0xff7efb06>
     3ac:	1f eb       	ldi	r17, 0xBF	; 191
     3ae:	ae 48       	sbci	r26, 0x8E	; 142
     3b0:	74 19       	sub	r23, r4
     3b2:	5a bb       	out	0x1a, r21	; 26
     3b4:	24 0a       	sbc	r2, r20
     3b6:	59 38       	cpi	r21, 0x89	; 137
     3b8:	4f f8       	.word	0xf84f	; ????
     3ba:	b2 5c       	subi	r27, 0xC2	; 194
     3bc:	85 2c       	mov	r8, r5
     3be:	b1 df       	rcall	.-158    	; 0x322 <__trampolines_end+0x118>
     3c0:	ee de       	rcall	.-548    	; 0x19e <__SREG__+0x15f>
     3c2:	45 2c       	mov	r4, r5
     3c4:	be cd       	rjmp	.-1156   	; 0xffffff42 <__eeprom_end+0xff7eff42>
     3c6:	46 af       	std	Z+62, r20	; 0x3e
     3c8:	d5 3f       	cpi	r29, 0xF5	; 245
     3ca:	0d 54       	subi	r16, 0x4D	; 77
     3cc:	98 71       	andi	r25, 0x18	; 24
     3ce:	0e d7       	rcall	.+3612   	; 0x11ec <xQueueGenericReceive+0xc>
     3d0:	f3 83       	std	Z+3, r31	; 0x03
     3d2:	fa 24       	eor	r15, r10
     3d4:	a3 90       	.word	0x90a3	; ????
     3d6:	f9 a7       	std	Y+41, r31	; 0x29
     3d8:	c8 62       	ori	r28, 0x28	; 40
     3da:	12 c3       	rjmp	.+1572   	; 0xa00 <pvPortMalloc+0x12>
     3dc:	02 b6       	in	r0, 0x32	; 50
     3de:	11 40       	sbci	r17, 0x01	; 1
     3e0:	69 44       	sbci	r22, 0x49	; 73
     3e2:	e5 b3       	in	r30, 0x15	; 21
     3e4:	39 57       	subi	r19, 0x79	; 121
     3e6:	e6 30       	cpi	r30, 0x06	; 6
     3e8:	52 a5       	ldd	r21, Z+42	; 0x2a
     3ea:	c2 0c       	add	r12, r2
     3ec:	41 fb       	bst	r20, 1
     3ee:	c1 8f       	std	Z+25, r28	; 0x19
     3f0:	2a 09       	sbc	r18, r10
     3f2:	35 7c       	andi	r19, 0xC5	; 197
     3f4:	7a 1a       	sub	r7, r26
     3f6:	36 ff       	sbrs	r19, 6
     3f8:	11 e8       	ldi	r17, 0x81	; 129
     3fa:	dd 9b       	sbis	0x1b, 5	; 27
     3fc:	db 3c       	cpi	r29, 0xCB	; 203
     3fe:	de 18       	sub	r13, r14
     400:	b0 ce       	rjmp	.-672    	; 0x162 <__SREG__+0x123>
     402:	2a eb       	ldi	r18, 0xBA	; 186
     404:	e0 dd       	rcall	.-1088   	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     406:	29 68       	ori	r18, 0x89	; 137
     408:	8b 2f       	mov	r24, r27
     40a:	78 3b       	cpi	r23, 0xB8	; 184
     40c:	f6 82       	std	Z+6, r15	; 0x06
     40e:	7b b8       	out	0x0b, r7	; 11
     410:	9d 70       	andi	r25, 0x0D	; 13
     412:	8f 4b       	sbci	r24, 0xBF	; 191
     414:	cd 63       	ori	r28, 0x3D	; 61
     416:	8c c8       	rjmp	.-3816   	; 0xfffff530 <__eeprom_end+0xff7ef530>
     418:	a6 91       	elpm	r26, Z
     41a:	67 ac       	ldd	r6, Z+63	; 0x3f
     41c:	6c 45       	sbci	r22, 0x5C	; 92
     41e:	64 2f       	mov	r22, r20
     420:	07 b7       	in	r16, 0x37	; 55
     422:	90 dc       	rcall	.-1760   	; 0xfffffd44 <__eeprom_end+0xff7efd44>
     424:	57 a4       	ldd	r5, Z+47	; 0x2f
     426:	93 5f       	subi	r25, 0xF3	; 243
     428:	3c 56       	subi	r19, 0x6C	; 108
     42a:	b7 63       	ori	r27, 0x37	; 55
     42c:	2f 08       	sbc	r2, r15
     42e:	b4 e0       	ldi	r27, 0x04	; 4
     430:	44 fa       	bst	r4, 4
     432:	40 13       	cpse	r20, r16
     434:	14 e9       	ldi	r17, 0x94	; 148
     436:	43 90       	.word	0x9043	; ????
     438:	7f 1b       	sub	r23, r31
     43a:	a8 f4       	brcc	.+42     	; 0x466 <__trampolines_end+0x25c>
     43c:	b5 cf       	rjmp	.-150    	; 0x3a8 <__trampolines_end+0x19e>
     43e:	ab 77       	andi	r26, 0x7B	; 123
     440:	de 3d       	cpi	r29, 0xDE	; 222
     442:	5f 84       	ldd	r5, Y+15	; 0x0f
     444:	8e 2e       	mov	r8, r30
     446:	5c 07       	cpc	r21, r28
     448:	e5 dc       	rcall	.-1590   	; 0xfffffe14 <__eeprom_end+0xff7efe14>
     44a:	17 fc       	sbrc	r1, 7
     44c:	a8 92       	.word	0x92a8	; ????
     44e:	14 7f       	andi	r17, 0xF4	; 244
     450:	c3 60       	ori	r28, 0x03	; 3
     452:	e0 8c       	ldd	r14, Z+24	; 0x18
     454:	93 73       	andi	r25, 0x33	; 51
     456:	e3 0f       	add	r30, r19
     458:	f8 81       	ld	r31, Y
     45a:	08 6b       	ori	r16, 0xB8	; 184
     45c:	32 55       	subi	r19, 0x52	; 82
     45e:	0b e8       	ldi	r16, 0x8B	; 139
     460:	59 a7       	std	Y+41, r21	; 0x29
     462:	ff 1b       	sub	r31, r31
     464:	09 b4       	in	r0, 0x29	; 41
     466:	fc 98       	cbi	0x1f, 4	; 31
     468:	62 46       	sbci	r22, 0x62	; 98
     46a:	d8 a4       	ldd	r13, Y+40	; 0x28
     46c:	71 18       	sub	r7, r1
     46e:	db 27       	eor	r29, r27
     470:	1a ea       	ldi	r17, 0xAA	; 170
     472:	2f d4       	rcall	.+2142   	; 0xcd2 <__vector_14+0x78>
     474:	4a f9       	.word	0xf94a	; ????
     476:	2c 57       	subi	r18, 0x7C	; 124
     478:	21 0b       	sbc	r18, r17
     47a:	c7 33       	cpi	r28, 0x37	; 55
     47c:	eb df       	rcall	.-42     	; 0x454 <__trampolines_end+0x24a>
     47e:	c4 b0       	in	r12, 0x04	; 4
     480:	80 2d       	mov	r24, r0
     482:	30 43       	sbci	r19, 0x30	; 48
     484:	d0 3e       	cpi	r29, 0xE0	; 224
     486:	33 c0       	rjmp	.+102    	; 0x4ee <__trampolines_end+0x2e4>
     488:	bb cc       	rjmp	.-1674   	; 0xfffffe00 <__eeprom_end+0xff7efe00>
     48a:	a6 b5       	in	r26, 0x26	; 38
     48c:	4b a2       	std	Y+35, r4	; 0x23
     48e:	a5 36       	cpi	r26, 0x65	; 101
     490:	20 50       	subi	r18, 0x00	; 0
     492:	51 c5       	rjmp	.+2722   	; 0xf36 <prvUnlockQueue+0x2a>
     494:	70 43       	sbci	r23, 0x30	; 48
     496:	52 46       	sbci	r21, 0x62	; 98
     498:	1b b1       	in	r17, 0x0b	; 11
     49a:	b9 22       	and	r11, r25
     49c:	d1 65       	ori	r29, 0x51	; 81
     49e:	ba a1       	ldd	r27, Y+34	; 0x22
     4a0:	ba 97       	sbiw	r30, 0x2a	; 42
     4a2:	4e 52       	subi	r20, 0x2E	; 46
     4a4:	ea 84       	ldd	r14, Y+10	; 0x0a
     4a6:	4d d1       	rcall	.+666    	; 0x742 <.do_clear_bss_start+0x2>
     4a8:	81 76       	andi	r24, 0x61	; 97
     4aa:	69 ed       	ldi	r22, 0xD9	; 217
     4ac:	92 28       	or	r9, r2
     4ae:	6a 6e       	ori	r22, 0xEA	; 234
     4b0:	f9 da       	rcall	.-2574   	; 0xfffffaa4 <__eeprom_end+0xff7efaa4>
     4b2:	9e 9d       	mul	r25, r14
     4b4:	a9 c9       	rjmp	.-3246   	; 0xfffff808 <__eeprom_end+0xff7ef808>
     4b6:	9d 1e       	adc	r9, r29
     4b8:	c2 3b       	cpi	r28, 0xB2	; 178
     4ba:	76 7a       	andi	r23, 0xA6	; 166
     4bc:	08 ef       	ldi	r16, 0xF8	; 248
     4be:	75 f9       	bld	r23, 5
     4c0:	63 1d       	adc	r22, r3
     4c2:	81 0a       	sbc	r8, r17
     4c4:	33 0e       	add	r3, r19
     4c6:	82 89       	ldd	r24, Z+18	; 0x12
     4c8:	58 fc       	.word	0xfc58	; ????
     4ca:	c9 72       	andi	r28, 0x29	; 41
     4cc:	15 b2       	in	r1, 0x15	; 21
     4ce:	ca f1       	brmi	.+114    	; 0x542 <__trampolines_end+0x338>
     4d0:	7e 40       	sbci	r23, 0x0E	; 14
     4d2:	3e 02       	muls	r19, r30
     4d4:	2e 53       	subi	r18, 0x3E	; 62
     4d6:	3d 81       	ldd	r19, Y+5	; 0x05
     4d8:	45 a1       	ldd	r20, Z+37	; 0x25
     4da:	d6 e5       	ldi	r29, 0x56	; 86
     4dc:	8f 75       	andi	r24, 0x5F	; 95
     4de:	d5 66       	ori	r29, 0x65	; 101
     4e0:	e4 87       	std	Z+12, r30	; 0x0c
     4e2:	21 95       	neg	r18
     4e4:	b4 94       	.word	0x94b4	; ????
     4e6:	22 16       	cp	r2, r18
     4e8:	df 66       	ori	r29, 0x6F	; 111
     4ea:	06 2a       	or	r0, r22
     4ec:	cc 38       	cpi	r28, 0x8C	; 140
     4ee:	05 a9       	ldd	r16, Z+53	; 0x35
     4f0:	a7 ca       	rjmp	.-2738   	; 0xfffffa40 <__eeprom_end+0xff7efa40>
     4f2:	f1 5a       	subi	r31, 0xA1	; 161
     4f4:	f7 d9       	rcall	.-3090   	; 0xfffff8e4 <__eeprom_end+0xff7ef8e4>
     4f6:	f2 d9       	rcall	.-3100   	; 0xfffff8dc <__eeprom_end+0xff7ef8dc>
     4f8:	9c 2b       	or	r25, r28
     4fa:	19 bd       	out	0x29, r17	; 41
     4fc:	56 ff       	sbrs	r21, 6
     4fe:	1a 3e       	cpi	r17, 0xEA	; 234
     500:	3d 0d       	add	r19, r13
     502:	ee cd       	rjmp	.-1060   	; 0xe0 <__SREG__+0xa1>
     504:	6d 1e       	adc	r6, r29
     506:	ed 4e       	sbci	r30, 0xED	; 237
     508:	06 ec       	ldi	r16, 0xC6	; 198
     50a:	c4 26       	eor	r12, r20
     50c:	8d c3       	rjmp	.+1818   	; 0xc28 <vPortYield+0x7e>
     50e:	c7 a5       	ldd	r28, Z+47	; 0x2f
     510:	e6 31       	cpi	r30, 0x16	; 22
     512:	33 56       	subi	r19, 0x63	; 99
     514:	b6 22       	and	r11, r22
     516:	30 d5       	rcall	.+2656   	; 0xf78 <prvUnlockQueue+0x6c>
     518:	dd d0       	rcall	.+442    	; 0x6d4 <__c.2159+0xc6>
     51a:	db b1       	in	r29, 0x0b	; 11
     51c:	17 04       	cpc	r1, r7
     51e:	d8 32       	cpi	r29, 0x28	; 40
     520:	7c f6       	brge	.-98     	; 0x4c0 <__trampolines_end+0x2b6>
     522:	2c c1       	rjmp	.+600    	; 0x77c <cspTask+0x2c>
     524:	2c e5       	ldi	r18, 0x5C	; 92
     526:	2f 42       	sbci	r18, 0x2F	; 47
     528:	47 17       	cp	r20, r23
     52a:	0b 7e       	andi	r16, 0xEB	; 235
     52c:	54 49       	sbci	r21, 0x94	; 148
     52e:	08 fd       	.word	0xfd08	; ????
     530:	3f bb       	out	0x1f, r19	; 31
     532:	fc 0e       	add	r15, r28
     534:	6f a8       	ldd	r6, Y+55	; 0x37
     536:	ff 8d       	ldd	r31, Y+31	; 0x1f
     538:	04 5a       	subi	r16, 0xA4	; 164
     53a:	14 e9       	ldi	r17, 0x94	; 148
     53c:	ce 8e       	std	Y+30, r12	; 0x1e
     53e:	17 6a       	ori	r17, 0xA7	; 167
     540:	a5 7c       	andi	r26, 0xC5	; 197
     542:	e3 99       	sbic	0x1c, 3	; 28
     544:	f5 6f       	ori	r31, 0xF5	; 245
     546:	e0 1a       	sub	r14, r16
     548:	9e 9d       	mul	r25, r14
     54a:	ab e1       	ldi	r26, 0x1B	; 27
     54c:	d3 d3       	rcall	.+1958   	; 0xcf4 <__vector_14+0x9a>
     54e:	a8 62       	ori	r26, 0x28	; 40
     550:	b8 21       	and	r27, r8
     552:	5c 91       	ld	r21, X
     554:	e8 32       	cpi	r30, 0x28	; 40
     556:	5f 12       	cpse	r5, r31
     558:	83 c0       	rjmp	.+262    	; 0x660 <__c.2159+0x52>
     55a:	b4 76       	andi	r27, 0x64	; 100
     55c:	49 14       	cp	r4, r9
     55e:	b7 f5       	brid	.+108    	; 0x5cc <__trampolines_end+0x3c2>
     560:	22 e6       	ldi	r18, 0x62	; 98
     562:	43 06       	cpc	r4, r19
     564:	72 f5       	brpl	.+92     	; 0x5c2 <__trampolines_end+0x3b8>
     566:	40 85       	ldd	r20, Z+8	; 0x08
     568:	19 07       	cpc	r17, r25
     56a:	64 b9       	out	0x04, r22	; 4
     56c:	0a 59       	subi	r16, 0x9A	; 154
     56e:	67 3a       	cpi	r22, 0xA7	; 167
     570:	61 ab       	std	Z+49, r22	; 0x31
     572:	93 c9       	rjmp	.-3290   	; 0xfffff89a <__eeprom_end+0xff7ef89a>
     574:	31 b8       	out	0x01, r3	; 1
     576:	90 4a       	sbci	r25, 0xA0	; 160
     578:	5a 4a       	sbci	r21, 0xAA	; 170
     57a:	7b 2e       	mov	r7, r27
     57c:	90 9e       	mul	r9, r16
     57e:	78 ad       	ldd	r23, Y+56	; 0x38
     580:	fb 6c       	ori	r31, 0xCB	; 203
     582:	8c 5e       	subi	r24, 0xEC	; 236
     584:	ab 7f       	andi	r26, 0xFB	; 251
     586:	8f dd       	rcall	.-1250   	; 0xa6 <__SREG__+0x67>
     588:	c0 8d       	ldd	r28, Z+24	; 0x18
     58a:	1a a8       	ldd	r1, Y+50	; 0x32
     58c:	30 e3       	ldi	r19, 0x30	; 48
     58e:	19 2b       	or	r17, r25
     590:	5b 11       	cpse	r21, r11
     592:	ed d8       	rcall	.-3622   	; 0xfffff76e <__eeprom_end+0xff7ef76e>
     594:	0b 02       	muls	r16, r27
     596:	ee 5b       	subi	r30, 0xBE	; 190
     598:	60 f0       	brcs	.+24     	; 0x5b2 <__trampolines_end+0x3a8>
     59a:	05 3f       	cpi	r16, 0xF5	; 245
     59c:	aa 24       	eor	r10, r10
     59e:	06 bc       	out	0x26, r0	; 38
     5a0:	c1 d6       	rcall	.+3458   	; 0x1324 <xQueueGenericReceive+0x144>
     5a2:	f2 4f       	sbci	r31, 0xF2	; 242
     5a4:	91 c5       	rjmp	.+2850   	; 0x10c8 <xQueueGenericSend+0x9c>
     5a6:	f1 cc       	rjmp	.-1566   	; 0xffffff8a <__eeprom_end+0xff7eff8a>
     5a8:	fa 37       	cpi	r31, 0x7A	; 122
     5aa:	d5 f0       	brhs	.+52     	; 0x5e0 <__trampolines_end+0x3d6>
     5ac:	e9 69       	ori	r30, 0x99	; 153
     5ae:	d6 73       	andi	r29, 0x36	; 54
     5b0:	82 9b       	sbis	0x10, 2	; 16
     5b2:	22 80       	ldd	r2, Z+2	; 0x02
     5b4:	d2 88       	ldd	r13, Z+18	; 0x12
     5b6:	21 03       	mulsu	r18, r17
     5b8:	b9 7a       	andi	r27, 0xA9	; 169
     5ba:	ca 67       	ori	r28, 0x7A	; 122
     5bc:	73 ae       	std	Z+59, r7	; 0x3b
     5be:	c9 e4       	ldi	r28, 0x49	; 73
     5c0:	18 5c       	subi	r17, 0xC8	; 200
     5c2:	3d 17       	cp	r19, r29
     5c4:	48 4f       	sbci	r20, 0xF8	; 248
     5c6:	3e 94 23 bd 	call	0xd7a46	; 0xd7a46 <__data_load_end+0xd1b72>
     5ca:	75 6f       	ori	r23, 0xF5	; 245
     5cc:	6e f3       	brts	.-38     	; 0x5a8 <__trampolines_end+0x39e>
     5ce:	76 ec       	ldi	r23, 0xC6	; 198
     5d0:	05 01       	movw	r0, r10
     5d2:	82 1f       	adc	r24, r18
     5d4:	55 12       	cpse	r5, r21
     5d6:	81 9c       	mul	r8, r1
     5d8:	3e e0       	ldi	r19, 0x0E	; 14
     5da:	6a f8       	.word	0xf86a	; ????
     5dc:	f4 34       	cpi	r31, 0x44	; 68
     5de:	69 7b       	andi	r22, 0xB9	; 185
     5e0:	9f c6       	rjmp	.+3390   	; 0x1320 <xQueueGenericReceive+0x140>
     5e2:	9d 88       	ldd	r9, Y+21	; 0x15
     5e4:	cf d5       	rcall	.+2974   	; 0x1184 <xQueueCreateMutex+0x48>
     5e6:	9e 0b       	sbc	r25, r30
     5e8:	a4 27       	eor	r26, r20
     5ea:	ba 37       	cpi	r27, 0x7A	; 122
     5ec:	b7 79       	andi	r27, 0x97	; 151
     5ee:	b9 b4       	in	r11, 0x29	; 41
     5f0:	dc 8b       	std	Y+20, r29	; 0x14
     5f2:	4d 47       	sbci	r20, 0x7D	; 125
     5f4:	8c 98       	cbi	0x11, 4	; 17
     5f6:	4e c4       	rjmp	.+2204   	; 0xe94 <prvCopyDataToQueue+0x54>
     5f8:	e7 6a       	ori	r30, 0xA7	; 167
     5fa:	a5 a0       	ldd	r10, Z+37	; 0x25
     5fc:	2d be       	out	0x3d, r2	; 61
     5fe:	a6 23       	and	r26, r22
     600:	46 4c       	sbci	r20, 0xC6	; 198
     602:	52 d0       	rcall	.+164    	; 0x6a8 <__c.2159+0x9a>
     604:	16 5f       	subi	r17, 0xF6	; 246
     606:	51 53       	subi	r21, 0x31	; 49
     608:	7d ad       	ldd	r23, Y+61	; 0x3d

0000060a <__c.2161>:
     60a:	6e 61 6e 00                                         nan.

0000060e <__c.2159>:
     60e:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     61e:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     62e:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     63e:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     64e:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     65e:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     66e:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     67e:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     68e:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     69e:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     6ae:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     6be:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     6ce:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     6de:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     6ee:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     6fe:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000070c <__ctors_end>:
     70c:	11 24       	eor	r1, r1
     70e:	1f be       	out	0x3f, r1	; 63
     710:	cf ef       	ldi	r28, 0xFF	; 255
     712:	cd bf       	out	0x3d, r28	; 61
     714:	df e3       	ldi	r29, 0x3F	; 63
     716:	de bf       	out	0x3e, r29	; 62
     718:	00 e0       	ldi	r16, 0x00	; 0
     71a:	0c bf       	out	0x3c, r16	; 60

0000071c <__do_copy_data>:
     71c:	11 e2       	ldi	r17, 0x21	; 33
     71e:	a0 e0       	ldi	r26, 0x00	; 0
     720:	b0 e2       	ldi	r27, 0x20	; 32
     722:	e6 eb       	ldi	r30, 0xB6	; 182
     724:	fd e5       	ldi	r31, 0x5D	; 93
     726:	00 e0       	ldi	r16, 0x00	; 0
     728:	0b bf       	out	0x3b, r16	; 59
     72a:	02 c0       	rjmp	.+4      	; 0x730 <__do_copy_data+0x14>
     72c:	07 90       	elpm	r0, Z+
     72e:	0d 92       	st	X+, r0
     730:	ae 31       	cpi	r26, 0x1E	; 30
     732:	b1 07       	cpc	r27, r17
     734:	d9 f7       	brne	.-10     	; 0x72c <__do_copy_data+0x10>

00000736 <__do_clear_bss>:
     736:	2f e3       	ldi	r18, 0x3F	; 63
     738:	ae e1       	ldi	r26, 0x1E	; 30
     73a:	b1 e2       	ldi	r27, 0x21	; 33
     73c:	01 c0       	rjmp	.+2      	; 0x740 <.do_clear_bss_start>

0000073e <.do_clear_bss_loop>:
     73e:	1d 92       	st	X+, r1

00000740 <.do_clear_bss_start>:
     740:	a6 39       	cpi	r26, 0x96	; 150
     742:	b2 07       	cpc	r27, r18
     744:	e1 f7       	brne	.-8      	; 0x73e <.do_clear_bss_loop>
     746:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <main>
     74a:	0c 94 d9 2e 	jmp	0x5db2	; 0x5db2 <_exit>

0000074e <__bad_interrupt>:
     74e:	58 cc       	rjmp	.-1872   	; 0x0 <__vectors>

00000750 <cspTask>:
/*	Task that handles CSP incoming packets								*/
/* -------------------------------------------------------------------- */
void cspTask(void *p) {
	
	/* Create socket without any socket options */
	csp_socket_t * sock = csp_socket(CSP_SO_NONE);
     750:	60 e0       	ldi	r22, 0x00	; 0
     752:	70 e0       	ldi	r23, 0x00	; 0
     754:	cb 01       	movw	r24, r22
     756:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <csp_socket>
     75a:	7c 01       	movw	r14, r24

	/* Bind all ports to socket */
	csp_bind(sock, CSP_ANY);
     75c:	60 e2       	ldi	r22, 0x20	; 32
     75e:	0e 94 0e 19 	call	0x321c	; 0x321c <csp_bind>

	/* Create 10 connections backlog queue */
	csp_listen(sock, 10);
     762:	6a e0       	ldi	r22, 0x0A	; 10
     764:	70 e0       	ldi	r23, 0x00	; 0
     766:	c7 01       	movw	r24, r14
     768:	0e 94 f3 18 	call	0x31e6	; 0x31e6 <csp_listen>

	/* Pointer to current connection and packet */
	csp_conn_t * conn;
	csp_packet_t * packet;
	
	xCSPEventQueue = xQueueCreate(10, (portBASE_TYPE) sizeof(xCSPStackEvent_t));
     76c:	63 e0       	ldi	r22, 0x03	; 3
     76e:	8a e0       	ldi	r24, 0x0A	; 10
     770:	11 d4       	rcall	.+2082   	; 0xf94 <xQueueCreate>
     772:	80 93 d7 3e 	sts	0x3ED7, r24
     776:	90 93 d8 3e 	sts	0x3ED8, r25
					
				/* if Port 16 packet received */
				// Free Heap space in Human readable form
				case 16:
				
					newEvent->eEventType = freeHeapEvent;
     77a:	bb 24       	eor	r11, r11
     77c:	b3 94       	inc	r11
				
				/* if Port 17 packet received */
				// Return info status message
				case 17:
				
					newEvent->eEventType = housKeepingEvent;
     77e:	68 94       	set
     780:	cc 24       	eor	r12, r12
     782:	c1 f8       	bld	r12, 1
				
				/* if Port 18 packet received */
				// Return value of ADC
				case 18:
				
					newEvent->eEventType = AdcConvertEvent;
     784:	0f 2e       	mov	r0, r31
     786:	f3 e0       	ldi	r31, 0x03	; 3
     788:	df 2e       	mov	r13, r31
     78a:	f0 2d       	mov	r31, r0

	/* Process incoming connections */
	while (1) {
		
		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
     78c:	40 e1       	ldi	r20, 0x10	; 16
     78e:	57 e2       	ldi	r21, 0x27	; 39
     790:	60 e0       	ldi	r22, 0x00	; 0
     792:	70 e0       	ldi	r23, 0x00	; 0
     794:	c7 01       	movw	r24, r14
     796:	0e 94 30 17 	call	0x2e60	; 0x2e60 <csp_accept>
     79a:	8c 01       	movw	r16, r24
     79c:	00 97       	sbiw	r24, 0x00	; 0
     79e:	b1 f3       	breq	.-20     	; 0x78c <cspTask+0x3c>
     7a0:	50 c0       	rjmp	.+160    	; 0x842 <cspTask+0xf2>
		continue;

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 10)) != NULL) {
			switch (csp_conn_dport(conn)) {
     7a2:	c8 01       	movw	r24, r16
     7a4:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <csp_conn_dport>
     7a8:	80 31       	cpi	r24, 0x10	; 16
     7aa:	91 05       	cpc	r25, r1
     7ac:	c9 f0       	breq	.+50     	; 0x7e0 <cspTask+0x90>
     7ae:	1c f4       	brge	.+6      	; 0x7b6 <cspTask+0x66>
     7b0:	0f 97       	sbiw	r24, 0x0f	; 15
     7b2:	39 f0       	breq	.+14     	; 0x7c2 <cspTask+0x72>
     7b4:	42 c0       	rjmp	.+132    	; 0x83a <cspTask+0xea>
     7b6:	81 31       	cpi	r24, 0x11	; 17
     7b8:	91 05       	cpc	r25, r1
     7ba:	09 f1       	breq	.+66     	; 0x7fe <cspTask+0xae>
     7bc:	42 97       	sbiw	r24, 0x12	; 18
     7be:	71 f1       	breq	.+92     	; 0x81c <cspTask+0xcc>
     7c0:	3c c0       	rjmp	.+120    	; 0x83a <cspTask+0xea>
				
				/* if Port 15 packet received */
				// Echo back the incoming packet
				case 15:
				
					newEvent->eEventType = echoBackEvent;
     7c2:	e0 e0       	ldi	r30, 0x00	; 0
     7c4:	f0 e0       	ldi	r31, 0x00	; 0
     7c6:	10 82       	st	Z, r1
					newEvent->pvData = packet;
     7c8:	c1 83       	std	Z+1, r28	; 0x01
     7ca:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	4a e0       	ldi	r20, 0x0A	; 10
     7d0:	50 e0       	ldi	r21, 0x00	; 0
     7d2:	bf 01       	movw	r22, r30
     7d4:	80 91 d7 3e 	lds	r24, 0x3ED7
     7d8:	90 91 d8 3e 	lds	r25, 0x3ED8
     7dc:	27 d4       	rcall	.+2126   	; 0x102c <xQueueGenericSend>
					
				break;
     7de:	31 c0       	rjmp	.+98     	; 0x842 <cspTask+0xf2>
					
				/* if Port 16 packet received */
				// Free Heap space in Human readable form
				case 16:
				
					newEvent->eEventType = freeHeapEvent;
     7e0:	e0 e0       	ldi	r30, 0x00	; 0
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	b0 82       	st	Z, r11
					newEvent->pvData = packet;
     7e6:	c1 83       	std	Z+1, r28	; 0x01
     7e8:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);	
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	4a e0       	ldi	r20, 0x0A	; 10
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	bf 01       	movw	r22, r30
     7f2:	80 91 d7 3e 	lds	r24, 0x3ED7
     7f6:	90 91 d8 3e 	lds	r25, 0x3ED8
     7fa:	18 d4       	rcall	.+2096   	; 0x102c <xQueueGenericSend>
					
				break;	
     7fc:	22 c0       	rjmp	.+68     	; 0x842 <cspTask+0xf2>
				
				/* if Port 17 packet received */
				// Return info status message
				case 17:
				
					newEvent->eEventType = housKeepingEvent;
     7fe:	e0 e0       	ldi	r30, 0x00	; 0
     800:	f0 e0       	ldi	r31, 0x00	; 0
     802:	c0 82       	st	Z, r12
					newEvent->pvData = packet;
     804:	c1 83       	std	Z+1, r28	; 0x01
     806:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
     808:	20 e0       	ldi	r18, 0x00	; 0
     80a:	4a e0       	ldi	r20, 0x0A	; 10
     80c:	50 e0       	ldi	r21, 0x00	; 0
     80e:	bf 01       	movw	r22, r30
     810:	80 91 d7 3e 	lds	r24, 0x3ED7
     814:	90 91 d8 3e 	lds	r25, 0x3ED8
     818:	09 d4       	rcall	.+2066   	; 0x102c <xQueueGenericSend>
				
				break;		
     81a:	13 c0       	rjmp	.+38     	; 0x842 <cspTask+0xf2>
				
				/* if Port 18 packet received */
				// Return value of ADC
				case 18:
				
					newEvent->eEventType = AdcConvertEvent;
     81c:	e0 e0       	ldi	r30, 0x00	; 0
     81e:	f0 e0       	ldi	r31, 0x00	; 0
     820:	d0 82       	st	Z, r13
					newEvent->pvData = packet;
     822:	c1 83       	std	Z+1, r28	; 0x01
     824:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	4a e0       	ldi	r20, 0x0A	; 10
     82a:	50 e0       	ldi	r21, 0x00	; 0
     82c:	bf 01       	movw	r22, r30
     82e:	80 91 d7 3e 	lds	r24, 0x3ED7
     832:	90 91 d8 3e 	lds	r25, 0x3ED8
     836:	fa d3       	rcall	.+2036   	; 0x102c <xQueueGenericSend>
				
				break;
     838:	04 c0       	rjmp	.+8      	; 0x842 <cspTask+0xf2>
				
				/* Process packet here */
				default:
				
				/* Let the service handler reply pings, buffer use, etc. */
				csp_service_handler(conn, packet);
     83a:	be 01       	movw	r22, r28
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 7e 1d 	call	0x3afc	; 0x3afc <csp_service_handler>
		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
		continue;

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 10)) != NULL) {
     842:	4a e0       	ldi	r20, 0x0A	; 10
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	60 e0       	ldi	r22, 0x00	; 0
     848:	70 e0       	ldi	r23, 0x00	; 0
     84a:	c8 01       	movw	r24, r16
     84c:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <csp_read>
     850:	ec 01       	movw	r28, r24
     852:	00 97       	sbiw	r24, 0x00	; 0
     854:	09 f0       	breq	.+2      	; 0x858 <cspTask+0x108>
     856:	a5 cf       	rjmp	.-182    	; 0x7a2 <cspTask+0x52>
				break;
			}
		}

		/* Close current connection, and handle next */
		csp_close(conn);
     858:	c8 01       	movw	r24, r16
     85a:	0e 94 78 15 	call	0x2af0	; 0x2af0 <csp_close>
     85e:	96 cf       	rjmp	.-212    	; 0x78c <cspTask+0x3c>

00000860 <TWI_CSP_SlaveProcessData>:
TWI_Slave_t twi_csp_slave;			/*!< TWI slave module. */
i2c_callback_t callbackFunction;

// this function processes received data on the I2C Slave line
// It is call by the I2C driver
void TWI_CSP_SlaveProcessData(void) {
     860:	cf 93       	push	r28
     862:	df 93       	push	r29
     864:	cd b7       	in	r28, 0x3d	; 61
     866:	de b7       	in	r29, 0x3e	; 62
     868:	ca 50       	subi	r28, 0x0A	; 10
     86a:	d1 40       	sbci	r29, 0x01	; 1
     86c:	cd bf       	out	0x3d, r28	; 61
     86e:	de bf       	out	0x3e, r29	; 62
	
	if (twi_csp_slave.result == TWIS_RESULT_OK) {
     870:	80 91 29 3f 	lds	r24, 0x3F29
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	49 f5       	brne	.+82     	; 0x8ca <TWI_CSP_SlaveProcessData+0x6a>
		
		i2c_frame_t newFrame;
		
		if (twi_csp_slave.bytesReceived > 0) {
     878:	80 91 26 3f 	lds	r24, 0x3F26
     87c:	88 23       	and	r24, r24
     87e:	e1 f0       	breq	.+56     	; 0x8b8 <TWI_CSP_SlaveProcessData+0x58>
			
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
     880:	e6 e2       	ldi	r30, 0x26	; 38
     882:	ff e3       	ldi	r31, 0x3F	; 63
     884:	80 81       	ld	r24, Z
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	89 87       	std	Y+9, r24	; 0x09
     88a:	9a 87       	std	Y+10, r25	; 0x0a
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
     88c:	80 81       	ld	r24, Z
     88e:	88 23       	and	r24, r24
     890:	99 f0       	breq	.+38     	; 0x8b8 <TWI_CSP_SlaveProcessData+0x58>
     892:	fe 01       	movw	r30, r28
     894:	3b 96       	adiw	r30, 0x0b	; 11
     896:	80 e0       	ldi	r24, 0x00	; 0
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	46 e2       	ldi	r20, 0x26	; 38
     89c:	5f e3       	ldi	r21, 0x3F	; 63
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
     89e:	dc 01       	movw	r26, r24
     8a0:	a7 52       	subi	r26, 0x27	; 39
     8a2:	b1 4c       	sbci	r27, 0xC1	; 193
     8a4:	14 96       	adiw	r26, 0x04	; 4
     8a6:	2c 91       	ld	r18, X
     8a8:	21 93       	st	Z+, r18
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
     8aa:	01 96       	adiw	r24, 0x01	; 1
     8ac:	da 01       	movw	r26, r20
     8ae:	2c 91       	ld	r18, X
     8b0:	30 e0       	ldi	r19, 0x00	; 0
     8b2:	82 17       	cp	r24, r18
     8b4:	93 07       	cpc	r25, r19
     8b6:	9c f3       	brlt	.-26     	; 0x89e <TWI_CSP_SlaveProcessData+0x3e>
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
			}
		}
		
		callbackFunction(&newFrame, false);
     8b8:	e0 91 7d 3f 	lds	r30, 0x3F7D
     8bc:	f0 91 7e 3f 	lds	r31, 0x3F7E
     8c0:	60 e0       	ldi	r22, 0x00	; 0
     8c2:	70 e0       	ldi	r23, 0x00	; 0
     8c4:	ce 01       	movw	r24, r28
     8c6:	01 96       	adiw	r24, 0x01	; 1
     8c8:	19 95       	eicall
		
	}
}
     8ca:	c6 5f       	subi	r28, 0xF6	; 246
     8cc:	de 4f       	sbci	r29, 0xFE	; 254
     8ce:	cd bf       	out	0x3d, r28	; 61
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	08 95       	ret

000008d8 <i2c_init>:

// Initialize the i2c interface for CSP
int i2c_init(int handle, int mode, uint8_t addr, uint16_t speed, int queue_len_tx, int queue_len_rx, i2c_callback_t callback) {
     8d8:	cf 92       	push	r12
     8da:	df 92       	push	r13
     8dc:	cf 93       	push	r28
     8de:	c4 2f       	mov	r28, r20
	
	// Initialize TWI master for CSP
	TWI_MasterInit(&twi_csp_master, &CSP_I2C_INTERFACE, TWI_MASTER_INTLVL_LO_gc, speed);
     8e0:	40 e4       	ldi	r20, 0x40	; 64
     8e2:	60 ea       	ldi	r22, 0xA0	; 160
     8e4:	74 e0       	ldi	r23, 0x04	; 4
     8e6:	8b e2       	ldi	r24, 0x2B	; 43
     8e8:	9f e3       	ldi	r25, 0x3F	; 63
     8ea:	0e 94 b9 21 	call	0x4372	; 0x4372 <TWI_MasterInit>
			
	// Initialize TWI slave for CSP
	TWI_SlaveInitializeDriver(&twi_csp_slave, &CSP_I2C_INTERFACE, TWI_CSP_SlaveProcessData);
     8ee:	40 e3       	ldi	r20, 0x30	; 48
     8f0:	54 e0       	ldi	r21, 0x04	; 4
     8f2:	60 ea       	ldi	r22, 0xA0	; 160
     8f4:	74 e0       	ldi	r23, 0x04	; 4
     8f6:	89 ed       	ldi	r24, 0xD9	; 217
     8f8:	9e e3       	ldi	r25, 0x3E	; 62
     8fa:	0e 94 df 22 	call	0x45be	; 0x45be <TWI_SlaveInitializeDriver>
	TWI_SlaveInitializeModule(&twi_csp_slave, addr, TWI_SLAVE_INTLVL_LO_gc);
     8fe:	40 e4       	ldi	r20, 0x40	; 64
     900:	6c 2f       	mov	r22, r28
     902:	89 ed       	ldi	r24, 0xD9	; 217
     904:	9e e3       	ldi	r25, 0x3E	; 62
     906:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <TWI_SlaveInitializeModule>
	
	callbackFunction = callback;
     90a:	c0 92 7d 3f 	sts	0x3F7D, r12
     90e:	d0 92 7e 3f 	sts	0x3F7E, r13
	
	return E_NO_ERR;
}
     912:	8f ef       	ldi	r24, 0xFF	; 255
     914:	9f ef       	ldi	r25, 0xFF	; 255
     916:	cf 91       	pop	r28
     918:	df 90       	pop	r13
     91a:	cf 90       	pop	r12
     91c:	08 95       	ret

0000091e <i2c_send>:
 * @param timeout Ticks to wait
 * @return Error code
 */
int i2c_send(int handle, i2c_frame_t * frame, uint16_t timeout) {
		
	if (TWI_MasterWrite(&twi_csp_master, frame->dest, (uint8_t *) frame->data, frame->len)) {
     91e:	ab 01       	movw	r20, r22
     920:	46 5f       	subi	r20, 0xF6	; 246
     922:	5f 4f       	sbci	r21, 0xFF	; 255
     924:	fb 01       	movw	r30, r22
     926:	20 85       	ldd	r18, Z+8	; 0x08
     928:	66 81       	ldd	r22, Z+6	; 0x06
     92a:	8b e2       	ldi	r24, 0x2B	; 43
     92c:	9f e3       	ldi	r25, 0x3F	; 63
     92e:	0e 94 2a 22 	call	0x4454	; 0x4454 <TWI_MasterWrite>
     932:	88 23       	and	r24, r24
     934:	19 f0       	breq	.+6      	; 0x93c <i2c_send+0x1e>
		
		return E_NO_ERR;
     936:	8f ef       	ldi	r24, 0xFF	; 255
     938:	9f ef       	ldi	r25, 0xFF	; 255
     93a:	08 95       	ret
	} else {
		
		return 1;
     93c:	81 e0       	ldi	r24, 0x01	; 1
     93e:	90 e0       	ldi	r25, 0x00	; 0
	}
}
     940:	08 95       	ret

00000942 <clock_get_time>:

/* User functions required */
void clock_get_time(csp_timestamp_t * time) {
     942:	08 95       	ret

00000944 <clock_set_time>:
	
	
}

extern void clock_set_time(csp_timestamp_t * time) {
     944:	08 95       	ret

00000946 <__vector_46>:
	
}

/*! CSP Master Interrupt vector. */
ISR(CSP_I2C_TWIM)
{
     946:	1f 92       	push	r1
     948:	0f 92       	push	r0
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	0f 92       	push	r0
     94e:	11 24       	eor	r1, r1
     950:	0b b6       	in	r0, 0x3b	; 59
     952:	0f 92       	push	r0
     954:	2f 93       	push	r18
     956:	3f 93       	push	r19
     958:	4f 93       	push	r20
     95a:	5f 93       	push	r21
     95c:	6f 93       	push	r22
     95e:	7f 93       	push	r23
     960:	8f 93       	push	r24
     962:	9f 93       	push	r25
     964:	af 93       	push	r26
     966:	bf 93       	push	r27
     968:	ef 93       	push	r30
     96a:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twi_csp_master);
     96c:	8b e2       	ldi	r24, 0x2B	; 43
     96e:	9f e3       	ldi	r25, 0x3F	; 63
     970:	0e 94 c6 22 	call	0x458c	; 0x458c <TWI_MasterInterruptHandler>
}
     974:	ff 91       	pop	r31
     976:	ef 91       	pop	r30
     978:	bf 91       	pop	r27
     97a:	af 91       	pop	r26
     97c:	9f 91       	pop	r25
     97e:	8f 91       	pop	r24
     980:	7f 91       	pop	r23
     982:	6f 91       	pop	r22
     984:	5f 91       	pop	r21
     986:	4f 91       	pop	r20
     988:	3f 91       	pop	r19
     98a:	2f 91       	pop	r18
     98c:	0f 90       	pop	r0
     98e:	0b be       	out	0x3b, r0	; 59
     990:	0f 90       	pop	r0
     992:	0f be       	out	0x3f, r0	; 63
     994:	0f 90       	pop	r0
     996:	1f 90       	pop	r1
     998:	18 95       	reti

0000099a <__vector_45>:

/*! CPS Slave Interrupt vector. */
ISR(CSP_I2C_TWIS)
{
     99a:	1f 92       	push	r1
     99c:	0f 92       	push	r0
     99e:	0f b6       	in	r0, 0x3f	; 63
     9a0:	0f 92       	push	r0
     9a2:	11 24       	eor	r1, r1
     9a4:	0b b6       	in	r0, 0x3b	; 59
     9a6:	0f 92       	push	r0
     9a8:	2f 93       	push	r18
     9aa:	3f 93       	push	r19
     9ac:	4f 93       	push	r20
     9ae:	5f 93       	push	r21
     9b0:	6f 93       	push	r22
     9b2:	7f 93       	push	r23
     9b4:	8f 93       	push	r24
     9b6:	9f 93       	push	r25
     9b8:	af 93       	push	r26
     9ba:	bf 93       	push	r27
     9bc:	ef 93       	push	r30
     9be:	ff 93       	push	r31
	TWI_SlaveInterruptHandler(&twi_csp_slave);
     9c0:	89 ed       	ldi	r24, 0xD9	; 217
     9c2:	9e e3       	ldi	r25, 0x3E	; 62
     9c4:	0e 94 bf 23 	call	0x477e	; 0x477e <TWI_SlaveInterruptHandler>
     9c8:	ff 91       	pop	r31
     9ca:	ef 91       	pop	r30
     9cc:	bf 91       	pop	r27
     9ce:	af 91       	pop	r26
     9d0:	9f 91       	pop	r25
     9d2:	8f 91       	pop	r24
     9d4:	7f 91       	pop	r23
     9d6:	6f 91       	pop	r22
     9d8:	5f 91       	pop	r21
     9da:	4f 91       	pop	r20
     9dc:	3f 91       	pop	r19
     9de:	2f 91       	pop	r18
     9e0:	0f 90       	pop	r0
     9e2:	0b be       	out	0x3b, r0	; 59
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	0f 90       	pop	r0
     9ea:	1f 90       	pop	r1
     9ec:	18 95       	reti

000009ee <pvPortMalloc>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	ec 01       	movw	r28, r24
     9f4:	dd d6       	rcall	.+3514   	; 0x17b0 <vTaskSuspendAll>
     9f6:	40 91 1e 21 	lds	r20, 0x211E
     9fa:	50 91 1f 21 	lds	r21, 0x211F
     9fe:	9e 01       	movw	r18, r28
     a00:	24 0f       	add	r18, r20
     a02:	35 1f       	adc	r19, r21
     a04:	28 35       	cpi	r18, 0x58	; 88
     a06:	8b e1       	ldi	r24, 0x1B	; 27
     a08:	38 07       	cpc	r19, r24
     a0a:	58 f4       	brcc	.+22     	; 0xa22 <pvPortMalloc+0x34>
     a0c:	42 17       	cp	r20, r18
     a0e:	53 07       	cpc	r21, r19
     a10:	58 f4       	brcc	.+22     	; 0xa28 <pvPortMalloc+0x3a>
     a12:	ea 01       	movw	r28, r20
     a14:	c0 5e       	subi	r28, 0xE0	; 224
     a16:	de 4d       	sbci	r29, 0xDE	; 222
     a18:	20 93 1e 21 	sts	0x211E, r18
     a1c:	30 93 1f 21 	sts	0x211F, r19
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <pvPortMalloc+0x3e>
     a22:	c0 e0       	ldi	r28, 0x00	; 0
     a24:	d0 e0       	ldi	r29, 0x00	; 0
     a26:	02 c0       	rjmp	.+4      	; 0xa2c <pvPortMalloc+0x3e>
     a28:	c0 e0       	ldi	r28, 0x00	; 0
     a2a:	d0 e0       	ldi	r29, 0x00	; 0
     a2c:	95 d7       	rcall	.+3882   	; 0x1958 <xTaskResumeAll>
     a2e:	ce 01       	movw	r24, r28
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	08 95       	ret

00000a36 <vPortFree>:
     a36:	08 95       	ret

00000a38 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     a38:	20 91 1e 21 	lds	r18, 0x211E
     a3c:	30 91 1f 21 	lds	r19, 0x211F
}
     a40:	88 e5       	ldi	r24, 0x58	; 88
     a42:	9b e1       	ldi	r25, 0x1B	; 27
     a44:	82 1b       	sub	r24, r18
     a46:	93 0b       	sbc	r25, r19
     a48:	08 95       	ret

00000a4a <pxPortInitialiseStack>:
    /* Should not get here. */
    return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler(void) {
     a4a:	31 e1       	ldi	r19, 0x11	; 17
     a4c:	fc 01       	movw	r30, r24
     a4e:	30 83       	st	Z, r19
     a50:	31 97       	sbiw	r30, 0x01	; 1
     a52:	22 e2       	ldi	r18, 0x22	; 34
     a54:	20 83       	st	Z, r18
     a56:	31 97       	sbiw	r30, 0x01	; 1
     a58:	a3 e3       	ldi	r26, 0x33	; 51
     a5a:	a0 83       	st	Z, r26
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	60 83       	st	Z, r22
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	70 83       	st	Z, r23
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	10 82       	st	Z, r1
     a68:	31 97       	sbiw	r30, 0x01	; 1
     a6a:	10 82       	st	Z, r1
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	60 e8       	ldi	r22, 0x80	; 128
     a70:	60 83       	st	Z, r22
     a72:	31 97       	sbiw	r30, 0x01	; 1
     a74:	10 82       	st	Z, r1
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	62 e0       	ldi	r22, 0x02	; 2
     a7a:	60 83       	st	Z, r22
     a7c:	31 97       	sbiw	r30, 0x01	; 1
     a7e:	63 e0       	ldi	r22, 0x03	; 3
     a80:	60 83       	st	Z, r22
     a82:	31 97       	sbiw	r30, 0x01	; 1
     a84:	64 e0       	ldi	r22, 0x04	; 4
     a86:	60 83       	st	Z, r22
     a88:	31 97       	sbiw	r30, 0x01	; 1
     a8a:	65 e0       	ldi	r22, 0x05	; 5
     a8c:	60 83       	st	Z, r22
     a8e:	31 97       	sbiw	r30, 0x01	; 1
     a90:	66 e0       	ldi	r22, 0x06	; 6
     a92:	60 83       	st	Z, r22
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	67 e0       	ldi	r22, 0x07	; 7
     a98:	60 83       	st	Z, r22
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	68 e0       	ldi	r22, 0x08	; 8
     a9e:	60 83       	st	Z, r22
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	69 e0       	ldi	r22, 0x09	; 9
     aa4:	60 83       	st	Z, r22
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	60 e1       	ldi	r22, 0x10	; 16
     aaa:	60 83       	st	Z, r22
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	30 83       	st	Z, r19
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	32 e1       	ldi	r19, 0x12	; 18
     ab4:	30 83       	st	Z, r19
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	33 e1       	ldi	r19, 0x13	; 19
     aba:	30 83       	st	Z, r19
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	34 e1       	ldi	r19, 0x14	; 20
     ac0:	30 83       	st	Z, r19
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	35 e1       	ldi	r19, 0x15	; 21
     ac6:	30 83       	st	Z, r19
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	36 e1       	ldi	r19, 0x16	; 22
     acc:	30 83       	st	Z, r19
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	37 e1       	ldi	r19, 0x17	; 23
     ad2:	30 83       	st	Z, r19
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	38 e1       	ldi	r19, 0x18	; 24
     ad8:	30 83       	st	Z, r19
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	39 e1       	ldi	r19, 0x19	; 25
     ade:	30 83       	st	Z, r19
     ae0:	31 97       	sbiw	r30, 0x01	; 1
     ae2:	30 e2       	ldi	r19, 0x20	; 32
     ae4:	30 83       	st	Z, r19
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	31 e2       	ldi	r19, 0x21	; 33
     aea:	30 83       	st	Z, r19
     aec:	31 97       	sbiw	r30, 0x01	; 1
     aee:	20 83       	st	Z, r18
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	23 e2       	ldi	r18, 0x23	; 35
     af4:	20 83       	st	Z, r18
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	40 83       	st	Z, r20
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	50 83       	st	Z, r21
     afe:	31 97       	sbiw	r30, 0x01	; 1
     b00:	26 e2       	ldi	r18, 0x26	; 38
     b02:	20 83       	st	Z, r18
     b04:	31 97       	sbiw	r30, 0x01	; 1
     b06:	27 e2       	ldi	r18, 0x27	; 39
     b08:	20 83       	st	Z, r18
     b0a:	31 97       	sbiw	r30, 0x01	; 1
     b0c:	28 e2       	ldi	r18, 0x28	; 40
     b0e:	20 83       	st	Z, r18
     b10:	31 97       	sbiw	r30, 0x01	; 1
     b12:	29 e2       	ldi	r18, 0x29	; 41
     b14:	20 83       	st	Z, r18
     b16:	31 97       	sbiw	r30, 0x01	; 1
     b18:	20 e3       	ldi	r18, 0x30	; 48
     b1a:	20 83       	st	Z, r18
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	21 e3       	ldi	r18, 0x31	; 49
     b20:	20 83       	st	Z, r18
     b22:	87 97       	sbiw	r24, 0x27	; 39
     b24:	08 95       	ret

00000b26 <xPortStartScheduler>:
     b26:	65 e0       	ldi	r22, 0x05	; 5
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	98 e0       	ldi	r25, 0x08	; 8
     b2c:	0e 94 a1 21 	call	0x4342	; 0x4342 <TC0_ConfigClockSource>
     b30:	83 ef       	ldi	r24, 0xF3	; 243
     b32:	91 e0       	ldi	r25, 0x01	; 1
     b34:	e0 e0       	ldi	r30, 0x00	; 0
     b36:	f8 e0       	ldi	r31, 0x08	; 8
     b38:	86 a3       	std	Z+38, r24	; 0x26
     b3a:	97 a3       	std	Z+39, r25	; 0x27
     b3c:	61 e0       	ldi	r22, 0x01	; 1
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	98 e0       	ldi	r25, 0x08	; 8
     b42:	0e 94 ad 21 	call	0x435a	; 0x435a <TC0_SetOverflowIntLevel>
     b46:	e0 ea       	ldi	r30, 0xA0	; 160
     b48:	f0 e0       	ldi	r31, 0x00	; 0
     b4a:	82 81       	ldd	r24, Z+2	; 0x02
     b4c:	81 60       	ori	r24, 0x01	; 1
     b4e:	82 83       	std	Z+2, r24	; 0x02
     b50:	a0 91 eb 3c 	lds	r26, 0x3CEB
     b54:	b0 91 ec 3c 	lds	r27, 0x3CEC
     b58:	cd 91       	ld	r28, X+
     b5a:	cd bf       	out	0x3d, r28	; 61
     b5c:	dd 91       	ld	r29, X+
     b5e:	de bf       	out	0x3e, r29	; 62
     b60:	ff 91       	pop	r31
     b62:	ef 91       	pop	r30
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	bf 91       	pop	r27
     b6a:	af 91       	pop	r26
     b6c:	9f 91       	pop	r25
     b6e:	8f 91       	pop	r24
     b70:	7f 91       	pop	r23
     b72:	6f 91       	pop	r22
     b74:	5f 91       	pop	r21
     b76:	4f 91       	pop	r20
     b78:	3f 91       	pop	r19
     b7a:	2f 91       	pop	r18
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	ff 90       	pop	r15
     b82:	ef 90       	pop	r14
     b84:	df 90       	pop	r13
     b86:	cf 90       	pop	r12
     b88:	bf 90       	pop	r11
     b8a:	af 90       	pop	r10
     b8c:	9f 90       	pop	r9
     b8e:	8f 90       	pop	r8
     b90:	7f 90       	pop	r7
     b92:	6f 90       	pop	r6
     b94:	5f 90       	pop	r5
     b96:	4f 90       	pop	r4
     b98:	3f 90       	pop	r3
     b9a:	2f 90       	pop	r2
     b9c:	1f 90       	pop	r1
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	0f 90       	pop	r0
     ba4:	08 95       	ret
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	08 95       	ret

00000baa <vPortYield>:
 * Manual context switch.  The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield(void) __attribute__ ( ( naked ) );
void vPortYield(void) {
    portSAVE_CONTEXT();
     baa:	0f 92       	push	r0
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	f8 94       	cli
     bb0:	0f 92       	push	r0
     bb2:	1f 92       	push	r1
     bb4:	11 24       	eor	r1, r1
     bb6:	2f 92       	push	r2
     bb8:	3f 92       	push	r3
     bba:	4f 92       	push	r4
     bbc:	5f 92       	push	r5
     bbe:	6f 92       	push	r6
     bc0:	7f 92       	push	r7
     bc2:	8f 92       	push	r8
     bc4:	9f 92       	push	r9
     bc6:	af 92       	push	r10
     bc8:	bf 92       	push	r11
     bca:	cf 92       	push	r12
     bcc:	df 92       	push	r13
     bce:	ef 92       	push	r14
     bd0:	ff 92       	push	r15
     bd2:	0f 93       	push	r16
     bd4:	1f 93       	push	r17
     bd6:	2f 93       	push	r18
     bd8:	3f 93       	push	r19
     bda:	4f 93       	push	r20
     bdc:	5f 93       	push	r21
     bde:	6f 93       	push	r22
     be0:	7f 93       	push	r23
     be2:	8f 93       	push	r24
     be4:	9f 93       	push	r25
     be6:	af 93       	push	r26
     be8:	bf 93       	push	r27
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	ef 93       	push	r30
     bf0:	ff 93       	push	r31
     bf2:	a0 91 eb 3c 	lds	r26, 0x3CEB
     bf6:	b0 91 ec 3c 	lds	r27, 0x3CEC
     bfa:	0d b6       	in	r0, 0x3d	; 61
     bfc:	0d 92       	st	X+, r0
     bfe:	0e b6       	in	r0, 0x3e	; 62
     c00:	0d 92       	st	X+, r0
    vTaskSwitchContext();
     c02:	a2 d7       	rcall	.+3908   	; 0x1b48 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     c04:	a0 91 eb 3c 	lds	r26, 0x3CEB
     c08:	b0 91 ec 3c 	lds	r27, 0x3CEC
     c0c:	cd 91       	ld	r28, X+
     c0e:	cd bf       	out	0x3d, r28	; 61
     c10:	dd 91       	ld	r29, X+
     c12:	de bf       	out	0x3e, r29	; 62
     c14:	ff 91       	pop	r31
     c16:	ef 91       	pop	r30
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	bf 91       	pop	r27
     c1e:	af 91       	pop	r26
     c20:	9f 91       	pop	r25
     c22:	8f 91       	pop	r24
     c24:	7f 91       	pop	r23
     c26:	6f 91       	pop	r22
     c28:	5f 91       	pop	r21
     c2a:	4f 91       	pop	r20
     c2c:	3f 91       	pop	r19
     c2e:	2f 91       	pop	r18
     c30:	1f 91       	pop	r17
     c32:	0f 91       	pop	r16
     c34:	ff 90       	pop	r15
     c36:	ef 90       	pop	r14
     c38:	df 90       	pop	r13
     c3a:	cf 90       	pop	r12
     c3c:	bf 90       	pop	r11
     c3e:	af 90       	pop	r10
     c40:	9f 90       	pop	r9
     c42:	8f 90       	pop	r8
     c44:	7f 90       	pop	r7
     c46:	6f 90       	pop	r6
     c48:	5f 90       	pop	r5
     c4a:	4f 90       	pop	r4
     c4c:	3f 90       	pop	r3
     c4e:	2f 90       	pop	r2
     c50:	1f 90       	pop	r1
     c52:	0f 90       	pop	r0
     c54:	0f be       	out	0x3f, r0	; 63
     c56:	0f 90       	pop	r0

    asm volatile ( "ret" );
     c58:	08 95       	ret

00000c5a <__vector_14>:
     * Context switch function used by the tick.  This must be identical to
     * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
     * difference from vPortYield() is the tick count is incremented as the
     * call comes from the tick ISR.
     */
    portSAVE_CONTEXT();
     c5a:	0f 92       	push	r0
     c5c:	0f b6       	in	r0, 0x3f	; 63
     c5e:	f8 94       	cli
     c60:	0f 92       	push	r0
     c62:	1f 92       	push	r1
     c64:	11 24       	eor	r1, r1
     c66:	2f 92       	push	r2
     c68:	3f 92       	push	r3
     c6a:	4f 92       	push	r4
     c6c:	5f 92       	push	r5
     c6e:	6f 92       	push	r6
     c70:	7f 92       	push	r7
     c72:	8f 92       	push	r8
     c74:	9f 92       	push	r9
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	2f 93       	push	r18
     c88:	3f 93       	push	r19
     c8a:	4f 93       	push	r20
     c8c:	5f 93       	push	r21
     c8e:	6f 93       	push	r22
     c90:	7f 93       	push	r23
     c92:	8f 93       	push	r24
     c94:	9f 93       	push	r25
     c96:	af 93       	push	r26
     c98:	bf 93       	push	r27
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	ef 93       	push	r30
     ca0:	ff 93       	push	r31
     ca2:	a0 91 eb 3c 	lds	r26, 0x3CEB
     ca6:	b0 91 ec 3c 	lds	r27, 0x3CEC
     caa:	0d b6       	in	r0, 0x3d	; 61
     cac:	0d 92       	st	X+, r0
     cae:	0e b6       	in	r0, 0x3e	; 62
     cb0:	0d 92       	st	X+, r0
    vTaskIncrementTick();
     cb2:	91 d5       	rcall	.+2850   	; 0x17d6 <vTaskIncrementTick>
    vTaskSwitchContext();
     cb4:	49 d7       	rcall	.+3730   	; 0x1b48 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     cb6:	a0 91 eb 3c 	lds	r26, 0x3CEB
     cba:	b0 91 ec 3c 	lds	r27, 0x3CEC
     cbe:	cd 91       	ld	r28, X+
     cc0:	cd bf       	out	0x3d, r28	; 61
     cc2:	dd 91       	ld	r29, X+
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	ff 91       	pop	r31
     cc8:	ef 91       	pop	r30
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	bf 91       	pop	r27
     cd0:	af 91       	pop	r26
     cd2:	9f 91       	pop	r25
     cd4:	8f 91       	pop	r24
     cd6:	7f 91       	pop	r23
     cd8:	6f 91       	pop	r22
     cda:	5f 91       	pop	r21
     cdc:	4f 91       	pop	r20
     cde:	3f 91       	pop	r19
     ce0:	2f 91       	pop	r18
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	ff 90       	pop	r15
     ce8:	ef 90       	pop	r14
     cea:	df 90       	pop	r13
     cec:	cf 90       	pop	r12
     cee:	bf 90       	pop	r11
     cf0:	af 90       	pop	r10
     cf2:	9f 90       	pop	r9
     cf4:	8f 90       	pop	r8
     cf6:	7f 90       	pop	r7
     cf8:	6f 90       	pop	r6
     cfa:	5f 90       	pop	r5
     cfc:	4f 90       	pop	r4
     cfe:	3f 90       	pop	r3
     d00:	2f 90       	pop	r2
     d02:	1f 90       	pop	r1
     d04:	0f 90       	pop	r0
     d06:	0f be       	out	0x3f, r0	; 63
     d08:	0f 90       	pop	r0
    asm volatile ( "reti" );
     d0a:	18 95       	reti

00000d0c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     d0c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     d0e:	03 96       	adiw	r24, 0x03	; 3
     d10:	81 83       	std	Z+1, r24	; 0x01
     d12:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d14:	2f ef       	ldi	r18, 0xFF	; 255
     d16:	3f ef       	ldi	r19, 0xFF	; 255
     d18:	23 83       	std	Z+3, r18	; 0x03
     d1a:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     d1c:	85 83       	std	Z+5, r24	; 0x05
     d1e:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     d20:	87 83       	std	Z+7, r24	; 0x07
     d22:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     d24:	10 82       	st	Z, r1
     d26:	08 95       	ret

00000d28 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d28:	fc 01       	movw	r30, r24
     d2a:	10 86       	std	Z+8, r1	; 0x08
     d2c:	11 86       	std	Z+9, r1	; 0x09
     d2e:	08 95       	ret

00000d30 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
     d34:	fc 01       	movw	r30, r24
     d36:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     d38:	21 81       	ldd	r18, Z+1	; 0x01
     d3a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     d3c:	e9 01       	movw	r28, r18
     d3e:	8a 81       	ldd	r24, Y+2	; 0x02
     d40:	9b 81       	ldd	r25, Y+3	; 0x03
     d42:	12 96       	adiw	r26, 0x02	; 2
     d44:	8d 93       	st	X+, r24
     d46:	9c 93       	st	X, r25
     d48:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
     d4a:	81 81       	ldd	r24, Z+1	; 0x01
     d4c:	92 81       	ldd	r25, Z+2	; 0x02
     d4e:	14 96       	adiw	r26, 0x04	; 4
     d50:	8d 93       	st	X+, r24
     d52:	9c 93       	st	X, r25
     d54:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     d56:	8a 81       	ldd	r24, Y+2	; 0x02
     d58:	9b 81       	ldd	r25, Y+3	; 0x03
     d5a:	ec 01       	movw	r28, r24
     d5c:	6c 83       	std	Y+4, r22	; 0x04
     d5e:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     d60:	e9 01       	movw	r28, r18
     d62:	6a 83       	std	Y+2, r22	; 0x02
     d64:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     d66:	61 83       	std	Z+1, r22	; 0x01
     d68:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d6a:	18 96       	adiw	r26, 0x08	; 8
     d6c:	ed 93       	st	X+, r30
     d6e:	fc 93       	st	X, r31
     d70:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
     d72:	80 81       	ld	r24, Z
     d74:	8f 5f       	subi	r24, 0xFF	; 255
     d76:	80 83       	st	Z, r24
}
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	08 95       	ret

00000d7e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d84:	48 81       	ld	r20, Y
     d86:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d88:	4f 3f       	cpi	r20, 0xFF	; 255
     d8a:	2f ef       	ldi	r18, 0xFF	; 255
     d8c:	52 07       	cpc	r21, r18
     d8e:	31 f4       	brne	.+12     	; 0xd9c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d90:	dc 01       	movw	r26, r24
     d92:	17 96       	adiw	r26, 0x07	; 7
     d94:	ed 91       	ld	r30, X+
     d96:	fc 91       	ld	r31, X
     d98:	18 97       	sbiw	r26, 0x08	; 8
     d9a:	17 c0       	rjmp	.+46     	; 0xdca <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     d9c:	fc 01       	movw	r30, r24
     d9e:	33 96       	adiw	r30, 0x03	; 3
     da0:	dc 01       	movw	r26, r24
     da2:	15 96       	adiw	r26, 0x05	; 5
     da4:	2d 91       	ld	r18, X+
     da6:	3c 91       	ld	r19, X
     da8:	16 97       	sbiw	r26, 0x06	; 6
     daa:	d9 01       	movw	r26, r18
     dac:	2d 91       	ld	r18, X+
     dae:	3c 91       	ld	r19, X
     db0:	42 17       	cp	r20, r18
     db2:	53 07       	cpc	r21, r19
     db4:	50 f0       	brcs	.+20     	; 0xdca <vListInsert+0x4c>
     db6:	02 80       	ldd	r0, Z+2	; 0x02
     db8:	f3 81       	ldd	r31, Z+3	; 0x03
     dba:	e0 2d       	mov	r30, r0
     dbc:	a2 81       	ldd	r26, Z+2	; 0x02
     dbe:	b3 81       	ldd	r27, Z+3	; 0x03
     dc0:	2d 91       	ld	r18, X+
     dc2:	3c 91       	ld	r19, X
     dc4:	42 17       	cp	r20, r18
     dc6:	53 07       	cpc	r21, r19
     dc8:	b0 f7       	brcc	.-20     	; 0xdb6 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     dca:	a2 81       	ldd	r26, Z+2	; 0x02
     dcc:	b3 81       	ldd	r27, Z+3	; 0x03
     dce:	aa 83       	std	Y+2, r26	; 0x02
     dd0:	bb 83       	std	Y+3, r27	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     dd2:	14 96       	adiw	r26, 0x04	; 4
     dd4:	cd 93       	st	X+, r28
     dd6:	dc 93       	st	X, r29
     dd8:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxIterator;
     dda:	ec 83       	std	Y+4, r30	; 0x04
     ddc:	fd 83       	std	Y+5, r31	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     dde:	c2 83       	std	Z+2, r28	; 0x02
     de0:	d3 83       	std	Z+3, r29	; 0x03

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     de2:	88 87       	std	Y+8, r24	; 0x08
     de4:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     de6:	fc 01       	movw	r30, r24
     de8:	20 81       	ld	r18, Z
     dea:	2f 5f       	subi	r18, 0xFF	; 255
     dec:	20 83       	st	Z, r18
}
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     df4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     df6:	a2 81       	ldd	r26, Z+2	; 0x02
     df8:	b3 81       	ldd	r27, Z+3	; 0x03
     dfa:	84 81       	ldd	r24, Z+4	; 0x04
     dfc:	95 81       	ldd	r25, Z+5	; 0x05
     dfe:	14 96       	adiw	r26, 0x04	; 4
     e00:	8d 93       	st	X+, r24
     e02:	9c 93       	st	X, r25
     e04:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e06:	a4 81       	ldd	r26, Z+4	; 0x04
     e08:	b5 81       	ldd	r27, Z+5	; 0x05
     e0a:	82 81       	ldd	r24, Z+2	; 0x02
     e0c:	93 81       	ldd	r25, Z+3	; 0x03
     e0e:	12 96       	adiw	r26, 0x02	; 2
     e10:	8d 93       	st	X+, r24
     e12:	9c 93       	st	X, r25
     e14:	13 97       	sbiw	r26, 0x03	; 3
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     e16:	a0 85       	ldd	r26, Z+8	; 0x08
     e18:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e1a:	11 96       	adiw	r26, 0x01	; 1
     e1c:	8d 91       	ld	r24, X+
     e1e:	9c 91       	ld	r25, X
     e20:	12 97       	sbiw	r26, 0x02	; 2
     e22:	8e 17       	cp	r24, r30
     e24:	9f 07       	cpc	r25, r31
     e26:	31 f4       	brne	.+12     	; 0xe34 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e28:	84 81       	ldd	r24, Z+4	; 0x04
     e2a:	95 81       	ldd	r25, Z+5	; 0x05
     e2c:	11 96       	adiw	r26, 0x01	; 1
     e2e:	8d 93       	st	X+, r24
     e30:	9c 93       	st	X, r25
     e32:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     e34:	10 86       	std	Z+8, r1	; 0x08
     e36:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     e38:	8c 91       	ld	r24, X
     e3a:	81 50       	subi	r24, 0x01	; 1
     e3c:	8c 93       	st	X, r24
     e3e:	08 95       	ret

00000e40 <prvCopyDataToQueue>:

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );

	return xReturn;
}
     e40:	cf 93       	push	r28
     e42:	df 93       	push	r29
     e44:	ec 01       	movw	r28, r24
     e46:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e48:	81 11       	cpse	r24, r1
     e4a:	0b c0       	rjmp	.+22     	; 0xe62 <prvCopyDataToQueue+0x22>
     e4c:	88 81       	ld	r24, Y
     e4e:	99 81       	ldd	r25, Y+1	; 0x01
     e50:	89 2b       	or	r24, r25
     e52:	e1 f5       	brne	.+120    	; 0xecc <prvCopyDataToQueue+0x8c>
     e54:	8a 81       	ldd	r24, Y+2	; 0x02
     e56:	9b 81       	ldd	r25, Y+3	; 0x03
     e58:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <vTaskPriorityDisinherit>
     e5c:	1a 82       	std	Y+2, r1	; 0x02
     e5e:	1b 82       	std	Y+3, r1	; 0x03
     e60:	35 c0       	rjmp	.+106    	; 0xecc <prvCopyDataToQueue+0x8c>
     e62:	41 11       	cpse	r20, r1
     e64:	17 c0       	rjmp	.+46     	; 0xe94 <prvCopyDataToQueue+0x54>
     e66:	48 2f       	mov	r20, r24
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	8c 81       	ldd	r24, Y+4	; 0x04
     e6c:	9d 81       	ldd	r25, Y+5	; 0x05
     e6e:	0e 94 56 2d 	call	0x5aac	; 0x5aac <memcpy>
     e72:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e74:	8c 81       	ldd	r24, Y+4	; 0x04
     e76:	9d 81       	ldd	r25, Y+5	; 0x05
     e78:	82 0f       	add	r24, r18
     e7a:	91 1d       	adc	r25, r1
     e7c:	8c 83       	std	Y+4, r24	; 0x04
     e7e:	9d 83       	std	Y+5, r25	; 0x05
     e80:	2a 81       	ldd	r18, Y+2	; 0x02
     e82:	3b 81       	ldd	r19, Y+3	; 0x03
     e84:	82 17       	cp	r24, r18
     e86:	93 07       	cpc	r25, r19
     e88:	08 f1       	brcs	.+66     	; 0xecc <prvCopyDataToQueue+0x8c>
     e8a:	88 81       	ld	r24, Y
     e8c:	99 81       	ldd	r25, Y+1	; 0x01
     e8e:	8c 83       	std	Y+4, r24	; 0x04
     e90:	9d 83       	std	Y+5, r25	; 0x05
     e92:	1c c0       	rjmp	.+56     	; 0xecc <prvCopyDataToQueue+0x8c>
     e94:	48 2f       	mov	r20, r24
     e96:	50 e0       	ldi	r21, 0x00	; 0
     e98:	8e 81       	ldd	r24, Y+6	; 0x06
     e9a:	9f 81       	ldd	r25, Y+7	; 0x07
     e9c:	0e 94 56 2d 	call	0x5aac	; 0x5aac <memcpy>
     ea0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	31 95       	neg	r19
     ea6:	21 95       	neg	r18
     ea8:	31 09       	sbc	r19, r1
     eaa:	8e 81       	ldd	r24, Y+6	; 0x06
     eac:	9f 81       	ldd	r25, Y+7	; 0x07
     eae:	82 0f       	add	r24, r18
     eb0:	93 1f       	adc	r25, r19
     eb2:	8e 83       	std	Y+6, r24	; 0x06
     eb4:	9f 83       	std	Y+7, r25	; 0x07
     eb6:	48 81       	ld	r20, Y
     eb8:	59 81       	ldd	r21, Y+1	; 0x01
     eba:	84 17       	cp	r24, r20
     ebc:	95 07       	cpc	r25, r21
     ebe:	30 f4       	brcc	.+12     	; 0xecc <prvCopyDataToQueue+0x8c>
     ec0:	8a 81       	ldd	r24, Y+2	; 0x02
     ec2:	9b 81       	ldd	r25, Y+3	; 0x03
     ec4:	28 0f       	add	r18, r24
     ec6:	39 1f       	adc	r19, r25
     ec8:	2e 83       	std	Y+6, r18	; 0x06
     eca:	3f 83       	std	Y+7, r19	; 0x07
     ecc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ece:	8f 5f       	subi	r24, 0xFF	; 255
     ed0:	8a 8f       	std	Y+26, r24	; 0x1a
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	08 95       	ret

00000ed8 <prvCopyDataFromQueue>:
     ed8:	fc 01       	movw	r30, r24
     eda:	cb 01       	movw	r24, r22
     edc:	a0 81       	ld	r26, Z
     ede:	b1 81       	ldd	r27, Z+1	; 0x01
     ee0:	10 97       	sbiw	r26, 0x00	; 0
     ee2:	99 f0       	breq	.+38     	; 0xf0a <prvCopyDataFromQueue+0x32>
     ee4:	44 8d       	ldd	r20, Z+28	; 0x1c
     ee6:	50 e0       	ldi	r21, 0x00	; 0
     ee8:	26 81       	ldd	r18, Z+6	; 0x06
     eea:	37 81       	ldd	r19, Z+7	; 0x07
     eec:	24 0f       	add	r18, r20
     eee:	35 1f       	adc	r19, r21
     ef0:	26 83       	std	Z+6, r18	; 0x06
     ef2:	37 83       	std	Z+7, r19	; 0x07
     ef4:	62 81       	ldd	r22, Z+2	; 0x02
     ef6:	73 81       	ldd	r23, Z+3	; 0x03
     ef8:	26 17       	cp	r18, r22
     efa:	37 07       	cpc	r19, r23
     efc:	10 f0       	brcs	.+4      	; 0xf02 <prvCopyDataFromQueue+0x2a>
     efe:	a6 83       	std	Z+6, r26	; 0x06
     f00:	b7 83       	std	Z+7, r27	; 0x07
     f02:	66 81       	ldd	r22, Z+6	; 0x06
     f04:	77 81       	ldd	r23, Z+7	; 0x07
     f06:	0c 94 56 2d 	jmp	0x5aac	; 0x5aac <memcpy>
     f0a:	08 95       	ret

00000f0c <prvUnlockQueue>:
     f0c:	0f 93       	push	r16
     f0e:	1f 93       	push	r17
     f10:	cf 93       	push	r28
     f12:	df 93       	push	r29
     f14:	ec 01       	movw	r28, r24
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	0f 92       	push	r0
     f1c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f1e:	18 16       	cp	r1, r24
     f20:	9c f4       	brge	.+38     	; 0xf48 <prvUnlockQueue+0x3c>
     f22:	89 89       	ldd	r24, Y+17	; 0x11
     f24:	88 23       	and	r24, r24
     f26:	81 f0       	breq	.+32     	; 0xf48 <prvUnlockQueue+0x3c>
     f28:	8e 01       	movw	r16, r28
     f2a:	0f 5e       	subi	r16, 0xEF	; 239
     f2c:	1f 4f       	sbci	r17, 0xFF	; 255
     f2e:	03 c0       	rjmp	.+6      	; 0xf36 <prvUnlockQueue+0x2a>
     f30:	89 89       	ldd	r24, Y+17	; 0x11
     f32:	88 23       	and	r24, r24
     f34:	49 f0       	breq	.+18     	; 0xf48 <prvUnlockQueue+0x3c>
     f36:	c8 01       	movw	r24, r16
     f38:	f7 d6       	rcall	.+3566   	; 0x1d28 <xTaskRemoveFromEventList>
     f3a:	81 11       	cpse	r24, r1
     f3c:	81 d7       	rcall	.+3842   	; 0x1e40 <vTaskMissedYield>
     f3e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f40:	81 50       	subi	r24, 0x01	; 1
     f42:	8e 8f       	std	Y+30, r24	; 0x1e
     f44:	18 16       	cp	r1, r24
     f46:	a4 f3       	brlt	.-24     	; 0xf30 <prvUnlockQueue+0x24>
     f48:	8f ef       	ldi	r24, 0xFF	; 255
     f4a:	8e 8f       	std	Y+30, r24	; 0x1e
     f4c:	0f 90       	pop	r0
     f4e:	0f be       	out	0x3f, r0	; 63
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	f8 94       	cli
     f54:	0f 92       	push	r0
     f56:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f58:	18 16       	cp	r1, r24
     f5a:	9c f4       	brge	.+38     	; 0xf82 <prvUnlockQueue+0x76>
     f5c:	88 85       	ldd	r24, Y+8	; 0x08
     f5e:	88 23       	and	r24, r24
     f60:	81 f0       	breq	.+32     	; 0xf82 <prvUnlockQueue+0x76>
     f62:	8e 01       	movw	r16, r28
     f64:	08 5f       	subi	r16, 0xF8	; 248
     f66:	1f 4f       	sbci	r17, 0xFF	; 255
     f68:	03 c0       	rjmp	.+6      	; 0xf70 <prvUnlockQueue+0x64>
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	88 23       	and	r24, r24
     f6e:	49 f0       	breq	.+18     	; 0xf82 <prvUnlockQueue+0x76>
     f70:	c8 01       	movw	r24, r16
     f72:	da d6       	rcall	.+3508   	; 0x1d28 <xTaskRemoveFromEventList>
     f74:	81 11       	cpse	r24, r1
     f76:	64 d7       	rcall	.+3784   	; 0x1e40 <vTaskMissedYield>
     f78:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f7a:	81 50       	subi	r24, 0x01	; 1
     f7c:	8d 8f       	std	Y+29, r24	; 0x1d
     f7e:	18 16       	cp	r1, r24
     f80:	a4 f3       	brlt	.-24     	; 0xf6a <prvUnlockQueue+0x5e>
     f82:	8f ef       	ldi	r24, 0xFF	; 255
     f84:	8d 8f       	std	Y+29, r24	; 0x1d
     f86:	0f 90       	pop	r0
     f88:	0f be       	out	0x3f, r0	; 63
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	1f 91       	pop	r17
     f90:	0f 91       	pop	r16
     f92:	08 95       	ret

00000f94 <xQueueCreate>:
     f94:	cf 92       	push	r12
     f96:	df 92       	push	r13
     f98:	ef 92       	push	r14
     f9a:	ff 92       	push	r15
     f9c:	0f 93       	push	r16
     f9e:	1f 93       	push	r17
     fa0:	cf 93       	push	r28
     fa2:	df 93       	push	r29
     fa4:	d8 2e       	mov	r13, r24
     fa6:	c6 2e       	mov	r12, r22
     fa8:	88 23       	and	r24, r24
     faa:	a1 f1       	breq	.+104    	; 0x1014 <xQueueCreate+0x80>
     fac:	8f e1       	ldi	r24, 0x1F	; 31
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	1e dd       	rcall	.-1476   	; 0x9ee <pvPortMalloc>
     fb2:	ec 01       	movw	r28, r24
     fb4:	00 97       	sbiw	r24, 0x00	; 0
     fb6:	81 f1       	breq	.+96     	; 0x1018 <xQueueCreate+0x84>
     fb8:	ec 2c       	mov	r14, r12
     fba:	f1 2c       	mov	r15, r1
     fbc:	de 9c       	mul	r13, r14
     fbe:	80 01       	movw	r16, r0
     fc0:	df 9c       	mul	r13, r15
     fc2:	10 0d       	add	r17, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	c8 01       	movw	r24, r16
     fc8:	01 96       	adiw	r24, 0x01	; 1
     fca:	11 dd       	rcall	.-1502   	; 0x9ee <pvPortMalloc>
     fcc:	88 83       	st	Y, r24
     fce:	99 83       	std	Y+1, r25	; 0x01
     fd0:	00 97       	sbiw	r24, 0x00	; 0
     fd2:	d9 f0       	breq	.+54     	; 0x100a <xQueueCreate+0x76>
     fd4:	ac 01       	movw	r20, r24
     fd6:	40 0f       	add	r20, r16
     fd8:	51 1f       	adc	r21, r17
     fda:	4a 83       	std	Y+2, r20	; 0x02
     fdc:	5b 83       	std	Y+3, r21	; 0x03
     fde:	1a 8e       	std	Y+26, r1	; 0x1a
     fe0:	8c 83       	std	Y+4, r24	; 0x04
     fe2:	9d 83       	std	Y+5, r25	; 0x05
     fe4:	0e 19       	sub	r16, r14
     fe6:	1f 09       	sbc	r17, r15
     fe8:	9c 01       	movw	r18, r24
     fea:	20 0f       	add	r18, r16
     fec:	31 1f       	adc	r19, r17
     fee:	2e 83       	std	Y+6, r18	; 0x06
     ff0:	3f 83       	std	Y+7, r19	; 0x07
     ff2:	db 8e       	std	Y+27, r13	; 0x1b
     ff4:	cc 8e       	std	Y+28, r12	; 0x1c
     ff6:	8f ef       	ldi	r24, 0xFF	; 255
     ff8:	8d 8f       	std	Y+29, r24	; 0x1d
     ffa:	8e 8f       	std	Y+30, r24	; 0x1e
     ffc:	ce 01       	movw	r24, r28
     ffe:	08 96       	adiw	r24, 0x08	; 8
    1000:	85 de       	rcall	.-758    	; 0xd0c <vListInitialise>
    1002:	ce 01       	movw	r24, r28
    1004:	41 96       	adiw	r24, 0x11	; 17
    1006:	82 de       	rcall	.-764    	; 0xd0c <vListInitialise>
    1008:	07 c0       	rjmp	.+14     	; 0x1018 <xQueueCreate+0x84>
    100a:	ce 01       	movw	r24, r28
    100c:	14 dd       	rcall	.-1496   	; 0xa36 <vPortFree>
    100e:	c0 e0       	ldi	r28, 0x00	; 0
    1010:	d0 e0       	ldi	r29, 0x00	; 0
    1012:	02 c0       	rjmp	.+4      	; 0x1018 <xQueueCreate+0x84>
    1014:	c0 e0       	ldi	r28, 0x00	; 0
    1016:	d0 e0       	ldi	r29, 0x00	; 0
    1018:	ce 01       	movw	r24, r28
    101a:	df 91       	pop	r29
    101c:	cf 91       	pop	r28
    101e:	1f 91       	pop	r17
    1020:	0f 91       	pop	r16
    1022:	ff 90       	pop	r15
    1024:	ef 90       	pop	r14
    1026:	df 90       	pop	r13
    1028:	cf 90       	pop	r12
    102a:	08 95       	ret

0000102c <xQueueGenericSend>:
    102c:	af 92       	push	r10
    102e:	bf 92       	push	r11
    1030:	cf 92       	push	r12
    1032:	df 92       	push	r13
    1034:	ef 92       	push	r14
    1036:	ff 92       	push	r15
    1038:	0f 93       	push	r16
    103a:	1f 93       	push	r17
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	25 97       	sbiw	r28, 0x05	; 5
    1046:	cd bf       	out	0x3d, r28	; 61
    1048:	de bf       	out	0x3e, r29	; 62
    104a:	8c 01       	movw	r16, r24
    104c:	6b 01       	movw	r12, r22
    104e:	4c 83       	std	Y+4, r20	; 0x04
    1050:	5d 83       	std	Y+5, r21	; 0x05
    1052:	a2 2e       	mov	r10, r18
    1054:	b1 2c       	mov	r11, r1
    1056:	7c 01       	movw	r14, r24
    1058:	88 e0       	ldi	r24, 0x08	; 8
    105a:	e8 0e       	add	r14, r24
    105c:	f1 1c       	adc	r15, r1
    105e:	0f b6       	in	r0, 0x3f	; 63
    1060:	f8 94       	cli
    1062:	0f 92       	push	r0
    1064:	f8 01       	movw	r30, r16
    1066:	92 8d       	ldd	r25, Z+26	; 0x1a
    1068:	83 8d       	ldd	r24, Z+27	; 0x1b
    106a:	98 17       	cp	r25, r24
    106c:	90 f4       	brcc	.+36     	; 0x1092 <xQueueGenericSend+0x66>
    106e:	4a 2d       	mov	r20, r10
    1070:	b6 01       	movw	r22, r12
    1072:	c8 01       	movw	r24, r16
    1074:	e5 de       	rcall	.-566    	; 0xe40 <prvCopyDataToQueue>
    1076:	f8 01       	movw	r30, r16
    1078:	81 89       	ldd	r24, Z+17	; 0x11
    107a:	88 23       	and	r24, r24
    107c:	31 f0       	breq	.+12     	; 0x108a <xQueueGenericSend+0x5e>
    107e:	c8 01       	movw	r24, r16
    1080:	41 96       	adiw	r24, 0x11	; 17
    1082:	52 d6       	rcall	.+3236   	; 0x1d28 <xTaskRemoveFromEventList>
    1084:	81 30       	cpi	r24, 0x01	; 1
    1086:	09 f4       	brne	.+2      	; 0x108a <xQueueGenericSend+0x5e>
    1088:	90 dd       	rcall	.-1248   	; 0xbaa <vPortYield>
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	47 c0       	rjmp	.+142    	; 0x1120 <xQueueGenericSend+0xf4>
    1092:	ec 81       	ldd	r30, Y+4	; 0x04
    1094:	fd 81       	ldd	r31, Y+5	; 0x05
    1096:	ef 2b       	or	r30, r31
    1098:	21 f4       	brne	.+8      	; 0x10a2 <xQueueGenericSend+0x76>
    109a:	0f 90       	pop	r0
    109c:	0f be       	out	0x3f, r0	; 63
    109e:	80 e0       	ldi	r24, 0x00	; 0
    10a0:	3f c0       	rjmp	.+126    	; 0x1120 <xQueueGenericSend+0xf4>
    10a2:	b1 10       	cpse	r11, r1
    10a4:	05 c0       	rjmp	.+10     	; 0x10b0 <xQueueGenericSend+0x84>
    10a6:	ce 01       	movw	r24, r28
    10a8:	01 96       	adiw	r24, 0x01	; 1
    10aa:	81 d6       	rcall	.+3330   	; 0x1dae <vTaskSetTimeOutState>
    10ac:	bb 24       	eor	r11, r11
    10ae:	b3 94       	inc	r11
    10b0:	0f 90       	pop	r0
    10b2:	0f be       	out	0x3f, r0	; 63
    10b4:	7d d3       	rcall	.+1786   	; 0x17b0 <vTaskSuspendAll>
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	f8 94       	cli
    10ba:	0f 92       	push	r0
    10bc:	f8 01       	movw	r30, r16
    10be:	85 8d       	ldd	r24, Z+29	; 0x1d
    10c0:	8f 3f       	cpi	r24, 0xFF	; 255
    10c2:	09 f4       	brne	.+2      	; 0x10c6 <xQueueGenericSend+0x9a>
    10c4:	15 8e       	std	Z+29, r1	; 0x1d
    10c6:	f8 01       	movw	r30, r16
    10c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    10ca:	8f 3f       	cpi	r24, 0xFF	; 255
    10cc:	09 f4       	brne	.+2      	; 0x10d0 <xQueueGenericSend+0xa4>
    10ce:	16 8e       	std	Z+30, r1	; 0x1e
    10d0:	0f 90       	pop	r0
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	be 01       	movw	r22, r28
    10d6:	6c 5f       	subi	r22, 0xFC	; 252
    10d8:	7f 4f       	sbci	r23, 0xFF	; 255
    10da:	ce 01       	movw	r24, r28
    10dc:	01 96       	adiw	r24, 0x01	; 1
    10de:	72 d6       	rcall	.+3300   	; 0x1dc4 <xTaskCheckForTimeOut>
    10e0:	81 11       	cpse	r24, r1
    10e2:	1a c0       	rjmp	.+52     	; 0x1118 <xQueueGenericSend+0xec>
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	0f 92       	push	r0
    10ea:	f8 01       	movw	r30, r16
    10ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    10ee:	0f 90       	pop	r0
    10f0:	0f be       	out	0x3f, r0	; 63
    10f2:	f8 01       	movw	r30, r16
    10f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10f6:	98 13       	cpse	r25, r24
    10f8:	0b c0       	rjmp	.+22     	; 0x1110 <xQueueGenericSend+0xe4>
    10fa:	6c 81       	ldd	r22, Y+4	; 0x04
    10fc:	7d 81       	ldd	r23, Y+5	; 0x05
    10fe:	c7 01       	movw	r24, r14
    1100:	d1 d5       	rcall	.+2978   	; 0x1ca4 <vTaskPlaceOnEventList>
    1102:	c8 01       	movw	r24, r16
    1104:	03 df       	rcall	.-506    	; 0xf0c <prvUnlockQueue>
    1106:	28 d4       	rcall	.+2128   	; 0x1958 <xTaskResumeAll>
    1108:	81 11       	cpse	r24, r1
    110a:	a9 cf       	rjmp	.-174    	; 0x105e <xQueueGenericSend+0x32>
    110c:	4e dd       	rcall	.-1380   	; 0xbaa <vPortYield>
    110e:	a7 cf       	rjmp	.-178    	; 0x105e <xQueueGenericSend+0x32>
    1110:	c8 01       	movw	r24, r16
    1112:	fc de       	rcall	.-520    	; 0xf0c <prvUnlockQueue>
    1114:	21 d4       	rcall	.+2114   	; 0x1958 <xTaskResumeAll>
    1116:	a3 cf       	rjmp	.-186    	; 0x105e <xQueueGenericSend+0x32>
    1118:	c8 01       	movw	r24, r16
    111a:	f8 de       	rcall	.-528    	; 0xf0c <prvUnlockQueue>
    111c:	1d d4       	rcall	.+2106   	; 0x1958 <xTaskResumeAll>
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	25 96       	adiw	r28, 0x05	; 5
    1122:	cd bf       	out	0x3d, r28	; 61
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	1f 91       	pop	r17
    112c:	0f 91       	pop	r16
    112e:	ff 90       	pop	r15
    1130:	ef 90       	pop	r14
    1132:	df 90       	pop	r13
    1134:	cf 90       	pop	r12
    1136:	bf 90       	pop	r11
    1138:	af 90       	pop	r10
    113a:	08 95       	ret

0000113c <xQueueCreateMutex>:
    113c:	cf 93       	push	r28
    113e:	df 93       	push	r29
    1140:	8f e1       	ldi	r24, 0x1F	; 31
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	54 dc       	rcall	.-1880   	; 0x9ee <pvPortMalloc>
    1146:	ec 01       	movw	r28, r24
    1148:	00 97       	sbiw	r24, 0x00	; 0
    114a:	e1 f0       	breq	.+56     	; 0x1184 <xQueueCreateMutex+0x48>
    114c:	1a 82       	std	Y+2, r1	; 0x02
    114e:	1b 82       	std	Y+3, r1	; 0x03
    1150:	18 82       	st	Y, r1
    1152:	19 82       	std	Y+1, r1	; 0x01
    1154:	1c 82       	std	Y+4, r1	; 0x04
    1156:	1d 82       	std	Y+5, r1	; 0x05
    1158:	1e 82       	std	Y+6, r1	; 0x06
    115a:	1f 82       	std	Y+7, r1	; 0x07
    115c:	1a 8e       	std	Y+26, r1	; 0x1a
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	8b 8f       	std	Y+27, r24	; 0x1b
    1162:	1c 8e       	std	Y+28, r1	; 0x1c
    1164:	8f ef       	ldi	r24, 0xFF	; 255
    1166:	8d 8f       	std	Y+29, r24	; 0x1d
    1168:	8e 8f       	std	Y+30, r24	; 0x1e
    116a:	ce 01       	movw	r24, r28
    116c:	08 96       	adiw	r24, 0x08	; 8
    116e:	ce dd       	rcall	.-1124   	; 0xd0c <vListInitialise>
    1170:	ce 01       	movw	r24, r28
    1172:	41 96       	adiw	r24, 0x11	; 17
    1174:	cb dd       	rcall	.-1130   	; 0xd0c <vListInitialise>
    1176:	20 e0       	ldi	r18, 0x00	; 0
    1178:	40 e0       	ldi	r20, 0x00	; 0
    117a:	50 e0       	ldi	r21, 0x00	; 0
    117c:	60 e0       	ldi	r22, 0x00	; 0
    117e:	70 e0       	ldi	r23, 0x00	; 0
    1180:	ce 01       	movw	r24, r28
    1182:	54 df       	rcall	.-344    	; 0x102c <xQueueGenericSend>
    1184:	ce 01       	movw	r24, r28
    1186:	df 91       	pop	r29
    1188:	cf 91       	pop	r28
    118a:	08 95       	ret

0000118c <xQueueGenericSendFromISR>:
    118c:	0f 93       	push	r16
    118e:	1f 93       	push	r17
    1190:	cf 93       	push	r28
    1192:	df 93       	push	r29
    1194:	ec 01       	movw	r28, r24
    1196:	8a 01       	movw	r16, r20
    1198:	9a 8d       	ldd	r25, Y+26	; 0x1a
    119a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    119c:	98 17       	cp	r25, r24
    119e:	b0 f4       	brcc	.+44     	; 0x11cc <xQueueGenericSendFromISR+0x40>
    11a0:	42 2f       	mov	r20, r18
    11a2:	ce 01       	movw	r24, r28
    11a4:	4d de       	rcall	.-870    	; 0xe40 <prvCopyDataToQueue>
    11a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11a8:	8f 3f       	cpi	r24, 0xFF	; 255
    11aa:	61 f4       	brne	.+24     	; 0x11c4 <xQueueGenericSendFromISR+0x38>
    11ac:	89 89       	ldd	r24, Y+17	; 0x11
    11ae:	88 23       	and	r24, r24
    11b0:	79 f0       	breq	.+30     	; 0x11d0 <xQueueGenericSendFromISR+0x44>
    11b2:	ce 01       	movw	r24, r28
    11b4:	41 96       	adiw	r24, 0x11	; 17
    11b6:	b8 d5       	rcall	.+2928   	; 0x1d28 <xTaskRemoveFromEventList>
    11b8:	88 23       	and	r24, r24
    11ba:	61 f0       	breq	.+24     	; 0x11d4 <xQueueGenericSendFromISR+0x48>
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	f8 01       	movw	r30, r16
    11c0:	80 83       	st	Z, r24
    11c2:	09 c0       	rjmp	.+18     	; 0x11d6 <xQueueGenericSendFromISR+0x4a>
    11c4:	8f 5f       	subi	r24, 0xFF	; 255
    11c6:	8e 8f       	std	Y+30, r24	; 0x1e
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	05 c0       	rjmp	.+10     	; 0x11d6 <xQueueGenericSendFromISR+0x4a>
    11cc:	80 e0       	ldi	r24, 0x00	; 0
    11ce:	03 c0       	rjmp	.+6      	; 0x11d6 <xQueueGenericSendFromISR+0x4a>
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	01 c0       	rjmp	.+2      	; 0x11d6 <xQueueGenericSendFromISR+0x4a>
    11d4:	81 e0       	ldi	r24, 0x01	; 1
    11d6:	df 91       	pop	r29
    11d8:	cf 91       	pop	r28
    11da:	1f 91       	pop	r17
    11dc:	0f 91       	pop	r16
    11de:	08 95       	ret

000011e0 <xQueueGenericReceive>:
    11e0:	af 92       	push	r10
    11e2:	bf 92       	push	r11
    11e4:	cf 92       	push	r12
    11e6:	df 92       	push	r13
    11e8:	ef 92       	push	r14
    11ea:	ff 92       	push	r15
    11ec:	0f 93       	push	r16
    11ee:	1f 93       	push	r17
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	25 97       	sbiw	r28, 0x05	; 5
    11fa:	cd bf       	out	0x3d, r28	; 61
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	8c 01       	movw	r16, r24
    1200:	6b 01       	movw	r12, r22
    1202:	4c 83       	std	Y+4, r20	; 0x04
    1204:	5d 83       	std	Y+5, r21	; 0x05
    1206:	b2 2e       	mov	r11, r18
    1208:	a1 2c       	mov	r10, r1
    120a:	7c 01       	movw	r14, r24
    120c:	81 e1       	ldi	r24, 0x11	; 17
    120e:	e8 0e       	add	r14, r24
    1210:	f1 1c       	adc	r15, r1
    1212:	0f b6       	in	r0, 0x3f	; 63
    1214:	f8 94       	cli
    1216:	0f 92       	push	r0
    1218:	f8 01       	movw	r30, r16
    121a:	82 8d       	ldd	r24, Z+26	; 0x1a
    121c:	88 23       	and	r24, r24
    121e:	69 f1       	breq	.+90     	; 0x127a <xQueueGenericReceive+0x9a>
    1220:	e6 80       	ldd	r14, Z+6	; 0x06
    1222:	f7 80       	ldd	r15, Z+7	; 0x07
    1224:	b6 01       	movw	r22, r12
    1226:	c8 01       	movw	r24, r16
    1228:	57 de       	rcall	.-850    	; 0xed8 <prvCopyDataFromQueue>
    122a:	b1 10       	cpse	r11, r1
    122c:	17 c0       	rjmp	.+46     	; 0x125c <xQueueGenericReceive+0x7c>
    122e:	f8 01       	movw	r30, r16
    1230:	82 8d       	ldd	r24, Z+26	; 0x1a
    1232:	81 50       	subi	r24, 0x01	; 1
    1234:	82 8f       	std	Z+26, r24	; 0x1a
    1236:	80 81       	ld	r24, Z
    1238:	91 81       	ldd	r25, Z+1	; 0x01
    123a:	89 2b       	or	r24, r25
    123c:	21 f4       	brne	.+8      	; 0x1246 <xQueueGenericReceive+0x66>
    123e:	04 d6       	rcall	.+3080   	; 0x1e48 <xTaskGetCurrentTaskHandle>
    1240:	f8 01       	movw	r30, r16
    1242:	82 83       	std	Z+2, r24	; 0x02
    1244:	93 83       	std	Z+3, r25	; 0x03
    1246:	f8 01       	movw	r30, r16
    1248:	80 85       	ldd	r24, Z+8	; 0x08
    124a:	88 23       	and	r24, r24
    124c:	91 f0       	breq	.+36     	; 0x1272 <xQueueGenericReceive+0x92>
    124e:	c8 01       	movw	r24, r16
    1250:	08 96       	adiw	r24, 0x08	; 8
    1252:	6a d5       	rcall	.+2772   	; 0x1d28 <xTaskRemoveFromEventList>
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	69 f4       	brne	.+26     	; 0x1272 <xQueueGenericReceive+0x92>
    1258:	a8 dc       	rcall	.-1712   	; 0xbaa <vPortYield>
    125a:	0b c0       	rjmp	.+22     	; 0x1272 <xQueueGenericReceive+0x92>
    125c:	f8 01       	movw	r30, r16
    125e:	e6 82       	std	Z+6, r14	; 0x06
    1260:	f7 82       	std	Z+7, r15	; 0x07
    1262:	81 89       	ldd	r24, Z+17	; 0x11
    1264:	88 23       	and	r24, r24
    1266:	29 f0       	breq	.+10     	; 0x1272 <xQueueGenericReceive+0x92>
    1268:	c8 01       	movw	r24, r16
    126a:	41 96       	adiw	r24, 0x11	; 17
    126c:	5d d5       	rcall	.+2746   	; 0x1d28 <xTaskRemoveFromEventList>
    126e:	81 11       	cpse	r24, r1
    1270:	9c dc       	rcall	.-1736   	; 0xbaa <vPortYield>
    1272:	0f 90       	pop	r0
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	53 c0       	rjmp	.+166    	; 0x1320 <xQueueGenericReceive+0x140>
    127a:	4c 81       	ldd	r20, Y+4	; 0x04
    127c:	5d 81       	ldd	r21, Y+5	; 0x05
    127e:	45 2b       	or	r20, r21
    1280:	21 f4       	brne	.+8      	; 0x128a <xQueueGenericReceive+0xaa>
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63
    1286:	80 e0       	ldi	r24, 0x00	; 0
    1288:	4b c0       	rjmp	.+150    	; 0x1320 <xQueueGenericReceive+0x140>
    128a:	a1 10       	cpse	r10, r1
    128c:	05 c0       	rjmp	.+10     	; 0x1298 <xQueueGenericReceive+0xb8>
    128e:	ce 01       	movw	r24, r28
    1290:	01 96       	adiw	r24, 0x01	; 1
    1292:	8d d5       	rcall	.+2842   	; 0x1dae <vTaskSetTimeOutState>
    1294:	aa 24       	eor	r10, r10
    1296:	a3 94       	inc	r10
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	89 d2       	rcall	.+1298   	; 0x17b0 <vTaskSuspendAll>
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
    12a4:	f8 01       	movw	r30, r16
    12a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    12a8:	8f 3f       	cpi	r24, 0xFF	; 255
    12aa:	09 f4       	brne	.+2      	; 0x12ae <xQueueGenericReceive+0xce>
    12ac:	15 8e       	std	Z+29, r1	; 0x1d
    12ae:	f8 01       	movw	r30, r16
    12b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    12b2:	8f 3f       	cpi	r24, 0xFF	; 255
    12b4:	09 f4       	brne	.+2      	; 0x12b8 <xQueueGenericReceive+0xd8>
    12b6:	16 8e       	std	Z+30, r1	; 0x1e
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	be 01       	movw	r22, r28
    12be:	6c 5f       	subi	r22, 0xFC	; 252
    12c0:	7f 4f       	sbci	r23, 0xFF	; 255
    12c2:	ce 01       	movw	r24, r28
    12c4:	01 96       	adiw	r24, 0x01	; 1
    12c6:	7e d5       	rcall	.+2812   	; 0x1dc4 <xTaskCheckForTimeOut>
    12c8:	81 11       	cpse	r24, r1
    12ca:	26 c0       	rjmp	.+76     	; 0x1318 <xQueueGenericReceive+0x138>
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	0f 92       	push	r0
    12d2:	f8 01       	movw	r30, r16
    12d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63
    12da:	81 11       	cpse	r24, r1
    12dc:	19 c0       	rjmp	.+50     	; 0x1310 <xQueueGenericReceive+0x130>
    12de:	f8 01       	movw	r30, r16
    12e0:	80 81       	ld	r24, Z
    12e2:	91 81       	ldd	r25, Z+1	; 0x01
    12e4:	89 2b       	or	r24, r25
    12e6:	49 f4       	brne	.+18     	; 0x12fa <xQueueGenericReceive+0x11a>
    12e8:	0f b6       	in	r0, 0x3f	; 63
    12ea:	f8 94       	cli
    12ec:	0f 92       	push	r0
    12ee:	f8 01       	movw	r30, r16
    12f0:	82 81       	ldd	r24, Z+2	; 0x02
    12f2:	93 81       	ldd	r25, Z+3	; 0x03
    12f4:	bc d5       	rcall	.+2936   	; 0x1e6e <vTaskPriorityInherit>
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	6c 81       	ldd	r22, Y+4	; 0x04
    12fc:	7d 81       	ldd	r23, Y+5	; 0x05
    12fe:	c7 01       	movw	r24, r14
    1300:	d1 d4       	rcall	.+2466   	; 0x1ca4 <vTaskPlaceOnEventList>
    1302:	c8 01       	movw	r24, r16
    1304:	03 de       	rcall	.-1018   	; 0xf0c <prvUnlockQueue>
    1306:	28 d3       	rcall	.+1616   	; 0x1958 <xTaskResumeAll>
    1308:	81 11       	cpse	r24, r1
    130a:	83 cf       	rjmp	.-250    	; 0x1212 <xQueueGenericReceive+0x32>
    130c:	4e dc       	rcall	.-1892   	; 0xbaa <vPortYield>
    130e:	81 cf       	rjmp	.-254    	; 0x1212 <xQueueGenericReceive+0x32>
    1310:	c8 01       	movw	r24, r16
    1312:	fc dd       	rcall	.-1032   	; 0xf0c <prvUnlockQueue>
    1314:	21 d3       	rcall	.+1602   	; 0x1958 <xTaskResumeAll>
    1316:	7d cf       	rjmp	.-262    	; 0x1212 <xQueueGenericReceive+0x32>
    1318:	c8 01       	movw	r24, r16
    131a:	f8 dd       	rcall	.-1040   	; 0xf0c <prvUnlockQueue>
    131c:	1d d3       	rcall	.+1594   	; 0x1958 <xTaskResumeAll>
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	25 96       	adiw	r28, 0x05	; 5
    1322:	cd bf       	out	0x3d, r28	; 61
    1324:	de bf       	out	0x3e, r29	; 62
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	1f 91       	pop	r17
    132c:	0f 91       	pop	r16
    132e:	ff 90       	pop	r15
    1330:	ef 90       	pop	r14
    1332:	df 90       	pop	r13
    1334:	cf 90       	pop	r12
    1336:	bf 90       	pop	r11
    1338:	af 90       	pop	r10
    133a:	08 95       	ret

0000133c <xQueueReceiveFromISR>:
    133c:	0f 93       	push	r16
    133e:	1f 93       	push	r17
    1340:	cf 93       	push	r28
    1342:	df 93       	push	r29
    1344:	ec 01       	movw	r28, r24
    1346:	8a 01       	movw	r16, r20
    1348:	8a 8d       	ldd	r24, Y+26	; 0x1a
    134a:	88 23       	and	r24, r24
    134c:	c1 f0       	breq	.+48     	; 0x137e <xQueueReceiveFromISR+0x42>
    134e:	ce 01       	movw	r24, r28
    1350:	c3 dd       	rcall	.-1146   	; 0xed8 <prvCopyDataFromQueue>
    1352:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1354:	81 50       	subi	r24, 0x01	; 1
    1356:	8a 8f       	std	Y+26, r24	; 0x1a
    1358:	8d 8d       	ldd	r24, Y+29	; 0x1d
    135a:	8f 3f       	cpi	r24, 0xFF	; 255
    135c:	61 f4       	brne	.+24     	; 0x1376 <xQueueReceiveFromISR+0x3a>
    135e:	88 85       	ldd	r24, Y+8	; 0x08
    1360:	88 23       	and	r24, r24
    1362:	79 f0       	breq	.+30     	; 0x1382 <xQueueReceiveFromISR+0x46>
    1364:	ce 01       	movw	r24, r28
    1366:	08 96       	adiw	r24, 0x08	; 8
    1368:	df d4       	rcall	.+2494   	; 0x1d28 <xTaskRemoveFromEventList>
    136a:	88 23       	and	r24, r24
    136c:	61 f0       	breq	.+24     	; 0x1386 <xQueueReceiveFromISR+0x4a>
    136e:	81 e0       	ldi	r24, 0x01	; 1
    1370:	f8 01       	movw	r30, r16
    1372:	80 83       	st	Z, r24
    1374:	09 c0       	rjmp	.+18     	; 0x1388 <xQueueReceiveFromISR+0x4c>
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	8d 8f       	std	Y+29, r24	; 0x1d
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	05 c0       	rjmp	.+10     	; 0x1388 <xQueueReceiveFromISR+0x4c>
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	03 c0       	rjmp	.+6      	; 0x1388 <xQueueReceiveFromISR+0x4c>
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	01 c0       	rjmp	.+2      	; 0x1388 <xQueueReceiveFromISR+0x4c>
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	08 95       	ret

00001392 <uxQueueMessagesWaiting>:
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	f8 94       	cli
    1396:	0f 92       	push	r0
    1398:	fc 01       	movw	r30, r24
    139a:	82 8d       	ldd	r24, Z+26	; 0x1a
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	08 95       	ret

000013a2 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	0f 92       	push	r0
    13ae:	8d 8d       	ldd	r24, Y+29	; 0x1d
    13b0:	8f 3f       	cpi	r24, 0xFF	; 255
    13b2:	09 f4       	brne	.+2      	; 0x13b6 <vQueueWaitForMessageRestricted+0x14>
    13b4:	1d 8e       	std	Y+29, r1	; 0x1d
    13b6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13b8:	8f 3f       	cpi	r24, 0xFF	; 255
    13ba:	09 f4       	brne	.+2      	; 0x13be <vQueueWaitForMessageRestricted+0x1c>
    13bc:	1e 8e       	std	Y+30, r1	; 0x1e
    13be:	0f 90       	pop	r0
    13c0:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
    13c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13c4:	81 11       	cpse	r24, r1
    13c6:	03 c0       	rjmp	.+6      	; 0x13ce <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13c8:	ce 01       	movw	r24, r28
    13ca:	41 96       	adiw	r24, 0x11	; 17
    13cc:	93 d4       	rcall	.+2342   	; 0x1cf4 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
    13ce:	ce 01       	movw	r24, r28
    13d0:	9d dd       	rcall	.-1222   	; 0xf0c <prvUnlockQueue>
	}
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	08 95       	ret

000013d8 <prvIdleTask>:
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    13d8:	c2 ee       	ldi	r28, 0xE2	; 226
    13da:	dc e3       	ldi	r29, 0x3C	; 60
    13dc:	88 81       	ld	r24, Y
    13de:	82 30       	cpi	r24, 0x02	; 2
    13e0:	e8 f3       	brcs	.-6      	; 0x13dc <prvIdleTask+0x4>
    13e2:	e3 db       	rcall	.-2106   	; 0xbaa <vPortYield>
    13e4:	fb cf       	rjmp	.-10     	; 0x13dc <prvIdleTask+0x4>

000013e6 <prvAddCurrentTaskToDelayedList>:
    13e6:	cf 93       	push	r28
    13e8:	df 93       	push	r29
    13ea:	ec 01       	movw	r28, r24
    13ec:	e0 91 eb 3c 	lds	r30, 0x3CEB
    13f0:	f0 91 ec 3c 	lds	r31, 0x3CEC
    13f4:	82 83       	std	Z+2, r24	; 0x02
    13f6:	93 83       	std	Z+3, r25	; 0x03
    13f8:	80 91 b7 3c 	lds	r24, 0x3CB7
    13fc:	90 91 b8 3c 	lds	r25, 0x3CB8
    1400:	c8 17       	cp	r28, r24
    1402:	d9 07       	cpc	r29, r25
    1404:	60 f4       	brcc	.+24     	; 0x141e <prvAddCurrentTaskToDelayedList+0x38>
    1406:	60 91 eb 3c 	lds	r22, 0x3CEB
    140a:	70 91 ec 3c 	lds	r23, 0x3CEC
    140e:	80 91 cc 3c 	lds	r24, 0x3CCC
    1412:	90 91 cd 3c 	lds	r25, 0x3CCD
    1416:	6e 5f       	subi	r22, 0xFE	; 254
    1418:	7f 4f       	sbci	r23, 0xFF	; 255
    141a:	b1 dc       	rcall	.-1694   	; 0xd7e <vListInsert>
    141c:	16 c0       	rjmp	.+44     	; 0x144a <prvAddCurrentTaskToDelayedList+0x64>
    141e:	60 91 eb 3c 	lds	r22, 0x3CEB
    1422:	70 91 ec 3c 	lds	r23, 0x3CEC
    1426:	80 91 ce 3c 	lds	r24, 0x3CCE
    142a:	90 91 cf 3c 	lds	r25, 0x3CCF
    142e:	6e 5f       	subi	r22, 0xFE	; 254
    1430:	7f 4f       	sbci	r23, 0xFF	; 255
    1432:	a5 dc       	rcall	.-1718   	; 0xd7e <vListInsert>
    1434:	80 91 05 20 	lds	r24, 0x2005
    1438:	90 91 06 20 	lds	r25, 0x2006
    143c:	c8 17       	cp	r28, r24
    143e:	d9 07       	cpc	r29, r25
    1440:	20 f4       	brcc	.+8      	; 0x144a <prvAddCurrentTaskToDelayedList+0x64>
    1442:	c0 93 05 20 	sts	0x2005, r28
    1446:	d0 93 06 20 	sts	0x2006, r29
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	08 95       	ret

00001450 <prvListTaskWithinSingleList>:
    1450:	3f 92       	push	r3
    1452:	4f 92       	push	r4
    1454:	5f 92       	push	r5
    1456:	6f 92       	push	r6
    1458:	7f 92       	push	r7
    145a:	8f 92       	push	r8
    145c:	9f 92       	push	r9
    145e:	af 92       	push	r10
    1460:	bf 92       	push	r11
    1462:	cf 92       	push	r12
    1464:	df 92       	push	r13
    1466:	ef 92       	push	r14
    1468:	ff 92       	push	r15
    146a:	0f 93       	push	r16
    146c:	1f 93       	push	r17
    146e:	cf 93       	push	r28
    1470:	df 93       	push	r29
    1472:	5c 01       	movw	r10, r24
    1474:	4b 01       	movw	r8, r22
    1476:	34 2e       	mov	r3, r20
    1478:	db 01       	movw	r26, r22
    147a:	11 96       	adiw	r26, 0x01	; 1
    147c:	ed 91       	ld	r30, X+
    147e:	fc 91       	ld	r31, X
    1480:	12 97       	sbiw	r26, 0x02	; 2
    1482:	02 80       	ldd	r0, Z+2	; 0x02
    1484:	f3 81       	ldd	r31, Z+3	; 0x03
    1486:	e0 2d       	mov	r30, r0
    1488:	11 96       	adiw	r26, 0x01	; 1
    148a:	ed 93       	st	X+, r30
    148c:	fc 93       	st	X, r31
    148e:	12 97       	sbiw	r26, 0x02	; 2
    1490:	7b 01       	movw	r14, r22
    1492:	b3 e0       	ldi	r27, 0x03	; 3
    1494:	eb 0e       	add	r14, r27
    1496:	f1 1c       	adc	r15, r1
    1498:	ee 15       	cp	r30, r14
    149a:	ff 05       	cpc	r31, r15
    149c:	29 f4       	brne	.+10     	; 0x14a8 <prvListTaskWithinSingleList+0x58>
    149e:	82 81       	ldd	r24, Z+2	; 0x02
    14a0:	93 81       	ldd	r25, Z+3	; 0x03
    14a2:	fb 01       	movw	r30, r22
    14a4:	81 83       	std	Z+1, r24	; 0x01
    14a6:	92 83       	std	Z+2, r25	; 0x02
    14a8:	d4 01       	movw	r26, r8
    14aa:	11 96       	adiw	r26, 0x01	; 1
    14ac:	ed 91       	ld	r30, X+
    14ae:	fc 91       	ld	r31, X
    14b0:	12 97       	sbiw	r26, 0x02	; 2
    14b2:	c6 80       	ldd	r12, Z+6	; 0x06
    14b4:	d7 80       	ldd	r13, Z+7	; 0x07
    14b6:	43 2c       	mov	r4, r3
    14b8:	55 24       	eor	r5, r5
    14ba:	47 fc       	sbrc	r4, 7
    14bc:	50 94       	com	r5
    14be:	0f 2e       	mov	r0, r31
    14c0:	ff e6       	ldi	r31, 0x6F	; 111
    14c2:	6f 2e       	mov	r6, r31
    14c4:	f0 e2       	ldi	r31, 0x20	; 32
    14c6:	7f 2e       	mov	r7, r31
    14c8:	f0 2d       	mov	r31, r0
    14ca:	08 e7       	ldi	r16, 0x78	; 120
    14cc:	1c e3       	ldi	r17, 0x3C	; 60
    14ce:	d4 01       	movw	r26, r8
    14d0:	11 96       	adiw	r26, 0x01	; 1
    14d2:	ed 91       	ld	r30, X+
    14d4:	fc 91       	ld	r31, X
    14d6:	12 97       	sbiw	r26, 0x02	; 2
    14d8:	82 81       	ldd	r24, Z+2	; 0x02
    14da:	93 81       	ldd	r25, Z+3	; 0x03
    14dc:	11 96       	adiw	r26, 0x01	; 1
    14de:	8d 93       	st	X+, r24
    14e0:	9c 93       	st	X, r25
    14e2:	12 97       	sbiw	r26, 0x02	; 2
    14e4:	e8 16       	cp	r14, r24
    14e6:	f9 06       	cpc	r15, r25
    14e8:	39 f4       	brne	.+14     	; 0x14f8 <prvListTaskWithinSingleList+0xa8>
    14ea:	f7 01       	movw	r30, r14
    14ec:	82 81       	ldd	r24, Z+2	; 0x02
    14ee:	93 81       	ldd	r25, Z+3	; 0x03
    14f0:	11 96       	adiw	r26, 0x01	; 1
    14f2:	8d 93       	st	X+, r24
    14f4:	9c 93       	st	X, r25
    14f6:	12 97       	sbiw	r26, 0x02	; 2
    14f8:	d4 01       	movw	r26, r8
    14fa:	11 96       	adiw	r26, 0x01	; 1
    14fc:	ed 91       	ld	r30, X+
    14fe:	fc 91       	ld	r31, X
    1500:	12 97       	sbiw	r26, 0x02	; 2
    1502:	c6 81       	ldd	r28, Z+6	; 0x06
    1504:	d7 81       	ldd	r29, Z+7	; 0x07
    1506:	ef 89       	ldd	r30, Y+23	; 0x17
    1508:	f8 8d       	ldd	r31, Y+24	; 0x18
    150a:	80 81       	ld	r24, Z
    150c:	85 3a       	cpi	r24, 0xA5	; 165
    150e:	41 f4       	brne	.+16     	; 0x1520 <prvListTaskWithinSingleList+0xd0>
    1510:	31 96       	adiw	r30, 0x01	; 1
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	01 96       	adiw	r24, 0x01	; 1
    1518:	21 91       	ld	r18, Z+
    151a:	25 3a       	cpi	r18, 0xA5	; 165
    151c:	e1 f3       	breq	.-8      	; 0x1516 <prvListTaskWithinSingleList+0xc6>
    151e:	02 c0       	rjmp	.+4      	; 0x1524 <prvListTaskWithinSingleList+0xd4>
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	39 a1       	ldd	r19, Y+33	; 0x21
    1526:	2e 89       	ldd	r18, Y+22	; 0x16
    1528:	1f 92       	push	r1
    152a:	3f 93       	push	r19
    152c:	9f 93       	push	r25
    152e:	8f 93       	push	r24
    1530:	1f 92       	push	r1
    1532:	2f 93       	push	r18
    1534:	5f 92       	push	r5
    1536:	3f 92       	push	r3
    1538:	ce 01       	movw	r24, r28
    153a:	49 96       	adiw	r24, 0x19	; 25
    153c:	9f 93       	push	r25
    153e:	8f 93       	push	r24
    1540:	7f 92       	push	r7
    1542:	6f 92       	push	r6
    1544:	1f 93       	push	r17
    1546:	0f 93       	push	r16
    1548:	0e 94 f5 2d 	call	0x5bea	; 0x5bea <sprintf>
    154c:	b8 01       	movw	r22, r16
    154e:	c5 01       	movw	r24, r10
    1550:	0e 94 66 2d 	call	0x5acc	; 0x5acc <strcat>
    1554:	ed b7       	in	r30, 0x3d	; 61
    1556:	fe b7       	in	r31, 0x3e	; 62
    1558:	3e 96       	adiw	r30, 0x0e	; 14
    155a:	ed bf       	out	0x3d, r30	; 61
    155c:	fe bf       	out	0x3e, r31	; 62
    155e:	cc 15       	cp	r28, r12
    1560:	dd 05       	cpc	r29, r13
    1562:	09 f0       	breq	.+2      	; 0x1566 <prvListTaskWithinSingleList+0x116>
    1564:	b4 cf       	rjmp	.-152    	; 0x14ce <prvListTaskWithinSingleList+0x7e>
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	1f 91       	pop	r17
    156c:	0f 91       	pop	r16
    156e:	ff 90       	pop	r15
    1570:	ef 90       	pop	r14
    1572:	df 90       	pop	r13
    1574:	cf 90       	pop	r12
    1576:	bf 90       	pop	r11
    1578:	af 90       	pop	r10
    157a:	9f 90       	pop	r9
    157c:	8f 90       	pop	r8
    157e:	7f 90       	pop	r7
    1580:	6f 90       	pop	r6
    1582:	5f 90       	pop	r5
    1584:	4f 90       	pop	r4
    1586:	3f 90       	pop	r3
    1588:	08 95       	ret

0000158a <xTaskGenericCreate>:
    158a:	4f 92       	push	r4
    158c:	5f 92       	push	r5
    158e:	6f 92       	push	r6
    1590:	7f 92       	push	r7
    1592:	8f 92       	push	r8
    1594:	9f 92       	push	r9
    1596:	af 92       	push	r10
    1598:	bf 92       	push	r11
    159a:	cf 92       	push	r12
    159c:	df 92       	push	r13
    159e:	ef 92       	push	r14
    15a0:	ff 92       	push	r15
    15a2:	0f 93       	push	r16
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	4c 01       	movw	r8, r24
    15aa:	3b 01       	movw	r6, r22
    15ac:	5a 01       	movw	r10, r20
    15ae:	29 01       	movw	r4, r18
    15b0:	83 e2       	ldi	r24, 0x23	; 35
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	1c da       	rcall	.-3016   	; 0x9ee <pvPortMalloc>
    15b6:	ec 01       	movw	r28, r24
    15b8:	00 97       	sbiw	r24, 0x00	; 0
    15ba:	09 f4       	brne	.+2      	; 0x15be <xTaskGenericCreate+0x34>
    15bc:	9f c0       	rjmp	.+318    	; 0x16fc <xTaskGenericCreate+0x172>
    15be:	c1 14       	cp	r12, r1
    15c0:	d1 04       	cpc	r13, r1
    15c2:	09 f0       	breq	.+2      	; 0x15c6 <xTaskGenericCreate+0x3c>
    15c4:	97 c0       	rjmp	.+302    	; 0x16f4 <xTaskGenericCreate+0x16a>
    15c6:	c5 01       	movw	r24, r10
    15c8:	12 da       	rcall	.-3036   	; 0x9ee <pvPortMalloc>
    15ca:	8f 8b       	std	Y+23, r24	; 0x17
    15cc:	98 8f       	std	Y+24, r25	; 0x18
    15ce:	00 97       	sbiw	r24, 0x00	; 0
    15d0:	19 f4       	brne	.+6      	; 0x15d8 <xTaskGenericCreate+0x4e>
    15d2:	ce 01       	movw	r24, r28
    15d4:	30 da       	rcall	.-2976   	; 0xa36 <vPortFree>
    15d6:	92 c0       	rjmp	.+292    	; 0x16fc <xTaskGenericCreate+0x172>
    15d8:	a5 01       	movw	r20, r10
    15da:	65 ea       	ldi	r22, 0xA5	; 165
    15dc:	70 e0       	ldi	r23, 0x00	; 0
    15de:	0e 94 5f 2d 	call	0x5abe	; 0x5abe <memset>
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	a8 1a       	sub	r10, r24
    15e6:	b1 08       	sbc	r11, r1
    15e8:	8f 89       	ldd	r24, Y+23	; 0x17
    15ea:	98 8d       	ldd	r25, Y+24	; 0x18
    15ec:	a8 0e       	add	r10, r24
    15ee:	b9 1e       	adc	r11, r25
    15f0:	48 e0       	ldi	r20, 0x08	; 8
    15f2:	50 e0       	ldi	r21, 0x00	; 0
    15f4:	b3 01       	movw	r22, r6
    15f6:	ce 01       	movw	r24, r28
    15f8:	49 96       	adiw	r24, 0x19	; 25
    15fa:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <strncpy>
    15fe:	18 a2       	std	Y+32, r1	; 0x20
    1600:	1e 8a       	std	Y+22, r1	; 0x16
    1602:	1a a2       	std	Y+34, r1	; 0x22
    1604:	6e 01       	movw	r12, r28
    1606:	e2 e0       	ldi	r30, 0x02	; 2
    1608:	ce 0e       	add	r12, r30
    160a:	d1 1c       	adc	r13, r1
    160c:	c6 01       	movw	r24, r12
    160e:	8c db       	rcall	.-2280   	; 0xd28 <vListInitialiseItem>
    1610:	ce 01       	movw	r24, r28
    1612:	0c 96       	adiw	r24, 0x0c	; 12
    1614:	89 db       	rcall	.-2286   	; 0xd28 <vListInitialiseItem>
    1616:	c8 87       	std	Y+8, r28	; 0x08
    1618:	d9 87       	std	Y+9, r29	; 0x09
    161a:	81 e0       	ldi	r24, 0x01	; 1
    161c:	90 e0       	ldi	r25, 0x00	; 0
    161e:	8c 87       	std	Y+12, r24	; 0x0c
    1620:	9d 87       	std	Y+13, r25	; 0x0d
    1622:	ca 8b       	std	Y+18, r28	; 0x12
    1624:	db 8b       	std	Y+19, r29	; 0x13
    1626:	a2 01       	movw	r20, r4
    1628:	b4 01       	movw	r22, r8
    162a:	c5 01       	movw	r24, r10
    162c:	0e da       	rcall	.-3044   	; 0xa4a <pxPortInitialiseStack>
    162e:	88 83       	st	Y, r24
    1630:	99 83       	std	Y+1, r25	; 0x01
    1632:	e1 14       	cp	r14, r1
    1634:	f1 04       	cpc	r15, r1
    1636:	19 f0       	breq	.+6      	; 0x163e <xTaskGenericCreate+0xb4>
    1638:	f7 01       	movw	r30, r14
    163a:	c0 83       	st	Z, r28
    163c:	d1 83       	std	Z+1, r29	; 0x01
    163e:	0f b6       	in	r0, 0x3f	; 63
    1640:	f8 94       	cli
    1642:	0f 92       	push	r0
    1644:	80 91 b9 3c 	lds	r24, 0x3CB9
    1648:	8f 5f       	subi	r24, 0xFF	; 255
    164a:	80 93 b9 3c 	sts	0x3CB9, r24
    164e:	80 91 eb 3c 	lds	r24, 0x3CEB
    1652:	90 91 ec 3c 	lds	r25, 0x3CEC
    1656:	89 2b       	or	r24, r25
    1658:	49 f4       	brne	.+18     	; 0x166c <xTaskGenericCreate+0xe2>
    165a:	c0 93 eb 3c 	sts	0x3CEB, r28
    165e:	d0 93 ec 3c 	sts	0x3CEC, r29
    1662:	80 91 b9 3c 	lds	r24, 0x3CB9
    1666:	81 30       	cpi	r24, 0x01	; 1
    1668:	81 f4       	brne	.+32     	; 0x168a <xTaskGenericCreate+0x100>
    166a:	4a c0       	rjmp	.+148    	; 0x1700 <xTaskGenericCreate+0x176>
    166c:	80 91 b4 3c 	lds	r24, 0x3CB4
    1670:	81 11       	cpse	r24, r1
    1672:	0b c0       	rjmp	.+22     	; 0x168a <xTaskGenericCreate+0x100>
    1674:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1678:	f0 91 ec 3c 	lds	r31, 0x3CEC
    167c:	86 89       	ldd	r24, Z+22	; 0x16
    167e:	08 17       	cp	r16, r24
    1680:	20 f0       	brcs	.+8      	; 0x168a <xTaskGenericCreate+0x100>
    1682:	c0 93 eb 3c 	sts	0x3CEB, r28
    1686:	d0 93 ec 3c 	sts	0x3CEC, r29
    168a:	8e 89       	ldd	r24, Y+22	; 0x16
    168c:	90 91 b6 3c 	lds	r25, 0x3CB6
    1690:	98 17       	cp	r25, r24
    1692:	10 f4       	brcc	.+4      	; 0x1698 <xTaskGenericCreate+0x10e>
    1694:	80 93 b6 3c 	sts	0x3CB6, r24
    1698:	90 91 af 3c 	lds	r25, 0x3CAF
    169c:	99 a3       	std	Y+33, r25	; 0x21
    169e:	9f 5f       	subi	r25, 0xFF	; 255
    16a0:	90 93 af 3c 	sts	0x3CAF, r25
    16a4:	90 91 b5 3c 	lds	r25, 0x3CB5
    16a8:	98 17       	cp	r25, r24
    16aa:	10 f4       	brcc	.+4      	; 0x16b0 <xTaskGenericCreate+0x126>
    16ac:	80 93 b5 3c 	sts	0x3CB5, r24
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	9c 01       	movw	r18, r24
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	82 0f       	add	r24, r18
    16c2:	93 1f       	adc	r25, r19
    16c4:	b6 01       	movw	r22, r12
    16c6:	8e 51       	subi	r24, 0x1E	; 30
    16c8:	93 4c       	sbci	r25, 0xC3	; 195
    16ca:	32 db       	rcall	.-2460   	; 0xd30 <vListInsertEnd>
    16cc:	0f 90       	pop	r0
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	80 91 b4 3c 	lds	r24, 0x3CB4
    16d4:	88 23       	and	r24, r24
    16d6:	51 f0       	breq	.+20     	; 0x16ec <xTaskGenericCreate+0x162>
    16d8:	e0 91 eb 3c 	lds	r30, 0x3CEB
    16dc:	f0 91 ec 3c 	lds	r31, 0x3CEC
    16e0:	86 89       	ldd	r24, Z+22	; 0x16
    16e2:	80 17       	cp	r24, r16
    16e4:	28 f4       	brcc	.+10     	; 0x16f0 <xTaskGenericCreate+0x166>
    16e6:	61 da       	rcall	.-2878   	; 0xbaa <vPortYield>
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	26 c0       	rjmp	.+76     	; 0x1738 <xTaskGenericCreate+0x1ae>
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	24 c0       	rjmp	.+72     	; 0x1738 <xTaskGenericCreate+0x1ae>
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	22 c0       	rjmp	.+68     	; 0x1738 <xTaskGenericCreate+0x1ae>
    16f4:	cf 8a       	std	Y+23, r12	; 0x17
    16f6:	d8 8e       	std	Y+24, r13	; 0x18
    16f8:	c6 01       	movw	r24, r12
    16fa:	6e cf       	rjmp	.-292    	; 0x15d8 <xTaskGenericCreate+0x4e>
    16fc:	8f ef       	ldi	r24, 0xFF	; 255
    16fe:	1c c0       	rjmp	.+56     	; 0x1738 <xTaskGenericCreate+0x1ae>
    1700:	82 ee       	ldi	r24, 0xE2	; 226
    1702:	9c e3       	ldi	r25, 0x3C	; 60
    1704:	03 db       	rcall	.-2554   	; 0xd0c <vListInitialise>
    1706:	89 ed       	ldi	r24, 0xD9	; 217
    1708:	9c e3       	ldi	r25, 0x3C	; 60
    170a:	00 db       	rcall	.-2560   	; 0xd0c <vListInitialise>
    170c:	80 ed       	ldi	r24, 0xD0	; 208
    170e:	9c e3       	ldi	r25, 0x3C	; 60
    1710:	fd da       	rcall	.-2566   	; 0xd0c <vListInitialise>
    1712:	83 ec       	ldi	r24, 0xC3	; 195
    1714:	9c e3       	ldi	r25, 0x3C	; 60
    1716:	fa da       	rcall	.-2572   	; 0xd0c <vListInitialise>
    1718:	8a eb       	ldi	r24, 0xBA	; 186
    171a:	9c e3       	ldi	r25, 0x3C	; 60
    171c:	f7 da       	rcall	.-2578   	; 0xd0c <vListInitialise>
    171e:	89 ed       	ldi	r24, 0xD9	; 217
    1720:	9c e3       	ldi	r25, 0x3C	; 60
    1722:	80 93 ce 3c 	sts	0x3CCE, r24
    1726:	90 93 cf 3c 	sts	0x3CCF, r25
    172a:	80 ed       	ldi	r24, 0xD0	; 208
    172c:	9c e3       	ldi	r25, 0x3C	; 60
    172e:	80 93 cc 3c 	sts	0x3CCC, r24
    1732:	90 93 cd 3c 	sts	0x3CCD, r25
    1736:	a9 cf       	rjmp	.-174    	; 0x168a <xTaskGenericCreate+0x100>
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	0f 91       	pop	r16
    173e:	ff 90       	pop	r15
    1740:	ef 90       	pop	r14
    1742:	df 90       	pop	r13
    1744:	cf 90       	pop	r12
    1746:	bf 90       	pop	r11
    1748:	af 90       	pop	r10
    174a:	9f 90       	pop	r9
    174c:	8f 90       	pop	r8
    174e:	7f 90       	pop	r7
    1750:	6f 90       	pop	r6
    1752:	5f 90       	pop	r5
    1754:	4f 90       	pop	r4
    1756:	08 95       	ret

00001758 <vTaskStartScheduler>:
    1758:	af 92       	push	r10
    175a:	bf 92       	push	r11
    175c:	cf 92       	push	r12
    175e:	df 92       	push	r13
    1760:	ef 92       	push	r14
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	a1 2c       	mov	r10, r1
    1768:	b1 2c       	mov	r11, r1
    176a:	c1 2c       	mov	r12, r1
    176c:	d1 2c       	mov	r13, r1
    176e:	e1 2c       	mov	r14, r1
    1770:	f1 2c       	mov	r15, r1
    1772:	00 e0       	ldi	r16, 0x00	; 0
    1774:	20 e0       	ldi	r18, 0x00	; 0
    1776:	30 e0       	ldi	r19, 0x00	; 0
    1778:	40 e4       	ldi	r20, 0x40	; 64
    177a:	50 e0       	ldi	r21, 0x00	; 0
    177c:	61 e8       	ldi	r22, 0x81	; 129
    177e:	70 e2       	ldi	r23, 0x20	; 32
    1780:	8c ee       	ldi	r24, 0xEC	; 236
    1782:	99 e0       	ldi	r25, 0x09	; 9
    1784:	02 df       	rcall	.-508    	; 0x158a <xTaskGenericCreate>
    1786:	81 30       	cpi	r24, 0x01	; 1
    1788:	59 f4       	brne	.+22     	; 0x17a0 <vTaskStartScheduler+0x48>
    178a:	52 d4       	rcall	.+2212   	; 0x2030 <xTimerCreateTimerTask>
    178c:	81 30       	cpi	r24, 0x01	; 1
    178e:	41 f4       	brne	.+16     	; 0x17a0 <vTaskStartScheduler+0x48>
    1790:	f8 94       	cli
    1792:	80 93 b4 3c 	sts	0x3CB4, r24
    1796:	10 92 b7 3c 	sts	0x3CB7, r1
    179a:	10 92 b8 3c 	sts	0x3CB8, r1
    179e:	c3 d9       	rcall	.-3194   	; 0xb26 <xPortStartScheduler>
    17a0:	0f 91       	pop	r16
    17a2:	ff 90       	pop	r15
    17a4:	ef 90       	pop	r14
    17a6:	df 90       	pop	r13
    17a8:	cf 90       	pop	r12
    17aa:	bf 90       	pop	r11
    17ac:	af 90       	pop	r10
    17ae:	08 95       	ret

000017b0 <vTaskSuspendAll>:
    17b0:	80 91 b3 3c 	lds	r24, 0x3CB3
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	80 93 b3 3c 	sts	0x3CB3, r24
    17ba:	08 95       	ret

000017bc <xTaskGetTickCount>:
    17bc:	0f b6       	in	r0, 0x3f	; 63
    17be:	f8 94       	cli
    17c0:	0f 92       	push	r0
    17c2:	80 91 b7 3c 	lds	r24, 0x3CB7
    17c6:	90 91 b8 3c 	lds	r25, 0x3CB8
    17ca:	0f 90       	pop	r0
    17cc:	0f be       	out	0x3f, r0	; 63
    17ce:	08 95       	ret

000017d0 <uxTaskGetNumberOfTasks>:
    17d0:	80 91 b9 3c 	lds	r24, 0x3CB9
    17d4:	08 95       	ret

000017d6 <vTaskIncrementTick>:
    17d6:	0f 93       	push	r16
    17d8:	1f 93       	push	r17
    17da:	cf 93       	push	r28
    17dc:	df 93       	push	r29
    17de:	80 91 b3 3c 	lds	r24, 0x3CB3
    17e2:	81 11       	cpse	r24, r1
    17e4:	af c0       	rjmp	.+350    	; 0x1944 <vTaskIncrementTick+0x16e>
    17e6:	80 91 b7 3c 	lds	r24, 0x3CB7
    17ea:	90 91 b8 3c 	lds	r25, 0x3CB8
    17ee:	01 96       	adiw	r24, 0x01	; 1
    17f0:	80 93 b7 3c 	sts	0x3CB7, r24
    17f4:	90 93 b8 3c 	sts	0x3CB8, r25
    17f8:	80 91 b7 3c 	lds	r24, 0x3CB7
    17fc:	90 91 b8 3c 	lds	r25, 0x3CB8
    1800:	89 2b       	or	r24, r25
    1802:	99 f5       	brne	.+102    	; 0x186a <vTaskIncrementTick+0x94>
    1804:	80 91 ce 3c 	lds	r24, 0x3CCE
    1808:	90 91 cf 3c 	lds	r25, 0x3CCF
    180c:	20 91 cc 3c 	lds	r18, 0x3CCC
    1810:	30 91 cd 3c 	lds	r19, 0x3CCD
    1814:	20 93 ce 3c 	sts	0x3CCE, r18
    1818:	30 93 cf 3c 	sts	0x3CCF, r19
    181c:	80 93 cc 3c 	sts	0x3CCC, r24
    1820:	90 93 cd 3c 	sts	0x3CCD, r25
    1824:	80 91 b0 3c 	lds	r24, 0x3CB0
    1828:	8f 5f       	subi	r24, 0xFF	; 255
    182a:	80 93 b0 3c 	sts	0x3CB0, r24
    182e:	e0 91 ce 3c 	lds	r30, 0x3CCE
    1832:	f0 91 cf 3c 	lds	r31, 0x3CCF
    1836:	80 81       	ld	r24, Z
    1838:	81 11       	cpse	r24, r1
    183a:	07 c0       	rjmp	.+14     	; 0x184a <vTaskIncrementTick+0x74>
    183c:	8f ef       	ldi	r24, 0xFF	; 255
    183e:	9f ef       	ldi	r25, 0xFF	; 255
    1840:	80 93 05 20 	sts	0x2005, r24
    1844:	90 93 06 20 	sts	0x2006, r25
    1848:	10 c0       	rjmp	.+32     	; 0x186a <vTaskIncrementTick+0x94>
    184a:	e0 91 ce 3c 	lds	r30, 0x3CCE
    184e:	f0 91 cf 3c 	lds	r31, 0x3CCF
    1852:	05 80       	ldd	r0, Z+5	; 0x05
    1854:	f6 81       	ldd	r31, Z+6	; 0x06
    1856:	e0 2d       	mov	r30, r0
    1858:	06 80       	ldd	r0, Z+6	; 0x06
    185a:	f7 81       	ldd	r31, Z+7	; 0x07
    185c:	e0 2d       	mov	r30, r0
    185e:	82 81       	ldd	r24, Z+2	; 0x02
    1860:	93 81       	ldd	r25, Z+3	; 0x03
    1862:	80 93 05 20 	sts	0x2005, r24
    1866:	90 93 06 20 	sts	0x2006, r25
    186a:	20 91 b7 3c 	lds	r18, 0x3CB7
    186e:	30 91 b8 3c 	lds	r19, 0x3CB8
    1872:	80 91 05 20 	lds	r24, 0x2005
    1876:	90 91 06 20 	lds	r25, 0x2006
    187a:	28 17       	cp	r18, r24
    187c:	39 07       	cpc	r19, r25
    187e:	08 f4       	brcc	.+2      	; 0x1882 <vTaskIncrementTick+0xac>
    1880:	66 c0       	rjmp	.+204    	; 0x194e <vTaskIncrementTick+0x178>
    1882:	e0 91 ce 3c 	lds	r30, 0x3CCE
    1886:	f0 91 cf 3c 	lds	r31, 0x3CCF
    188a:	80 81       	ld	r24, Z
    188c:	88 23       	and	r24, r24
    188e:	99 f0       	breq	.+38     	; 0x18b6 <vTaskIncrementTick+0xe0>
    1890:	e0 91 ce 3c 	lds	r30, 0x3CCE
    1894:	f0 91 cf 3c 	lds	r31, 0x3CCF
    1898:	05 80       	ldd	r0, Z+5	; 0x05
    189a:	f6 81       	ldd	r31, Z+6	; 0x06
    189c:	e0 2d       	mov	r30, r0
    189e:	c6 81       	ldd	r28, Z+6	; 0x06
    18a0:	d7 81       	ldd	r29, Z+7	; 0x07
    18a2:	8a 81       	ldd	r24, Y+2	; 0x02
    18a4:	9b 81       	ldd	r25, Y+3	; 0x03
    18a6:	20 91 b7 3c 	lds	r18, 0x3CB7
    18aa:	30 91 b8 3c 	lds	r19, 0x3CB8
    18ae:	28 17       	cp	r18, r24
    18b0:	39 07       	cpc	r19, r25
    18b2:	f8 f4       	brcc	.+62     	; 0x18f2 <vTaskIncrementTick+0x11c>
    18b4:	19 c0       	rjmp	.+50     	; 0x18e8 <vTaskIncrementTick+0x112>
    18b6:	8f ef       	ldi	r24, 0xFF	; 255
    18b8:	9f ef       	ldi	r25, 0xFF	; 255
    18ba:	80 93 05 20 	sts	0x2005, r24
    18be:	90 93 06 20 	sts	0x2006, r25
    18c2:	45 c0       	rjmp	.+138    	; 0x194e <vTaskIncrementTick+0x178>
    18c4:	e0 91 ce 3c 	lds	r30, 0x3CCE
    18c8:	f0 91 cf 3c 	lds	r31, 0x3CCF
    18cc:	05 80       	ldd	r0, Z+5	; 0x05
    18ce:	f6 81       	ldd	r31, Z+6	; 0x06
    18d0:	e0 2d       	mov	r30, r0
    18d2:	c6 81       	ldd	r28, Z+6	; 0x06
    18d4:	d7 81       	ldd	r29, Z+7	; 0x07
    18d6:	8a 81       	ldd	r24, Y+2	; 0x02
    18d8:	9b 81       	ldd	r25, Y+3	; 0x03
    18da:	20 91 b7 3c 	lds	r18, 0x3CB7
    18de:	30 91 b8 3c 	lds	r19, 0x3CB8
    18e2:	28 17       	cp	r18, r24
    18e4:	39 07       	cpc	r19, r25
    18e6:	28 f4       	brcc	.+10     	; 0x18f2 <vTaskIncrementTick+0x11c>
    18e8:	80 93 05 20 	sts	0x2005, r24
    18ec:	90 93 06 20 	sts	0x2006, r25
    18f0:	2e c0       	rjmp	.+92     	; 0x194e <vTaskIncrementTick+0x178>
    18f2:	8e 01       	movw	r16, r28
    18f4:	0e 5f       	subi	r16, 0xFE	; 254
    18f6:	1f 4f       	sbci	r17, 0xFF	; 255
    18f8:	c8 01       	movw	r24, r16
    18fa:	7c da       	rcall	.-2824   	; 0xdf4 <vListRemove>
    18fc:	8c 89       	ldd	r24, Y+20	; 0x14
    18fe:	9d 89       	ldd	r25, Y+21	; 0x15
    1900:	89 2b       	or	r24, r25
    1902:	19 f0       	breq	.+6      	; 0x190a <vTaskIncrementTick+0x134>
    1904:	ce 01       	movw	r24, r28
    1906:	0c 96       	adiw	r24, 0x0c	; 12
    1908:	75 da       	rcall	.-2838   	; 0xdf4 <vListRemove>
    190a:	8e 89       	ldd	r24, Y+22	; 0x16
    190c:	90 91 b5 3c 	lds	r25, 0x3CB5
    1910:	98 17       	cp	r25, r24
    1912:	10 f4       	brcc	.+4      	; 0x1918 <vTaskIncrementTick+0x142>
    1914:	80 93 b5 3c 	sts	0x3CB5, r24
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	9c 01       	movw	r18, r24
    191c:	22 0f       	add	r18, r18
    191e:	33 1f       	adc	r19, r19
    1920:	22 0f       	add	r18, r18
    1922:	33 1f       	adc	r19, r19
    1924:	22 0f       	add	r18, r18
    1926:	33 1f       	adc	r19, r19
    1928:	82 0f       	add	r24, r18
    192a:	93 1f       	adc	r25, r19
    192c:	b8 01       	movw	r22, r16
    192e:	8e 51       	subi	r24, 0x1E	; 30
    1930:	93 4c       	sbci	r25, 0xC3	; 195
    1932:	fe d9       	rcall	.-3076   	; 0xd30 <vListInsertEnd>
    1934:	e0 91 ce 3c 	lds	r30, 0x3CCE
    1938:	f0 91 cf 3c 	lds	r31, 0x3CCF
    193c:	80 81       	ld	r24, Z
    193e:	81 11       	cpse	r24, r1
    1940:	c1 cf       	rjmp	.-126    	; 0x18c4 <vTaskIncrementTick+0xee>
    1942:	b9 cf       	rjmp	.-142    	; 0x18b6 <vTaskIncrementTick+0xe0>
    1944:	80 91 b2 3c 	lds	r24, 0x3CB2
    1948:	8f 5f       	subi	r24, 0xFF	; 255
    194a:	80 93 b2 3c 	sts	0x3CB2, r24
    194e:	df 91       	pop	r29
    1950:	cf 91       	pop	r28
    1952:	1f 91       	pop	r17
    1954:	0f 91       	pop	r16
    1956:	08 95       	ret

00001958 <xTaskResumeAll>:
    1958:	bf 92       	push	r11
    195a:	cf 92       	push	r12
    195c:	df 92       	push	r13
    195e:	ef 92       	push	r14
    1960:	ff 92       	push	r15
    1962:	0f 93       	push	r16
    1964:	1f 93       	push	r17
    1966:	cf 93       	push	r28
    1968:	df 93       	push	r29
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	0f 92       	push	r0
    1970:	80 91 b3 3c 	lds	r24, 0x3CB3
    1974:	81 50       	subi	r24, 0x01	; 1
    1976:	80 93 b3 3c 	sts	0x3CB3, r24
    197a:	80 91 b3 3c 	lds	r24, 0x3CB3
    197e:	81 11       	cpse	r24, r1
    1980:	62 c0       	rjmp	.+196    	; 0x1a46 <xTaskResumeAll+0xee>
    1982:	80 91 b9 3c 	lds	r24, 0x3CB9
    1986:	88 23       	and	r24, r24
    1988:	09 f4       	brne	.+2      	; 0x198c <xTaskResumeAll+0x34>
    198a:	5f c0       	rjmp	.+190    	; 0x1a4a <xTaskResumeAll+0xf2>
    198c:	b1 2c       	mov	r11, r1
    198e:	0f 2e       	mov	r0, r31
    1990:	f3 ec       	ldi	r31, 0xC3	; 195
    1992:	ef 2e       	mov	r14, r31
    1994:	fc e3       	ldi	r31, 0x3C	; 60
    1996:	ff 2e       	mov	r15, r31
    1998:	f0 2d       	mov	r31, r0
    199a:	0f 2e       	mov	r0, r31
    199c:	f8 ec       	ldi	r31, 0xC8	; 200
    199e:	cf 2e       	mov	r12, r31
    19a0:	fc e3       	ldi	r31, 0x3C	; 60
    19a2:	df 2e       	mov	r13, r31
    19a4:	f0 2d       	mov	r31, r0
    19a6:	2c c0       	rjmp	.+88     	; 0x1a00 <xTaskResumeAll+0xa8>
    19a8:	d6 01       	movw	r26, r12
    19aa:	ed 91       	ld	r30, X+
    19ac:	fc 91       	ld	r31, X
    19ae:	c6 81       	ldd	r28, Z+6	; 0x06
    19b0:	d7 81       	ldd	r29, Z+7	; 0x07
    19b2:	ce 01       	movw	r24, r28
    19b4:	0c 96       	adiw	r24, 0x0c	; 12
    19b6:	1e da       	rcall	.-3012   	; 0xdf4 <vListRemove>
    19b8:	8e 01       	movw	r16, r28
    19ba:	0e 5f       	subi	r16, 0xFE	; 254
    19bc:	1f 4f       	sbci	r17, 0xFF	; 255
    19be:	c8 01       	movw	r24, r16
    19c0:	19 da       	rcall	.-3022   	; 0xdf4 <vListRemove>
    19c2:	8e 89       	ldd	r24, Y+22	; 0x16
    19c4:	90 91 b5 3c 	lds	r25, 0x3CB5
    19c8:	98 17       	cp	r25, r24
    19ca:	10 f4       	brcc	.+4      	; 0x19d0 <xTaskResumeAll+0x78>
    19cc:	80 93 b5 3c 	sts	0x3CB5, r24
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	9c 01       	movw	r18, r24
    19d4:	22 0f       	add	r18, r18
    19d6:	33 1f       	adc	r19, r19
    19d8:	22 0f       	add	r18, r18
    19da:	33 1f       	adc	r19, r19
    19dc:	22 0f       	add	r18, r18
    19de:	33 1f       	adc	r19, r19
    19e0:	82 0f       	add	r24, r18
    19e2:	93 1f       	adc	r25, r19
    19e4:	b8 01       	movw	r22, r16
    19e6:	8e 51       	subi	r24, 0x1E	; 30
    19e8:	93 4c       	sbci	r25, 0xC3	; 195
    19ea:	a2 d9       	rcall	.-3260   	; 0xd30 <vListInsertEnd>
    19ec:	e0 91 eb 3c 	lds	r30, 0x3CEB
    19f0:	f0 91 ec 3c 	lds	r31, 0x3CEC
    19f4:	9e 89       	ldd	r25, Y+22	; 0x16
    19f6:	86 89       	ldd	r24, Z+22	; 0x16
    19f8:	98 17       	cp	r25, r24
    19fa:	10 f0       	brcs	.+4      	; 0x1a00 <xTaskResumeAll+0xa8>
    19fc:	bb 24       	eor	r11, r11
    19fe:	b3 94       	inc	r11
    1a00:	f7 01       	movw	r30, r14
    1a02:	80 81       	ld	r24, Z
    1a04:	81 11       	cpse	r24, r1
    1a06:	d0 cf       	rjmp	.-96     	; 0x19a8 <xTaskResumeAll+0x50>
    1a08:	80 91 b2 3c 	lds	r24, 0x3CB2
    1a0c:	88 23       	and	r24, r24
    1a0e:	79 f0       	breq	.+30     	; 0x1a2e <xTaskResumeAll+0xd6>
    1a10:	80 91 b2 3c 	lds	r24, 0x3CB2
    1a14:	88 23       	and	r24, r24
    1a16:	91 f0       	breq	.+36     	; 0x1a3c <xTaskResumeAll+0xe4>
    1a18:	de de       	rcall	.-580    	; 0x17d6 <vTaskIncrementTick>
    1a1a:	80 91 b2 3c 	lds	r24, 0x3CB2
    1a1e:	81 50       	subi	r24, 0x01	; 1
    1a20:	80 93 b2 3c 	sts	0x3CB2, r24
    1a24:	80 91 b2 3c 	lds	r24, 0x3CB2
    1a28:	81 11       	cpse	r24, r1
    1a2a:	f6 cf       	rjmp	.-20     	; 0x1a18 <xTaskResumeAll+0xc0>
    1a2c:	07 c0       	rjmp	.+14     	; 0x1a3c <xTaskResumeAll+0xe4>
    1a2e:	f1 e0       	ldi	r31, 0x01	; 1
    1a30:	bf 16       	cp	r11, r31
    1a32:	21 f0       	breq	.+8      	; 0x1a3c <xTaskResumeAll+0xe4>
    1a34:	80 91 b1 3c 	lds	r24, 0x3CB1
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	49 f4       	brne	.+18     	; 0x1a4e <xTaskResumeAll+0xf6>
    1a3c:	10 92 b1 3c 	sts	0x3CB1, r1
    1a40:	b4 d8       	rcall	.-3736   	; 0xbaa <vPortYield>
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	05 c0       	rjmp	.+10     	; 0x1a50 <xTaskResumeAll+0xf8>
    1a46:	80 e0       	ldi	r24, 0x00	; 0
    1a48:	03 c0       	rjmp	.+6      	; 0x1a50 <xTaskResumeAll+0xf8>
    1a4a:	80 e0       	ldi	r24, 0x00	; 0
    1a4c:	01 c0       	rjmp	.+2      	; 0x1a50 <xTaskResumeAll+0xf8>
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	0f 90       	pop	r0
    1a52:	0f be       	out	0x3f, r0	; 63
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	ff 90       	pop	r15
    1a5e:	ef 90       	pop	r14
    1a60:	df 90       	pop	r13
    1a62:	cf 90       	pop	r12
    1a64:	bf 90       	pop	r11
    1a66:	08 95       	ret

00001a68 <vTaskDelay>:
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29
    1a6c:	ec 01       	movw	r28, r24
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	91 f0       	breq	.+36     	; 0x1a96 <vTaskDelay+0x2e>
    1a72:	9e de       	rcall	.-708    	; 0x17b0 <vTaskSuspendAll>
    1a74:	80 91 b7 3c 	lds	r24, 0x3CB7
    1a78:	90 91 b8 3c 	lds	r25, 0x3CB8
    1a7c:	c8 0f       	add	r28, r24
    1a7e:	d9 1f       	adc	r29, r25
    1a80:	80 91 eb 3c 	lds	r24, 0x3CEB
    1a84:	90 91 ec 3c 	lds	r25, 0x3CEC
    1a88:	02 96       	adiw	r24, 0x02	; 2
    1a8a:	b4 d9       	rcall	.-3224   	; 0xdf4 <vListRemove>
    1a8c:	ce 01       	movw	r24, r28
    1a8e:	ab dc       	rcall	.-1706   	; 0x13e6 <prvAddCurrentTaskToDelayedList>
    1a90:	63 df       	rcall	.-314    	; 0x1958 <xTaskResumeAll>
    1a92:	81 11       	cpse	r24, r1
    1a94:	01 c0       	rjmp	.+2      	; 0x1a98 <vTaskDelay+0x30>
    1a96:	89 d8       	rcall	.-3822   	; 0xbaa <vPortYield>
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	08 95       	ret

00001a9e <vTaskList>:
    1a9e:	1f 93       	push	r17
    1aa0:	cf 93       	push	r28
    1aa2:	df 93       	push	r29
    1aa4:	ec 01       	movw	r28, r24
    1aa6:	84 de       	rcall	.-760    	; 0x17b0 <vTaskSuspendAll>
    1aa8:	18 82       	st	Y, r1
    1aaa:	fe 01       	movw	r30, r28
    1aac:	01 90       	ld	r0, Z+
    1aae:	00 20       	and	r0, r0
    1ab0:	e9 f7       	brne	.-6      	; 0x1aac <vTaskList+0xe>
    1ab2:	31 97       	sbiw	r30, 0x01	; 1
    1ab4:	2d e0       	ldi	r18, 0x0D	; 13
    1ab6:	3a e0       	ldi	r19, 0x0A	; 10
    1ab8:	40 e0       	ldi	r20, 0x00	; 0
    1aba:	20 83       	st	Z, r18
    1abc:	31 83       	std	Z+1, r19	; 0x01
    1abe:	42 83       	std	Z+2, r20	; 0x02
    1ac0:	10 91 b6 3c 	lds	r17, 0x3CB6
    1ac4:	1f 5f       	subi	r17, 0xFF	; 255
    1ac6:	11 50       	subi	r17, 0x01	; 1
    1ac8:	21 2f       	mov	r18, r17
    1aca:	30 e0       	ldi	r19, 0x00	; 0
    1acc:	f9 01       	movw	r30, r18
    1ace:	ee 0f       	add	r30, r30
    1ad0:	ff 1f       	adc	r31, r31
    1ad2:	ee 0f       	add	r30, r30
    1ad4:	ff 1f       	adc	r31, r31
    1ad6:	ee 0f       	add	r30, r30
    1ad8:	ff 1f       	adc	r31, r31
    1ada:	e2 0f       	add	r30, r18
    1adc:	f3 1f       	adc	r31, r19
    1ade:	ee 51       	subi	r30, 0x1E	; 30
    1ae0:	f3 4c       	sbci	r31, 0xC3	; 195
    1ae2:	80 81       	ld	r24, Z
    1ae4:	88 23       	and	r24, r24
    1ae6:	21 f0       	breq	.+8      	; 0x1af0 <vTaskList+0x52>
    1ae8:	bf 01       	movw	r22, r30
    1aea:	42 e5       	ldi	r20, 0x52	; 82
    1aec:	ce 01       	movw	r24, r28
    1aee:	b0 dc       	rcall	.-1696   	; 0x1450 <prvListTaskWithinSingleList>
    1af0:	11 11       	cpse	r17, r1
    1af2:	e9 cf       	rjmp	.-46     	; 0x1ac6 <vTaskList+0x28>
    1af4:	e0 91 ce 3c 	lds	r30, 0x3CCE
    1af8:	f0 91 cf 3c 	lds	r31, 0x3CCF
    1afc:	80 81       	ld	r24, Z
    1afe:	88 23       	and	r24, r24
    1b00:	39 f0       	breq	.+14     	; 0x1b10 <vTaskList+0x72>
    1b02:	60 91 ce 3c 	lds	r22, 0x3CCE
    1b06:	70 91 cf 3c 	lds	r23, 0x3CCF
    1b0a:	42 e4       	ldi	r20, 0x42	; 66
    1b0c:	ce 01       	movw	r24, r28
    1b0e:	a0 dc       	rcall	.-1728   	; 0x1450 <prvListTaskWithinSingleList>
    1b10:	e0 91 cc 3c 	lds	r30, 0x3CCC
    1b14:	f0 91 cd 3c 	lds	r31, 0x3CCD
    1b18:	80 81       	ld	r24, Z
    1b1a:	88 23       	and	r24, r24
    1b1c:	39 f0       	breq	.+14     	; 0x1b2c <vTaskList+0x8e>
    1b1e:	60 91 cc 3c 	lds	r22, 0x3CCC
    1b22:	70 91 cd 3c 	lds	r23, 0x3CCD
    1b26:	42 e4       	ldi	r20, 0x42	; 66
    1b28:	ce 01       	movw	r24, r28
    1b2a:	92 dc       	rcall	.-1756   	; 0x1450 <prvListTaskWithinSingleList>
    1b2c:	80 91 ba 3c 	lds	r24, 0x3CBA
    1b30:	88 23       	and	r24, r24
    1b32:	29 f0       	breq	.+10     	; 0x1b3e <vTaskList+0xa0>
    1b34:	43 e5       	ldi	r20, 0x53	; 83
    1b36:	6a eb       	ldi	r22, 0xBA	; 186
    1b38:	7c e3       	ldi	r23, 0x3C	; 60
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	89 dc       	rcall	.-1774   	; 0x1450 <prvListTaskWithinSingleList>
    1b3e:	0c df       	rcall	.-488    	; 0x1958 <xTaskResumeAll>
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	1f 91       	pop	r17
    1b46:	08 95       	ret

00001b48 <vTaskSwitchContext>:
    1b48:	80 91 b3 3c 	lds	r24, 0x3CB3
    1b4c:	81 11       	cpse	r24, r1
    1b4e:	13 c0       	rjmp	.+38     	; 0x1b76 <vTaskSwitchContext+0x2e>
    1b50:	80 91 b5 3c 	lds	r24, 0x3CB5
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	fc 01       	movw	r30, r24
    1b58:	ee 0f       	add	r30, r30
    1b5a:	ff 1f       	adc	r31, r31
    1b5c:	ee 0f       	add	r30, r30
    1b5e:	ff 1f       	adc	r31, r31
    1b60:	ee 0f       	add	r30, r30
    1b62:	ff 1f       	adc	r31, r31
    1b64:	8e 0f       	add	r24, r30
    1b66:	9f 1f       	adc	r25, r31
    1b68:	fc 01       	movw	r30, r24
    1b6a:	ee 51       	subi	r30, 0x1E	; 30
    1b6c:	f3 4c       	sbci	r31, 0xC3	; 195
    1b6e:	80 81       	ld	r24, Z
    1b70:	88 23       	and	r24, r24
    1b72:	29 f0       	breq	.+10     	; 0x1b7e <vTaskSwitchContext+0x36>
    1b74:	1b c0       	rjmp	.+54     	; 0x1bac <vTaskSwitchContext+0x64>
    1b76:	81 e0       	ldi	r24, 0x01	; 1
    1b78:	80 93 b1 3c 	sts	0x3CB1, r24
    1b7c:	08 95       	ret
    1b7e:	80 91 b5 3c 	lds	r24, 0x3CB5
    1b82:	81 50       	subi	r24, 0x01	; 1
    1b84:	80 93 b5 3c 	sts	0x3CB5, r24
    1b88:	80 91 b5 3c 	lds	r24, 0x3CB5
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	fc 01       	movw	r30, r24
    1b90:	ee 0f       	add	r30, r30
    1b92:	ff 1f       	adc	r31, r31
    1b94:	ee 0f       	add	r30, r30
    1b96:	ff 1f       	adc	r31, r31
    1b98:	ee 0f       	add	r30, r30
    1b9a:	ff 1f       	adc	r31, r31
    1b9c:	8e 0f       	add	r24, r30
    1b9e:	9f 1f       	adc	r25, r31
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	ee 51       	subi	r30, 0x1E	; 30
    1ba4:	f3 4c       	sbci	r31, 0xC3	; 195
    1ba6:	80 81       	ld	r24, Z
    1ba8:	88 23       	and	r24, r24
    1baa:	49 f3       	breq	.-46     	; 0x1b7e <vTaskSwitchContext+0x36>
    1bac:	e0 91 b5 3c 	lds	r30, 0x3CB5
    1bb0:	f0 e0       	ldi	r31, 0x00	; 0
    1bb2:	cf 01       	movw	r24, r30
    1bb4:	88 0f       	add	r24, r24
    1bb6:	99 1f       	adc	r25, r25
    1bb8:	88 0f       	add	r24, r24
    1bba:	99 1f       	adc	r25, r25
    1bbc:	88 0f       	add	r24, r24
    1bbe:	99 1f       	adc	r25, r25
    1bc0:	e8 0f       	add	r30, r24
    1bc2:	f9 1f       	adc	r31, r25
    1bc4:	ee 51       	subi	r30, 0x1E	; 30
    1bc6:	f3 4c       	sbci	r31, 0xC3	; 195
    1bc8:	a1 81       	ldd	r26, Z+1	; 0x01
    1bca:	b2 81       	ldd	r27, Z+2	; 0x02
    1bcc:	12 96       	adiw	r26, 0x02	; 2
    1bce:	0d 90       	ld	r0, X+
    1bd0:	bc 91       	ld	r27, X
    1bd2:	a0 2d       	mov	r26, r0
    1bd4:	a1 83       	std	Z+1, r26	; 0x01
    1bd6:	b2 83       	std	Z+2, r27	; 0x02
    1bd8:	cf 01       	movw	r24, r30
    1bda:	03 96       	adiw	r24, 0x03	; 3
    1bdc:	a8 17       	cp	r26, r24
    1bde:	b9 07       	cpc	r27, r25
    1be0:	31 f4       	brne	.+12     	; 0x1bee <vTaskSwitchContext+0xa6>
    1be2:	12 96       	adiw	r26, 0x02	; 2
    1be4:	8d 91       	ld	r24, X+
    1be6:	9c 91       	ld	r25, X
    1be8:	13 97       	sbiw	r26, 0x03	; 3
    1bea:	81 83       	std	Z+1, r24	; 0x01
    1bec:	92 83       	std	Z+2, r25	; 0x02
    1bee:	01 80       	ldd	r0, Z+1	; 0x01
    1bf0:	f2 81       	ldd	r31, Z+2	; 0x02
    1bf2:	e0 2d       	mov	r30, r0
    1bf4:	86 81       	ldd	r24, Z+6	; 0x06
    1bf6:	97 81       	ldd	r25, Z+7	; 0x07
    1bf8:	80 93 eb 3c 	sts	0x3CEB, r24
    1bfc:	90 93 ec 3c 	sts	0x3CEC, r25
    1c00:	80 91 aa 3c 	lds	r24, 0x3CAA
    1c04:	88 23       	and	r24, r24
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <vTaskSwitchContext+0xc2>
    1c08:	4c c0       	rjmp	.+152    	; 0x1ca2 <vTaskSwitchContext+0x15a>
    1c0a:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1c0e:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1c12:	91 a1       	ldd	r25, Z+33	; 0x21
    1c14:	80 91 04 20 	lds	r24, 0x2004
    1c18:	98 17       	cp	r25, r24
    1c1a:	09 f4       	brne	.+2      	; 0x1c1e <vTaskSwitchContext+0xd6>
    1c1c:	42 c0       	rjmp	.+132    	; 0x1ca2 <vTaskSwitchContext+0x15a>
    1c1e:	80 91 ad 3c 	lds	r24, 0x3CAD
    1c22:	90 91 ae 3c 	lds	r25, 0x3CAE
    1c26:	08 96       	adiw	r24, 0x08	; 8
    1c28:	20 91 ab 3c 	lds	r18, 0x3CAB
    1c2c:	30 91 ac 3c 	lds	r19, 0x3CAC
    1c30:	82 17       	cp	r24, r18
    1c32:	93 07       	cpc	r25, r19
    1c34:	a0 f5       	brcc	.+104    	; 0x1c9e <vTaskSwitchContext+0x156>
    1c36:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1c3a:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1c3e:	81 a1       	ldd	r24, Z+33	; 0x21
    1c40:	80 93 04 20 	sts	0x2004, r24
    1c44:	e0 91 ad 3c 	lds	r30, 0x3CAD
    1c48:	f0 91 ae 3c 	lds	r31, 0x3CAE
    1c4c:	40 91 b7 3c 	lds	r20, 0x3CB7
    1c50:	50 91 b8 3c 	lds	r21, 0x3CB8
    1c54:	60 e0       	ldi	r22, 0x00	; 0
    1c56:	70 e0       	ldi	r23, 0x00	; 0
    1c58:	40 83       	st	Z, r20
    1c5a:	51 83       	std	Z+1, r21	; 0x01
    1c5c:	62 83       	std	Z+2, r22	; 0x02
    1c5e:	73 83       	std	Z+3, r23	; 0x03
    1c60:	20 91 ad 3c 	lds	r18, 0x3CAD
    1c64:	30 91 ae 3c 	lds	r19, 0x3CAE
    1c68:	2c 5f       	subi	r18, 0xFC	; 252
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	20 93 ad 3c 	sts	0x3CAD, r18
    1c70:	30 93 ae 3c 	sts	0x3CAE, r19
    1c74:	e0 91 ad 3c 	lds	r30, 0x3CAD
    1c78:	f0 91 ae 3c 	lds	r31, 0x3CAE
    1c7c:	90 e0       	ldi	r25, 0x00	; 0
    1c7e:	a0 e0       	ldi	r26, 0x00	; 0
    1c80:	b0 e0       	ldi	r27, 0x00	; 0
    1c82:	80 83       	st	Z, r24
    1c84:	91 83       	std	Z+1, r25	; 0x01
    1c86:	a2 83       	std	Z+2, r26	; 0x02
    1c88:	b3 83       	std	Z+3, r27	; 0x03
    1c8a:	80 91 ad 3c 	lds	r24, 0x3CAD
    1c8e:	90 91 ae 3c 	lds	r25, 0x3CAE
    1c92:	04 96       	adiw	r24, 0x04	; 4
    1c94:	80 93 ad 3c 	sts	0x3CAD, r24
    1c98:	90 93 ae 3c 	sts	0x3CAE, r25
    1c9c:	08 95       	ret
    1c9e:	10 92 aa 3c 	sts	0x3CAA, r1
    1ca2:	08 95       	ret

00001ca4 <vTaskPlaceOnEventList>:
    1ca4:	cf 93       	push	r28
    1ca6:	df 93       	push	r29
    1ca8:	eb 01       	movw	r28, r22
    1caa:	60 91 eb 3c 	lds	r22, 0x3CEB
    1cae:	70 91 ec 3c 	lds	r23, 0x3CEC
    1cb2:	64 5f       	subi	r22, 0xF4	; 244
    1cb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb6:	63 d8       	rcall	.-3898   	; 0xd7e <vListInsert>
    1cb8:	80 91 eb 3c 	lds	r24, 0x3CEB
    1cbc:	90 91 ec 3c 	lds	r25, 0x3CEC
    1cc0:	02 96       	adiw	r24, 0x02	; 2
    1cc2:	98 d8       	rcall	.-3792   	; 0xdf4 <vListRemove>
    1cc4:	cf 3f       	cpi	r28, 0xFF	; 255
    1cc6:	8f ef       	ldi	r24, 0xFF	; 255
    1cc8:	d8 07       	cpc	r29, r24
    1cca:	51 f4       	brne	.+20     	; 0x1ce0 <vTaskPlaceOnEventList+0x3c>
    1ccc:	60 91 eb 3c 	lds	r22, 0x3CEB
    1cd0:	70 91 ec 3c 	lds	r23, 0x3CEC
    1cd4:	6e 5f       	subi	r22, 0xFE	; 254
    1cd6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd8:	8a eb       	ldi	r24, 0xBA	; 186
    1cda:	9c e3       	ldi	r25, 0x3C	; 60
    1cdc:	29 d8       	rcall	.-4014   	; 0xd30 <vListInsertEnd>
    1cde:	07 c0       	rjmp	.+14     	; 0x1cee <vTaskPlaceOnEventList+0x4a>
    1ce0:	80 91 b7 3c 	lds	r24, 0x3CB7
    1ce4:	90 91 b8 3c 	lds	r25, 0x3CB8
    1ce8:	8c 0f       	add	r24, r28
    1cea:	9d 1f       	adc	r25, r29
    1cec:	7c db       	rcall	.-2312   	; 0x13e6 <prvAddCurrentTaskToDelayedList>
    1cee:	df 91       	pop	r29
    1cf0:	cf 91       	pop	r28
    1cf2:	08 95       	ret

00001cf4 <vTaskPlaceOnEventListRestricted>:
    1cf4:	cf 93       	push	r28
    1cf6:	df 93       	push	r29
    1cf8:	eb 01       	movw	r28, r22
    1cfa:	60 91 eb 3c 	lds	r22, 0x3CEB
    1cfe:	70 91 ec 3c 	lds	r23, 0x3CEC
    1d02:	64 5f       	subi	r22, 0xF4	; 244
    1d04:	7f 4f       	sbci	r23, 0xFF	; 255
    1d06:	14 d8       	rcall	.-4056   	; 0xd30 <vListInsertEnd>
    1d08:	80 91 eb 3c 	lds	r24, 0x3CEB
    1d0c:	90 91 ec 3c 	lds	r25, 0x3CEC
    1d10:	02 96       	adiw	r24, 0x02	; 2
    1d12:	70 d8       	rcall	.-3872   	; 0xdf4 <vListRemove>
    1d14:	80 91 b7 3c 	lds	r24, 0x3CB7
    1d18:	90 91 b8 3c 	lds	r25, 0x3CB8
    1d1c:	8c 0f       	add	r24, r28
    1d1e:	9d 1f       	adc	r25, r29
    1d20:	62 db       	rcall	.-2364   	; 0x13e6 <prvAddCurrentTaskToDelayedList>
    1d22:	df 91       	pop	r29
    1d24:	cf 91       	pop	r28
    1d26:	08 95       	ret

00001d28 <xTaskRemoveFromEventList>:
    1d28:	0f 93       	push	r16
    1d2a:	1f 93       	push	r17
    1d2c:	cf 93       	push	r28
    1d2e:	df 93       	push	r29
    1d30:	dc 01       	movw	r26, r24
    1d32:	15 96       	adiw	r26, 0x05	; 5
    1d34:	ed 91       	ld	r30, X+
    1d36:	fc 91       	ld	r31, X
    1d38:	16 97       	sbiw	r26, 0x06	; 6
    1d3a:	c6 81       	ldd	r28, Z+6	; 0x06
    1d3c:	d7 81       	ldd	r29, Z+7	; 0x07
    1d3e:	8e 01       	movw	r16, r28
    1d40:	04 5f       	subi	r16, 0xF4	; 244
    1d42:	1f 4f       	sbci	r17, 0xFF	; 255
    1d44:	c8 01       	movw	r24, r16
    1d46:	56 d8       	rcall	.-3924   	; 0xdf4 <vListRemove>
    1d48:	80 91 b3 3c 	lds	r24, 0x3CB3
    1d4c:	81 11       	cpse	r24, r1
    1d4e:	1b c0       	rjmp	.+54     	; 0x1d86 <xTaskRemoveFromEventList+0x5e>
    1d50:	0a 50       	subi	r16, 0x0A	; 10
    1d52:	11 09       	sbc	r17, r1
    1d54:	c8 01       	movw	r24, r16
    1d56:	4e d8       	rcall	.-3940   	; 0xdf4 <vListRemove>
    1d58:	8e 89       	ldd	r24, Y+22	; 0x16
    1d5a:	90 91 b5 3c 	lds	r25, 0x3CB5
    1d5e:	98 17       	cp	r25, r24
    1d60:	10 f4       	brcc	.+4      	; 0x1d66 <xTaskRemoveFromEventList+0x3e>
    1d62:	80 93 b5 3c 	sts	0x3CB5, r24
    1d66:	90 e0       	ldi	r25, 0x00	; 0
    1d68:	9c 01       	movw	r18, r24
    1d6a:	22 0f       	add	r18, r18
    1d6c:	33 1f       	adc	r19, r19
    1d6e:	22 0f       	add	r18, r18
    1d70:	33 1f       	adc	r19, r19
    1d72:	22 0f       	add	r18, r18
    1d74:	33 1f       	adc	r19, r19
    1d76:	82 0f       	add	r24, r18
    1d78:	93 1f       	adc	r25, r19
    1d7a:	b8 01       	movw	r22, r16
    1d7c:	8e 51       	subi	r24, 0x1E	; 30
    1d7e:	93 4c       	sbci	r25, 0xC3	; 195
    1d80:	0e 94 98 06 	call	0xd30	; 0xd30 <vListInsertEnd>
    1d84:	05 c0       	rjmp	.+10     	; 0x1d90 <xTaskRemoveFromEventList+0x68>
    1d86:	b8 01       	movw	r22, r16
    1d88:	83 ec       	ldi	r24, 0xC3	; 195
    1d8a:	9c e3       	ldi	r25, 0x3C	; 60
    1d8c:	0e 94 98 06 	call	0xd30	; 0xd30 <vListInsertEnd>
    1d90:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1d94:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	2e 89       	ldd	r18, Y+22	; 0x16
    1d9c:	96 89       	ldd	r25, Z+22	; 0x16
    1d9e:	29 17       	cp	r18, r25
    1da0:	08 f4       	brcc	.+2      	; 0x1da4 <xTaskRemoveFromEventList+0x7c>
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17
    1daa:	0f 91       	pop	r16
    1dac:	08 95       	ret

00001dae <vTaskSetTimeOutState>:
    1dae:	20 91 b0 3c 	lds	r18, 0x3CB0
    1db2:	fc 01       	movw	r30, r24
    1db4:	20 83       	st	Z, r18
    1db6:	20 91 b7 3c 	lds	r18, 0x3CB7
    1dba:	30 91 b8 3c 	lds	r19, 0x3CB8
    1dbe:	21 83       	std	Z+1, r18	; 0x01
    1dc0:	32 83       	std	Z+2, r19	; 0x02
    1dc2:	08 95       	ret

00001dc4 <xTaskCheckForTimeOut>:
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	0f 92       	push	r0
    1dca:	db 01       	movw	r26, r22
    1dcc:	2d 91       	ld	r18, X+
    1dce:	3c 91       	ld	r19, X
    1dd0:	2f 3f       	cpi	r18, 0xFF	; 255
    1dd2:	bf ef       	ldi	r27, 0xFF	; 255
    1dd4:	3b 07       	cpc	r19, r27
    1dd6:	61 f1       	breq	.+88     	; 0x1e30 <xTaskCheckForTimeOut+0x6c>
    1dd8:	40 91 b0 3c 	lds	r20, 0x3CB0
    1ddc:	fc 01       	movw	r30, r24
    1dde:	50 81       	ld	r21, Z
    1de0:	54 17       	cp	r21, r20
    1de2:	51 f0       	breq	.+20     	; 0x1df8 <xTaskCheckForTimeOut+0x34>
    1de4:	40 91 b7 3c 	lds	r20, 0x3CB7
    1de8:	50 91 b8 3c 	lds	r21, 0x3CB8
    1dec:	01 80       	ldd	r0, Z+1	; 0x01
    1dee:	f2 81       	ldd	r31, Z+2	; 0x02
    1df0:	e0 2d       	mov	r30, r0
    1df2:	4e 17       	cp	r20, r30
    1df4:	5f 07       	cpc	r21, r31
    1df6:	f0 f4       	brcc	.+60     	; 0x1e34 <xTaskCheckForTimeOut+0x70>
    1df8:	e0 91 b7 3c 	lds	r30, 0x3CB7
    1dfc:	f0 91 b8 3c 	lds	r31, 0x3CB8
    1e00:	dc 01       	movw	r26, r24
    1e02:	11 96       	adiw	r26, 0x01	; 1
    1e04:	4d 91       	ld	r20, X+
    1e06:	5c 91       	ld	r21, X
    1e08:	12 97       	sbiw	r26, 0x02	; 2
    1e0a:	e4 1b       	sub	r30, r20
    1e0c:	f5 0b       	sbc	r31, r21
    1e0e:	e2 17       	cp	r30, r18
    1e10:	f3 07       	cpc	r31, r19
    1e12:	90 f4       	brcc	.+36     	; 0x1e38 <xTaskCheckForTimeOut+0x74>
    1e14:	e0 91 b7 3c 	lds	r30, 0x3CB7
    1e18:	f0 91 b8 3c 	lds	r31, 0x3CB8
    1e1c:	4e 1b       	sub	r20, r30
    1e1e:	5f 0b       	sbc	r21, r31
    1e20:	24 0f       	add	r18, r20
    1e22:	35 1f       	adc	r19, r21
    1e24:	fb 01       	movw	r30, r22
    1e26:	20 83       	st	Z, r18
    1e28:	31 83       	std	Z+1, r19	; 0x01
    1e2a:	c1 df       	rcall	.-126    	; 0x1dae <vTaskSetTimeOutState>
    1e2c:	80 e0       	ldi	r24, 0x00	; 0
    1e2e:	05 c0       	rjmp	.+10     	; 0x1e3a <xTaskCheckForTimeOut+0x76>
    1e30:	80 e0       	ldi	r24, 0x00	; 0
    1e32:	03 c0       	rjmp	.+6      	; 0x1e3a <xTaskCheckForTimeOut+0x76>
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	01 c0       	rjmp	.+2      	; 0x1e3a <xTaskCheckForTimeOut+0x76>
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	0f 90       	pop	r0
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	08 95       	ret

00001e40 <vTaskMissedYield>:
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	80 93 b1 3c 	sts	0x3CB1, r24
    1e46:	08 95       	ret

00001e48 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1e48:	80 91 eb 3c 	lds	r24, 0x3CEB
    1e4c:	90 91 ec 3c 	lds	r25, 0x3CEC

		return xReturn;
	}
    1e50:	08 95       	ret

00001e52 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e52:	80 91 b4 3c 	lds	r24, 0x3CB4
    1e56:	88 23       	and	r24, r24
    1e58:	31 f0       	breq	.+12     	; 0x1e66 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e5a:	80 91 b3 3c 	lds	r24, 0x3CB3
    1e5e:	81 11       	cpse	r24, r1
    1e60:	04 c0       	rjmp	.+8      	; 0x1e6a <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e62:	81 e0       	ldi	r24, 0x01	; 1
    1e64:	08 95       	ret
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e66:	80 e0       	ldi	r24, 0x00	; 0
    1e68:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e6a:	82 e0       	ldi	r24, 0x02	; 2
			}
		}

		return xReturn;
	}
    1e6c:	08 95       	ret

00001e6e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1e6e:	0f 93       	push	r16
    1e70:	1f 93       	push	r17
    1e72:	cf 93       	push	r28
    1e74:	df 93       	push	r29
    1e76:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1e78:	8e 89       	ldd	r24, Y+22	; 0x16
    1e7a:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1e7e:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1e82:	96 89       	ldd	r25, Z+22	; 0x16
    1e84:	89 17       	cp	r24, r25
    1e86:	08 f0       	brcs	.+2      	; 0x1e8a <vTaskPriorityInherit+0x1c>
    1e88:	44 c0       	rjmp	.+136    	; 0x1f12 <vTaskPriorityInherit+0xa4>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    1e8a:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1e8e:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1e92:	96 89       	ldd	r25, Z+22	; 0x16
    1e94:	21 e0       	ldi	r18, 0x01	; 1
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	29 1b       	sub	r18, r25
    1e9a:	31 09       	sbc	r19, r1
    1e9c:	2c 87       	std	Y+12, r18	; 0x0c
    1e9e:	3d 87       	std	Y+13, r19	; 0x0d

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1ea0:	90 e0       	ldi	r25, 0x00	; 0
    1ea2:	9c 01       	movw	r18, r24
    1ea4:	22 0f       	add	r18, r18
    1ea6:	33 1f       	adc	r19, r19
    1ea8:	22 0f       	add	r18, r18
    1eaa:	33 1f       	adc	r19, r19
    1eac:	22 0f       	add	r18, r18
    1eae:	33 1f       	adc	r19, r19
    1eb0:	82 0f       	add	r24, r18
    1eb2:	93 1f       	adc	r25, r19
    1eb4:	8e 51       	subi	r24, 0x1E	; 30
    1eb6:	93 4c       	sbci	r25, 0xC3	; 195
    1eb8:	2a 85       	ldd	r18, Y+10	; 0x0a
    1eba:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ebc:	28 17       	cp	r18, r24
    1ebe:	39 07       	cpc	r19, r25
    1ec0:	11 f5       	brne	.+68     	; 0x1f06 <vTaskPriorityInherit+0x98>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    1ec2:	8e 01       	movw	r16, r28
    1ec4:	0e 5f       	subi	r16, 0xFE	; 254
    1ec6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ec8:	c8 01       	movw	r24, r16
    1eca:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1ece:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1ed2:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1ed6:	86 89       	ldd	r24, Z+22	; 0x16
    1ed8:	8e 8b       	std	Y+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    1eda:	90 91 b5 3c 	lds	r25, 0x3CB5
    1ede:	98 17       	cp	r25, r24
    1ee0:	10 f4       	brcc	.+4      	; 0x1ee6 <vTaskPriorityInherit+0x78>
    1ee2:	80 93 b5 3c 	sts	0x3CB5, r24
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	9c 01       	movw	r18, r24
    1eea:	22 0f       	add	r18, r18
    1eec:	33 1f       	adc	r19, r19
    1eee:	22 0f       	add	r18, r18
    1ef0:	33 1f       	adc	r19, r19
    1ef2:	22 0f       	add	r18, r18
    1ef4:	33 1f       	adc	r19, r19
    1ef6:	82 0f       	add	r24, r18
    1ef8:	93 1f       	adc	r25, r19
    1efa:	b8 01       	movw	r22, r16
    1efc:	8e 51       	subi	r24, 0x1E	; 30
    1efe:	93 4c       	sbci	r25, 0xC3	; 195
    1f00:	0e 94 98 06 	call	0xd30	; 0xd30 <vListInsertEnd>
    1f04:	06 c0       	rjmp	.+12     	; 0x1f12 <vTaskPriorityInherit+0xa4>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f06:	e0 91 eb 3c 	lds	r30, 0x3CEB
    1f0a:	f0 91 ec 3c 	lds	r31, 0x3CEC
    1f0e:	86 89       	ldd	r24, Z+22	; 0x16
    1f10:	8e 8b       	std	Y+22, r24	; 0x16
			}
		}
	}
    1f12:	df 91       	pop	r29
    1f14:	cf 91       	pop	r28
    1f16:	1f 91       	pop	r17
    1f18:	0f 91       	pop	r16
    1f1a:	08 95       	ret

00001f1c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1f26:	00 97       	sbiw	r24, 0x00	; 0
    1f28:	39 f1       	breq	.+78     	; 0x1f78 <vTaskPriorityDisinherit+0x5c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1f2a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f2c:	8a a1       	ldd	r24, Y+34	; 0x22
    1f2e:	98 17       	cp	r25, r24
    1f30:	19 f1       	breq	.+70     	; 0x1f78 <vTaskPriorityDisinherit+0x5c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    1f32:	8e 01       	movw	r16, r28
    1f34:	0e 5f       	subi	r16, 0xFE	; 254
    1f36:	1f 4f       	sbci	r17, 0xFF	; 255
    1f38:	c8 01       	movw	r24, r16
    1f3a:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f3e:	8a a1       	ldd	r24, Y+34	; 0x22
    1f40:	8e 8b       	std	Y+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1f42:	21 e0       	ldi	r18, 0x01	; 1
    1f44:	30 e0       	ldi	r19, 0x00	; 0
    1f46:	28 1b       	sub	r18, r24
    1f48:	31 09       	sbc	r19, r1
    1f4a:	2c 87       	std	Y+12, r18	; 0x0c
    1f4c:	3d 87       	std	Y+13, r19	; 0x0d
				prvAddTaskToReadyQueue( pxTCB );
    1f4e:	90 91 b5 3c 	lds	r25, 0x3CB5
    1f52:	98 17       	cp	r25, r24
    1f54:	10 f4       	brcc	.+4      	; 0x1f5a <vTaskPriorityDisinherit+0x3e>
    1f56:	80 93 b5 3c 	sts	0x3CB5, r24
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	9c 01       	movw	r18, r24
    1f5e:	22 0f       	add	r18, r18
    1f60:	33 1f       	adc	r19, r19
    1f62:	22 0f       	add	r18, r18
    1f64:	33 1f       	adc	r19, r19
    1f66:	22 0f       	add	r18, r18
    1f68:	33 1f       	adc	r19, r19
    1f6a:	82 0f       	add	r24, r18
    1f6c:	93 1f       	adc	r25, r19
    1f6e:	b8 01       	movw	r22, r16
    1f70:	8e 51       	subi	r24, 0x1E	; 30
    1f72:	93 4c       	sbci	r25, 0xC3	; 195
    1f74:	0e 94 98 06 	call	0xd30	; 0xd30 <vListInsertEnd>
			}
		}
	}
    1f78:	df 91       	pop	r29
    1f7a:	cf 91       	pop	r28
    1f7c:	1f 91       	pop	r17
    1f7e:	0f 91       	pop	r16
    1f80:	08 95       	ret

00001f82 <prvInsertTimerInActiveList>:
			traceTIMER_CREATE_FAILED();
		}
	}
	
	return ( xTimerHandle ) pxNewTimer;
}
    1f82:	fc 01       	movw	r30, r24
    1f84:	62 83       	std	Z+2, r22	; 0x02
    1f86:	73 83       	std	Z+3, r23	; 0x03
    1f88:	80 87       	std	Z+8, r24	; 0x08
    1f8a:	91 87       	std	Z+9, r25	; 0x09
    1f8c:	46 17       	cp	r20, r22
    1f8e:	57 07       	cpc	r21, r23
    1f90:	90 f0       	brcs	.+36     	; 0x1fb6 <prvInsertTimerInActiveList+0x34>
    1f92:	42 1b       	sub	r20, r18
    1f94:	53 0b       	sbc	r21, r19
    1f96:	84 85       	ldd	r24, Z+12	; 0x0c
    1f98:	95 85       	ldd	r25, Z+13	; 0x0d
    1f9a:	48 17       	cp	r20, r24
    1f9c:	59 07       	cpc	r21, r25
    1f9e:	e0 f4       	brcc	.+56     	; 0x1fd8 <prvInsertTimerInActiveList+0x56>
    1fa0:	bf 01       	movw	r22, r30
    1fa2:	6e 5f       	subi	r22, 0xFE	; 254
    1fa4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fa6:	80 91 f1 3c 	lds	r24, 0x3CF1
    1faa:	90 91 f2 3c 	lds	r25, 0x3CF2
    1fae:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vListInsert>
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
    1fb4:	08 95       	ret
    1fb6:	42 17       	cp	r20, r18
    1fb8:	53 07       	cpc	r21, r19
    1fba:	18 f4       	brcc	.+6      	; 0x1fc2 <prvInsertTimerInActiveList+0x40>
    1fbc:	62 17       	cp	r22, r18
    1fbe:	73 07       	cpc	r23, r19
    1fc0:	68 f4       	brcc	.+26     	; 0x1fdc <prvInsertTimerInActiveList+0x5a>
    1fc2:	bf 01       	movw	r22, r30
    1fc4:	6e 5f       	subi	r22, 0xFE	; 254
    1fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc8:	80 91 f3 3c 	lds	r24, 0x3CF3
    1fcc:	90 91 f4 3c 	lds	r25, 0x3CF4
    1fd0:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vListInsert>
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	08 95       	ret
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	08 95       	ret
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	08 95       	ret

00001fe0 <prvCheckForValidListAndQueue>:
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	f8 94       	cli
    1fe4:	0f 92       	push	r0
    1fe6:	80 91 ef 3c 	lds	r24, 0x3CEF
    1fea:	90 91 f0 3c 	lds	r25, 0x3CF0
    1fee:	89 2b       	or	r24, r25
    1ff0:	e1 f4       	brne	.+56     	; 0x202a <prvCheckForValidListAndQueue+0x4a>
    1ff2:	8e ef       	ldi	r24, 0xFE	; 254
    1ff4:	9c e3       	ldi	r25, 0x3C	; 60
    1ff6:	0e 94 86 06 	call	0xd0c	; 0xd0c <vListInitialise>
    1ffa:	85 ef       	ldi	r24, 0xF5	; 245
    1ffc:	9c e3       	ldi	r25, 0x3C	; 60
    1ffe:	0e 94 86 06 	call	0xd0c	; 0xd0c <vListInitialise>
    2002:	8e ef       	ldi	r24, 0xFE	; 254
    2004:	9c e3       	ldi	r25, 0x3C	; 60
    2006:	80 93 f3 3c 	sts	0x3CF3, r24
    200a:	90 93 f4 3c 	sts	0x3CF4, r25
    200e:	85 ef       	ldi	r24, 0xF5	; 245
    2010:	9c e3       	ldi	r25, 0x3C	; 60
    2012:	80 93 f1 3c 	sts	0x3CF1, r24
    2016:	90 93 f2 3c 	sts	0x3CF2, r25
    201a:	65 e0       	ldi	r22, 0x05	; 5
    201c:	80 e1       	ldi	r24, 0x10	; 16
    201e:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueCreate>
    2022:	80 93 ef 3c 	sts	0x3CEF, r24
    2026:	90 93 f0 3c 	sts	0x3CF0, r25
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	08 95       	ret

00002030 <xTimerCreateTimerTask>:
    2030:	af 92       	push	r10
    2032:	bf 92       	push	r11
    2034:	cf 92       	push	r12
    2036:	df 92       	push	r13
    2038:	ef 92       	push	r14
    203a:	ff 92       	push	r15
    203c:	0f 93       	push	r16
    203e:	d0 df       	rcall	.-96     	; 0x1fe0 <prvCheckForValidListAndQueue>
    2040:	80 91 ef 3c 	lds	r24, 0x3CEF
    2044:	90 91 f0 3c 	lds	r25, 0x3CF0
    2048:	89 2b       	or	r24, r25
    204a:	89 f0       	breq	.+34     	; 0x206e <xTimerCreateTimerTask+0x3e>
    204c:	a1 2c       	mov	r10, r1
    204e:	b1 2c       	mov	r11, r1
    2050:	c1 2c       	mov	r12, r1
    2052:	d1 2c       	mov	r13, r1
    2054:	e1 2c       	mov	r14, r1
    2056:	f1 2c       	mov	r15, r1
    2058:	00 e0       	ldi	r16, 0x00	; 0
    205a:	20 e0       	ldi	r18, 0x00	; 0
    205c:	30 e0       	ldi	r19, 0x00	; 0
    205e:	40 e4       	ldi	r20, 0x40	; 64
    2060:	50 e0       	ldi	r21, 0x00	; 0
    2062:	66 e8       	ldi	r22, 0x86	; 134
    2064:	70 e2       	ldi	r23, 0x20	; 32
    2066:	84 ef       	ldi	r24, 0xF4	; 244
    2068:	90 e1       	ldi	r25, 0x10	; 16
    206a:	8f da       	rcall	.-2786   	; 0x158a <xTaskGenericCreate>
    206c:	01 c0       	rjmp	.+2      	; 0x2070 <xTimerCreateTimerTask+0x40>
    206e:	80 e0       	ldi	r24, 0x00	; 0
    2070:	0f 91       	pop	r16
    2072:	ff 90       	pop	r15
    2074:	ef 90       	pop	r14
    2076:	df 90       	pop	r13
    2078:	cf 90       	pop	r12
    207a:	bf 90       	pop	r11
    207c:	af 90       	pop	r10
    207e:	08 95       	ret

00002080 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    2080:	0f 93       	push	r16
    2082:	1f 93       	push	r17
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	25 97       	sbiw	r28, 0x05	; 5
    208e:	cd bf       	out	0x3d, r28	; 61
    2090:	de bf       	out	0x3e, r29	; 62
    2092:	d9 01       	movw	r26, r18
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2094:	e0 91 ef 3c 	lds	r30, 0x3CEF
    2098:	f0 91 f0 3c 	lds	r31, 0x3CF0
    209c:	30 97       	sbiw	r30, 0x00	; 0
    209e:	59 f1       	breq	.+86     	; 0x20f6 <xTimerGenericCommand+0x76>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    20a0:	69 83       	std	Y+1, r22	; 0x01
		xMessage.xMessageValue = xOptionalValue;
    20a2:	4a 83       	std	Y+2, r20	; 0x02
    20a4:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    20a6:	8c 83       	std	Y+4, r24	; 0x04
    20a8:	9d 83       	std	Y+5, r25	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    20aa:	10 97       	sbiw	r26, 0x00	; 0
    20ac:	e1 f4       	brne	.+56     	; 0x20e6 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    20ae:	d1 de       	rcall	.-606    	; 0x1e52 <xTaskGetSchedulerState>
    20b0:	81 30       	cpi	r24, 0x01	; 1
    20b2:	61 f4       	brne	.+24     	; 0x20cc <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    20b6:	a8 01       	movw	r20, r16
    20b8:	be 01       	movw	r22, r28
    20ba:	6f 5f       	subi	r22, 0xFF	; 255
    20bc:	7f 4f       	sbci	r23, 0xFF	; 255
    20be:	80 91 ef 3c 	lds	r24, 0x3CEF
    20c2:	90 91 f0 3c 	lds	r25, 0x3CF0
    20c6:	0e 94 16 08 	call	0x102c	; 0x102c <xQueueGenericSend>
    20ca:	16 c0       	rjmp	.+44     	; 0x20f8 <xTimerGenericCommand+0x78>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    20cc:	20 e0       	ldi	r18, 0x00	; 0
    20ce:	40 e0       	ldi	r20, 0x00	; 0
    20d0:	50 e0       	ldi	r21, 0x00	; 0
    20d2:	be 01       	movw	r22, r28
    20d4:	6f 5f       	subi	r22, 0xFF	; 255
    20d6:	7f 4f       	sbci	r23, 0xFF	; 255
    20d8:	80 91 ef 3c 	lds	r24, 0x3CEF
    20dc:	90 91 f0 3c 	lds	r25, 0x3CF0
    20e0:	0e 94 16 08 	call	0x102c	; 0x102c <xQueueGenericSend>
    20e4:	09 c0       	rjmp	.+18     	; 0x20f8 <xTimerGenericCommand+0x78>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    20e6:	20 e0       	ldi	r18, 0x00	; 0
    20e8:	ad 01       	movw	r20, r26
    20ea:	be 01       	movw	r22, r28
    20ec:	6f 5f       	subi	r22, 0xFF	; 255
    20ee:	7f 4f       	sbci	r23, 0xFF	; 255
    20f0:	cf 01       	movw	r24, r30
    20f2:	4c d8       	rcall	.-3944   	; 0x118c <xQueueGenericSendFromISR>
    20f4:	01 c0       	rjmp	.+2      	; 0x20f8 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
    20f6:	80 e0       	ldi	r24, 0x00	; 0
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
}
    20f8:	25 96       	adiw	r28, 0x05	; 5
    20fa:	cd bf       	out	0x3d, r28	; 61
    20fc:	de bf       	out	0x3e, r29	; 62
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	0f 91       	pop	r16
    2106:	08 95       	ret

00002108 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    2108:	af 92       	push	r10
    210a:	bf 92       	push	r11
    210c:	cf 92       	push	r12
    210e:	df 92       	push	r13
    2110:	ef 92       	push	r14
    2112:	ff 92       	push	r15
    2114:	0f 93       	push	r16
    2116:	1f 93       	push	r17
    2118:	cf 93       	push	r28
    211a:	df 93       	push	r29
    211c:	5c 01       	movw	r10, r24
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    211e:	4e db       	rcall	.-2404   	; 0x17bc <xTaskGetTickCount>
    2120:	6c 01       	movw	r12, r24
	
	if( xTimeNow < xLastTime )
    2122:	80 91 ed 3c 	lds	r24, 0x3CED
    2126:	90 91 ee 3c 	lds	r25, 0x3CEE
    212a:	c8 16       	cp	r12, r24
    212c:	d9 06       	cpc	r13, r25
    212e:	08 f0       	brcs	.+2      	; 0x2132 <prvSampleTimeNow+0x2a>
    2130:	49 c0       	rjmp	.+146    	; 0x21c4 <prvSampleTimeNow+0xbc>
    2132:	31 c0       	rjmp	.+98     	; 0x2196 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2134:	a5 81       	ldd	r26, Z+5	; 0x05
    2136:	b6 81       	ldd	r27, Z+6	; 0x06
    2138:	ed 90       	ld	r14, X+
    213a:	fc 90       	ld	r15, X

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    213c:	05 80       	ldd	r0, Z+5	; 0x05
    213e:	f6 81       	ldd	r31, Z+6	; 0x06
    2140:	e0 2d       	mov	r30, r0
    2142:	c6 81       	ldd	r28, Z+6	; 0x06
    2144:	d7 81       	ldd	r29, Z+7	; 0x07
		vListRemove( &( pxTimer->xTimerListItem ) );
    2146:	8e 01       	movw	r16, r28
    2148:	0e 5f       	subi	r16, 0xFE	; 254
    214a:	1f 4f       	sbci	r17, 0xFF	; 255
    214c:	c8 01       	movw	r24, r16
    214e:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    2152:	e9 89       	ldd	r30, Y+17	; 0x11
    2154:	fa 89       	ldd	r31, Y+18	; 0x12
    2156:	ce 01       	movw	r24, r28
    2158:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    215a:	8e 85       	ldd	r24, Y+14	; 0x0e
    215c:	81 30       	cpi	r24, 0x01	; 1
    215e:	d9 f4       	brne	.+54     	; 0x2196 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2160:	8c 85       	ldd	r24, Y+12	; 0x0c
    2162:	9d 85       	ldd	r25, Y+13	; 0x0d
    2164:	8e 0d       	add	r24, r14
    2166:	9f 1d       	adc	r25, r15
			if( xReloadTime > xNextExpireTime )
    2168:	e8 16       	cp	r14, r24
    216a:	f9 06       	cpc	r15, r25
    216c:	60 f4       	brcc	.+24     	; 0x2186 <prvSampleTimeNow+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    216e:	8a 83       	std	Y+2, r24	; 0x02
    2170:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2172:	c8 87       	std	Y+8, r28	; 0x08
    2174:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2176:	b8 01       	movw	r22, r16
    2178:	80 91 f3 3c 	lds	r24, 0x3CF3
    217c:	90 91 f4 3c 	lds	r25, 0x3CF4
    2180:	0e 94 bf 06 	call	0xd7e	; 0xd7e <vListInsert>
    2184:	08 c0       	rjmp	.+16     	; 0x2196 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    2186:	00 e0       	ldi	r16, 0x00	; 0
    2188:	10 e0       	ldi	r17, 0x00	; 0
    218a:	20 e0       	ldi	r18, 0x00	; 0
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	a7 01       	movw	r20, r14
    2190:	60 e0       	ldi	r22, 0x00	; 0
    2192:	ce 01       	movw	r24, r28
    2194:	75 df       	rcall	.-278    	; 0x2080 <xTimerGenericCommand>
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2196:	e0 91 f3 3c 	lds	r30, 0x3CF3
    219a:	f0 91 f4 3c 	lds	r31, 0x3CF4
    219e:	80 81       	ld	r24, Z
    21a0:	81 11       	cpse	r24, r1
    21a2:	c8 cf       	rjmp	.-112    	; 0x2134 <prvSampleTimeNow+0x2c>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    21a4:	80 91 f1 3c 	lds	r24, 0x3CF1
    21a8:	90 91 f2 3c 	lds	r25, 0x3CF2
    21ac:	80 93 f3 3c 	sts	0x3CF3, r24
    21b0:	90 93 f4 3c 	sts	0x3CF4, r25
	pxOverflowTimerList = pxTemp;
    21b4:	e0 93 f1 3c 	sts	0x3CF1, r30
    21b8:	f0 93 f2 3c 	sts	0x3CF2, r31
	xTimeNow = xTaskGetTickCount();
	
	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
    21bc:	81 e0       	ldi	r24, 0x01	; 1
    21be:	f5 01       	movw	r30, r10
    21c0:	80 83       	st	Z, r24
    21c2:	02 c0       	rjmp	.+4      	; 0x21c8 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    21c4:	f5 01       	movw	r30, r10
    21c6:	10 82       	st	Z, r1
	}
	
	xLastTime = xTimeNow;
    21c8:	c0 92 ed 3c 	sts	0x3CED, r12
    21cc:	d0 92 ee 3c 	sts	0x3CEE, r13
	
	return xTimeNow;
}
    21d0:	c6 01       	movw	r24, r12
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	1f 91       	pop	r17
    21d8:	0f 91       	pop	r16
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	df 90       	pop	r13
    21e0:	cf 90       	pop	r12
    21e2:	bf 90       	pop	r11
    21e4:	af 90       	pop	r10
    21e6:	08 95       	ret

000021e8 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
    21ec:	00 d0       	rcall	.+0      	; 0x21ee <prvTimerTask+0x6>
    21ee:	00 d0       	rcall	.+0      	; 0x21f0 <prvTimerTask+0x8>
    21f0:	cd b7       	in	r28, 0x3d	; 61
    21f2:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    21f4:	ce 01       	movw	r24, r28
    21f6:	01 96       	adiw	r24, 0x01	; 1
    21f8:	5c 01       	movw	r10, r24

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    21fa:	88 2e       	mov	r8, r24
    21fc:	9b 2c       	mov	r9, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    21fe:	e0 91 f3 3c 	lds	r30, 0x3CF3
    2202:	f0 91 f4 3c 	lds	r31, 0x3CF4
    2206:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    2208:	88 23       	and	r24, r24
    220a:	09 f4       	brne	.+2      	; 0x220e <prvTimerTask+0x26>
    220c:	b1 c0       	rjmp	.+354    	; 0x2370 <prvTimerTask+0x188>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    220e:	05 80       	ldd	r0, Z+5	; 0x05
    2210:	f6 81       	ldd	r31, Z+6	; 0x06
    2212:	e0 2d       	mov	r30, r0
    2214:	e0 80       	ld	r14, Z
    2216:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    2218:	cb da       	rcall	.-2666   	; 0x17b0 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    221a:	c5 01       	movw	r24, r10
    221c:	75 df       	rcall	.-278    	; 0x2108 <prvSampleTimeNow>
    221e:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	81 11       	cpse	r24, r1
    2224:	43 c0       	rjmp	.+134    	; 0x22ac <prvTimerTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2226:	0e 15       	cp	r16, r14
    2228:	1f 05       	cpc	r17, r15
    222a:	90 f1       	brcs	.+100    	; 0x2290 <prvTimerTask+0xa8>
			{
				xTaskResumeAll();
    222c:	95 db       	rcall	.-2262   	; 0x1958 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    222e:	e0 91 f3 3c 	lds	r30, 0x3CF3
    2232:	f0 91 f4 3c 	lds	r31, 0x3CF4
    2236:	05 80       	ldd	r0, Z+5	; 0x05
    2238:	f6 81       	ldd	r31, Z+6	; 0x06
    223a:	e0 2d       	mov	r30, r0
    223c:	c6 80       	ldd	r12, Z+6	; 0x06
    223e:	d7 80       	ldd	r13, Z+7	; 0x07
	vListRemove( &( pxTimer->xTimerListItem ) );
    2240:	c6 01       	movw	r24, r12
    2242:	02 96       	adiw	r24, 0x02	; 2
    2244:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    2248:	d6 01       	movw	r26, r12
    224a:	1e 96       	adiw	r26, 0x0e	; 14
    224c:	8c 91       	ld	r24, X
    224e:	1e 97       	sbiw	r26, 0x0e	; 14
    2250:	81 30       	cpi	r24, 0x01	; 1
    2252:	a1 f4       	brne	.+40     	; 0x227c <prvTimerTask+0x94>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2254:	1c 96       	adiw	r26, 0x0c	; 12
    2256:	6d 91       	ld	r22, X+
    2258:	7c 91       	ld	r23, X
    225a:	1d 97       	sbiw	r26, 0x0d	; 13
    225c:	6e 0d       	add	r22, r14
    225e:	7f 1d       	adc	r23, r15
    2260:	97 01       	movw	r18, r14
    2262:	a8 01       	movw	r20, r16
    2264:	c6 01       	movw	r24, r12
    2266:	8d de       	rcall	.-742    	; 0x1f82 <prvInsertTimerInActiveList>
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	41 f4       	brne	.+16     	; 0x227c <prvTimerTask+0x94>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    226c:	00 e0       	ldi	r16, 0x00	; 0
    226e:	10 e0       	ldi	r17, 0x00	; 0
    2270:	20 e0       	ldi	r18, 0x00	; 0
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	a7 01       	movw	r20, r14
    2276:	60 e0       	ldi	r22, 0x00	; 0
    2278:	c6 01       	movw	r24, r12
    227a:	02 df       	rcall	.-508    	; 0x2080 <xTimerGenericCommand>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    227c:	d6 01       	movw	r26, r12
    227e:	51 96       	adiw	r26, 0x11	; 17
    2280:	ed 91       	ld	r30, X+
    2282:	fc 91       	ld	r31, X
    2284:	52 97       	sbiw	r26, 0x12	; 18
    2286:	c6 01       	movw	r24, r12
    2288:	19 95       	eicall
    228a:	11 c0       	rjmp	.+34     	; 0x22ae <prvTimerTask+0xc6>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    228c:	e1 2c       	mov	r14, r1
    228e:	f1 2c       	mov	r15, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    2290:	b7 01       	movw	r22, r14
    2292:	60 1b       	sub	r22, r16
    2294:	71 0b       	sbc	r23, r17
    2296:	80 91 ef 3c 	lds	r24, 0x3CEF
    229a:	90 91 f0 3c 	lds	r25, 0x3CF0
    229e:	81 d8       	rcall	.-3838   	; 0x13a2 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    22a0:	5b db       	rcall	.-2378   	; 0x1958 <xTaskResumeAll>
    22a2:	81 11       	cpse	r24, r1
    22a4:	04 c0       	rjmp	.+8      	; 0x22ae <prvTimerTask+0xc6>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    22a6:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vPortYield>
    22aa:	01 c0       	rjmp	.+2      	; 0x22ae <prvTimerTask+0xc6>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    22ac:	55 db       	rcall	.-2390   	; 0x1958 <xTaskResumeAll>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    22ae:	ce 01       	movw	r24, r28
    22b0:	06 96       	adiw	r24, 0x06	; 6
    22b2:	2a df       	rcall	.-428    	; 0x2108 <prvSampleTimeNow>
    22b4:	6c 01       	movw	r12, r24
    22b6:	4e c0       	rjmp	.+156    	; 0x2354 <prvTimerTask+0x16c>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    22b8:	ec 80       	ldd	r14, Y+4	; 0x04
    22ba:	fd 80       	ldd	r15, Y+5	; 0x05

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    22bc:	e1 14       	cp	r14, r1
    22be:	f1 04       	cpc	r15, r1
    22c0:	59 f0       	breq	.+22     	; 0x22d8 <prvTimerTask+0xf0>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    22c2:	d7 01       	movw	r26, r14
    22c4:	1a 96       	adiw	r26, 0x0a	; 10
    22c6:	ed 91       	ld	r30, X+
    22c8:	fc 91       	ld	r31, X
    22ca:	1b 97       	sbiw	r26, 0x0b	; 11
    22cc:	ef 2b       	or	r30, r31
    22ce:	21 f0       	breq	.+8      	; 0x22d8 <prvTimerTask+0xf0>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    22d0:	c7 01       	movw	r24, r14
    22d2:	02 96       	adiw	r24, 0x02	; 2
    22d4:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
    22d8:	89 81       	ldd	r24, Y+1	; 0x01
    22da:	82 30       	cpi	r24, 0x02	; 2
    22dc:	49 f1       	breq	.+82     	; 0x2330 <prvTimerTask+0x148>
    22de:	83 30       	cpi	r24, 0x03	; 3
    22e0:	b1 f1       	breq	.+108    	; 0x234e <prvTimerTask+0x166>
    22e2:	81 11       	cpse	r24, r1
    22e4:	37 c0       	rjmp	.+110    	; 0x2354 <prvTimerTask+0x16c>
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    22e6:	2a 81       	ldd	r18, Y+2	; 0x02
    22e8:	3b 81       	ldd	r19, Y+3	; 0x03
    22ea:	f7 01       	movw	r30, r14
    22ec:	64 85       	ldd	r22, Z+12	; 0x0c
    22ee:	75 85       	ldd	r23, Z+13	; 0x0d
    22f0:	62 0f       	add	r22, r18
    22f2:	73 1f       	adc	r23, r19
    22f4:	a6 01       	movw	r20, r12
    22f6:	c7 01       	movw	r24, r14
    22f8:	44 de       	rcall	.-888    	; 0x1f82 <prvInsertTimerInActiveList>
    22fa:	81 30       	cpi	r24, 0x01	; 1
    22fc:	59 f5       	brne	.+86     	; 0x2354 <prvTimerTask+0x16c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    22fe:	d7 01       	movw	r26, r14
    2300:	51 96       	adiw	r26, 0x11	; 17
    2302:	ed 91       	ld	r30, X+
    2304:	fc 91       	ld	r31, X
    2306:	52 97       	sbiw	r26, 0x12	; 18
    2308:	c7 01       	movw	r24, r14
    230a:	19 95       	eicall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    230c:	f7 01       	movw	r30, r14
    230e:	86 85       	ldd	r24, Z+14	; 0x0e
    2310:	81 30       	cpi	r24, 0x01	; 1
    2312:	01 f5       	brne	.+64     	; 0x2354 <prvTimerTask+0x16c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2314:	44 85       	ldd	r20, Z+12	; 0x0c
    2316:	55 85       	ldd	r21, Z+13	; 0x0d
    2318:	8a 81       	ldd	r24, Y+2	; 0x02
    231a:	9b 81       	ldd	r25, Y+3	; 0x03
    231c:	48 0f       	add	r20, r24
    231e:	59 1f       	adc	r21, r25
    2320:	00 e0       	ldi	r16, 0x00	; 0
    2322:	10 e0       	ldi	r17, 0x00	; 0
    2324:	20 e0       	ldi	r18, 0x00	; 0
    2326:	30 e0       	ldi	r19, 0x00	; 0
    2328:	60 e0       	ldi	r22, 0x00	; 0
    232a:	c7 01       	movw	r24, r14
    232c:	a9 de       	rcall	.-686    	; 0x2080 <xTimerGenericCommand>
    232e:	12 c0       	rjmp	.+36     	; 0x2354 <prvTimerTask+0x16c>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    2330:	2a 81       	ldd	r18, Y+2	; 0x02
    2332:	3b 81       	ldd	r19, Y+3	; 0x03
    2334:	d7 01       	movw	r26, r14
    2336:	1c 96       	adiw	r26, 0x0c	; 12
    2338:	2d 93       	st	X+, r18
    233a:	3c 93       	st	X, r19
    233c:	1d 97       	sbiw	r26, 0x0d	; 13
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    233e:	b6 01       	movw	r22, r12
    2340:	62 0f       	add	r22, r18
    2342:	73 1f       	adc	r23, r19
    2344:	96 01       	movw	r18, r12
    2346:	a6 01       	movw	r20, r12
    2348:	c7 01       	movw	r24, r14
    234a:	1b de       	rcall	.-970    	; 0x1f82 <prvInsertTimerInActiveList>
    234c:	03 c0       	rjmp	.+6      	; 0x2354 <prvTimerTask+0x16c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    234e:	c7 01       	movw	r24, r14
    2350:	0e 94 1b 05 	call	0xa36	; 0xa36 <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    2354:	20 e0       	ldi	r18, 0x00	; 0
    2356:	40 e0       	ldi	r20, 0x00	; 0
    2358:	50 e0       	ldi	r21, 0x00	; 0
    235a:	68 2d       	mov	r22, r8
    235c:	79 2d       	mov	r23, r9
    235e:	80 91 ef 3c 	lds	r24, 0x3CEF
    2362:	90 91 f0 3c 	lds	r25, 0x3CF0
    2366:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xQueueGenericReceive>
    236a:	81 11       	cpse	r24, r1
    236c:	a5 cf       	rjmp	.-182    	; 0x22b8 <prvTimerTask+0xd0>
    236e:	47 cf       	rjmp	.-370    	; 0x21fe <prvTimerTask+0x16>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    2370:	1f da       	rcall	.-3010   	; 0x17b0 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2372:	c5 01       	movw	r24, r10
    2374:	c9 de       	rcall	.-622    	; 0x2108 <prvSampleTimeNow>
    2376:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	88 23       	and	r24, r24
    237c:	09 f4       	brne	.+2      	; 0x2380 <prvTimerTask+0x198>
    237e:	86 cf       	rjmp	.-244    	; 0x228c <prvTimerTask+0xa4>
    2380:	95 cf       	rjmp	.-214    	; 0x22ac <prvTimerTask+0xc4>

00002382 <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    2382:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <pvPortMalloc>
}
    2386:	08 95       	ret

00002388 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    2388:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <vPortFree>
    238c:	08 95       	ret

0000238e <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    238e:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <xQueueCreate>
    2392:	08 95       	ret

00002394 <csp_queue_enqueue>:
    2394:	fb 01       	movw	r30, r22
    2396:	ba 01       	movw	r22, r20
    2398:	a9 01       	movw	r20, r18
    239a:	20 e0       	ldi	r18, 0x00	; 0
    239c:	bf 01       	movw	r22, r30
    239e:	0e 94 16 08 	call	0x102c	; 0x102c <xQueueGenericSend>
    23a2:	99 27       	eor	r25, r25
    23a4:	87 fd       	sbrc	r24, 7
    23a6:	90 95       	com	r25
    23a8:	08 95       	ret

000023aa <csp_queue_enqueue_isr>:
    23aa:	20 e0       	ldi	r18, 0x00	; 0
    23ac:	0e 94 c6 08 	call	0x118c	; 0x118c <xQueueGenericSendFromISR>
    23b0:	99 27       	eor	r25, r25
    23b2:	87 fd       	sbrc	r24, 7
    23b4:	90 95       	com	r25
    23b6:	08 95       	ret

000023b8 <csp_queue_dequeue>:
    23b8:	fb 01       	movw	r30, r22
    23ba:	ba 01       	movw	r22, r20
    23bc:	a9 01       	movw	r20, r18
    23be:	20 e0       	ldi	r18, 0x00	; 0
    23c0:	bf 01       	movw	r22, r30
    23c2:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xQueueGenericReceive>
    23c6:	99 27       	eor	r25, r25
    23c8:	87 fd       	sbrc	r24, 7
    23ca:	90 95       	com	r25
    23cc:	08 95       	ret

000023ce <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    23ce:	0e 94 c9 09 	call	0x1392	; 0x1392 <uxQueueMessagesWaiting>
}
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	08 95       	ret

000023d6 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    23d6:	cf 93       	push	r28
    23d8:	df 93       	push	r29
    23da:	ec 01       	movw	r28, r24
    23dc:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueCreateMutex>
    23e0:	9c 01       	movw	r18, r24
    23e2:	88 83       	st	Y, r24
    23e4:	99 83       	std	Y+1, r25	; 0x01
    23e6:	81 e0       	ldi	r24, 0x01	; 1
    23e8:	90 e0       	ldi	r25, 0x00	; 0
    23ea:	23 2b       	or	r18, r19
    23ec:	11 f4       	brne	.+4      	; 0x23f2 <csp_mutex_create+0x1c>
    23ee:	80 e0       	ldi	r24, 0x00	; 0
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	df 91       	pop	r29
    23f4:	cf 91       	pop	r28
    23f6:	08 95       	ret

000023f8 <csp_bin_sem_create>:
    23f8:	cf 93       	push	r28
    23fa:	df 93       	push	r29
    23fc:	ec 01       	movw	r28, r24
    23fe:	60 e0       	ldi	r22, 0x00	; 0
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueCreate>
    2406:	88 83       	st	Y, r24
    2408:	99 83       	std	Y+1, r25	; 0x01
    240a:	00 97       	sbiw	r24, 0x00	; 0
    240c:	39 f0       	breq	.+14     	; 0x241c <csp_bin_sem_create+0x24>
    240e:	20 e0       	ldi	r18, 0x00	; 0
    2410:	40 e0       	ldi	r20, 0x00	; 0
    2412:	50 e0       	ldi	r21, 0x00	; 0
    2414:	60 e0       	ldi	r22, 0x00	; 0
    2416:	70 e0       	ldi	r23, 0x00	; 0
    2418:	0e 94 16 08 	call	0x102c	; 0x102c <xQueueGenericSend>
    241c:	81 e0       	ldi	r24, 0x01	; 1
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	df 91       	pop	r29
    2422:	cf 91       	pop	r28
    2424:	08 95       	ret

00002426 <csp_bin_sem_wait>:
    2426:	20 e0       	ldi	r18, 0x00	; 0
    2428:	60 e0       	ldi	r22, 0x00	; 0
    242a:	70 e0       	ldi	r23, 0x00	; 0
    242c:	fc 01       	movw	r30, r24
    242e:	80 81       	ld	r24, Z
    2430:	91 81       	ldd	r25, Z+1	; 0x01
    2432:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xQueueGenericReceive>
    2436:	21 e0       	ldi	r18, 0x01	; 1
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	81 30       	cpi	r24, 0x01	; 1
    243c:	11 f0       	breq	.+4      	; 0x2442 <csp_bin_sem_wait+0x1c>
    243e:	20 e0       	ldi	r18, 0x00	; 0
    2440:	30 e0       	ldi	r19, 0x00	; 0
    2442:	c9 01       	movw	r24, r18
    2444:	08 95       	ret

00002446 <csp_bin_sem_post>:
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
	csp_log_lock("Post: %p\r\n", sem);
	if (xSemaphoreGive(*sem) == pdPASS) {
    2446:	20 e0       	ldi	r18, 0x00	; 0
    2448:	40 e0       	ldi	r20, 0x00	; 0
    244a:	50 e0       	ldi	r21, 0x00	; 0
    244c:	60 e0       	ldi	r22, 0x00	; 0
    244e:	70 e0       	ldi	r23, 0x00	; 0
    2450:	fc 01       	movw	r30, r24
    2452:	80 81       	ld	r24, Z
    2454:	91 81       	ldd	r25, Z+1	; 0x01
    2456:	0e 94 16 08 	call	0x102c	; 0x102c <xQueueGenericSend>
    245a:	21 e0       	ldi	r18, 0x01	; 1
    245c:	30 e0       	ldi	r19, 0x00	; 0
    245e:	81 30       	cpi	r24, 0x01	; 1
    2460:	11 f0       	breq	.+4      	; 0x2466 <csp_bin_sem_post+0x20>
    2462:	20 e0       	ldi	r18, 0x00	; 0
    2464:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    2466:	c9 01       	movw	r24, r18
    2468:	08 95       	ret

0000246a <csp_sys_tasklist>:

#include <csp/arch/csp_system.h>

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed char *) out);
    246a:	19 db       	rcall	.-2510   	; 0x1a9e <vTaskList>
#else
	vTaskList(out);
#endif
	return CSP_ERR_NONE;
}
    246c:	80 e0       	ldi	r24, 0x00	; 0
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	08 95       	ret

00002472 <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    2472:	ae d9       	rcall	.-3236   	; 0x17d0 <uxTaskGetNumberOfTasks>
}
    2474:	28 e2       	ldi	r18, 0x28	; 40
    2476:	82 9f       	mul	r24, r18
    2478:	c0 01       	movw	r24, r0
    247a:	11 24       	eor	r1, r1
    247c:	08 95       	ret

0000247e <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    247e:	4f 92       	push	r4
    2480:	5f 92       	push	r5
    2482:	6f 92       	push	r6
    2484:	7f 92       	push	r7
    2486:	8f 92       	push	r8
    2488:	9f 92       	push	r9
    248a:	af 92       	push	r10
    248c:	bf 92       	push	r11
    248e:	cf 92       	push	r12
    2490:	df 92       	push	r13
    2492:	ef 92       	push	r14
    2494:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    2496:	0f 2e       	mov	r0, r31
    2498:	f0 e1       	ldi	r31, 0x10	; 16
    249a:	cf 2e       	mov	r12, r31
    249c:	f7 e2       	ldi	r31, 0x27	; 39
    249e:	df 2e       	mov	r13, r31
    24a0:	e1 2c       	mov	r14, r1
    24a2:	f1 2c       	mov	r15, r1
    24a4:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    24a6:	44 24       	eor	r4, r4
    24a8:	4a 94       	dec	r4
    24aa:	54 2c       	mov	r5, r4
    24ac:	32 01       	movw	r6, r4
    24ae:	81 2c       	mov	r8, r1
    24b0:	91 2c       	mov	r9, r1
    24b2:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    24b4:	c4 01       	movw	r24, r8
    24b6:	8c 0d       	add	r24, r12
    24b8:	9d 1d       	adc	r25, r13
    24ba:	0e 94 f7 04 	call	0x9ee	; 0x9ee <pvPortMalloc>
		if (pmem == NULL) {
    24be:	00 97       	sbiw	r24, 0x00	; 0
    24c0:	59 f4       	brne	.+22     	; 0x24d8 <csp_sys_memfree+0x5a>
			max = size + total;
    24c2:	26 01       	movw	r4, r12
    24c4:	37 01       	movw	r6, r14
    24c6:	48 0c       	add	r4, r8
    24c8:	59 1c       	adc	r5, r9
    24ca:	6a 1c       	adc	r6, r10
    24cc:	7b 1c       	adc	r7, r11
			size = size / 2;
    24ce:	f6 94       	lsr	r15
    24d0:	e7 94       	ror	r14
    24d2:	d7 94       	ror	r13
    24d4:	c7 94       	ror	r12
    24d6:	15 c0       	rjmp	.+42     	; 0x2502 <csp_sys_memfree+0x84>
		} else {
			total += size;
    24d8:	8c 0c       	add	r8, r12
    24da:	9d 1c       	adc	r9, r13
    24dc:	ae 1c       	adc	r10, r14
    24de:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    24e0:	b5 01       	movw	r22, r10
    24e2:	a4 01       	movw	r20, r8
    24e4:	4c 0d       	add	r20, r12
    24e6:	5d 1d       	adc	r21, r13
    24e8:	6e 1d       	adc	r22, r14
    24ea:	7f 1d       	adc	r23, r15
    24ec:	44 15       	cp	r20, r4
    24ee:	55 05       	cpc	r21, r5
    24f0:	66 05       	cpc	r22, r6
    24f2:	77 05       	cpc	r23, r7
    24f4:	20 f0       	brcs	.+8      	; 0x24fe <csp_sys_memfree+0x80>
				size = size / 2;
    24f6:	f6 94       	lsr	r15
    24f8:	e7 94       	ror	r14
    24fa:	d7 94       	ror	r13
    24fc:	c7 94       	ror	r12
			vPortFree(pmem);
    24fe:	0e 94 1b 05 	call	0xa36	; 0xa36 <vPortFree>
		}
		if (size < 32) break;
    2502:	80 e2       	ldi	r24, 0x20	; 32
    2504:	c8 16       	cp	r12, r24
    2506:	d1 04       	cpc	r13, r1
    2508:	e1 04       	cpc	r14, r1
    250a:	f1 04       	cpc	r15, r1
    250c:	98 f6       	brcc	.-90     	; 0x24b4 <csp_sys_memfree+0x36>
	}

	return total;
}
    250e:	c5 01       	movw	r24, r10
    2510:	b4 01       	movw	r22, r8
    2512:	ff 90       	pop	r15
    2514:	ef 90       	pop	r14
    2516:	df 90       	pop	r13
    2518:	cf 90       	pop	r12
    251a:	bf 90       	pop	r11
    251c:	af 90       	pop	r10
    251e:	9f 90       	pop	r9
    2520:	8f 90       	pop	r8
    2522:	7f 90       	pop	r7
    2524:	6f 90       	pop	r6
    2526:	5f 90       	pop	r5
    2528:	4f 90       	pop	r4
    252a:	08 95       	ret

0000252c <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    252c:	80 e0       	ldi	r24, 0x00	; 0
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	89 2b       	or	r24, r25
    2532:	21 f0       	breq	.+8      	; 0x253c <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    253c:	80 e0       	ldi	r24, 0x00	; 0
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	89 2b       	or	r24, r25
    2542:	19 f0       	breq	.+6      	; 0x254a <csp_sys_reboot+0x1e>
		cpu_reset();
    2544:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    2548:	ff cf       	rjmp	.-2      	; 0x2548 <csp_sys_reboot+0x1c>
	}
	
	csp_log_error("Failed to reboot\r\n");

	return CSP_ERR_INVAL;
}
    254a:	8e ef       	ldi	r24, 0xFE	; 254
    254c:	9f ef       	ldi	r25, 0xFF	; 255
    254e:	08 95       	ret

00002550 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const signed char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    2550:	af 92       	push	r10
    2552:	bf 92       	push	r11
    2554:	cf 92       	push	r12
    2556:	df 92       	push	r13
    2558:	ef 92       	push	r14
    255a:	ff 92       	push	r15
    255c:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, (char *) thread_name, stack_depth, parameters, priority, handle);
#else
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
    255e:	a1 2c       	mov	r10, r1
    2560:	b1 2c       	mov	r11, r1
    2562:	c1 2c       	mov	r12, r1
    2564:	d1 2c       	mov	r13, r1
    2566:	11 d8       	rcall	.-4062   	; 0x158a <xTaskGenericCreate>
#endif
	if (ret != pdTRUE)
    2568:	21 e0       	ldi	r18, 0x01	; 1
    256a:	30 e0       	ldi	r19, 0x00	; 0
    256c:	81 30       	cpi	r24, 0x01	; 1
    256e:	11 f4       	brne	.+4      	; 0x2574 <csp_thread_create+0x24>
    2570:	20 e0       	ldi	r18, 0x00	; 0
    2572:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    2574:	88 27       	eor	r24, r24
    2576:	99 27       	eor	r25, r25
    2578:	82 1b       	sub	r24, r18
    257a:	93 0b       	sbc	r25, r19
    257c:	0f 91       	pop	r16
    257e:	ff 90       	pop	r15
    2580:	ef 90       	pop	r14
    2582:	df 90       	pop	r13
    2584:	cf 90       	pop	r12
    2586:	bf 90       	pop	r11
    2588:	af 90       	pop	r10
    258a:	08 95       	ret

0000258c <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    258c:	17 d9       	rcall	.-3538   	; 0x17bc <xTaskGetTickCount>
    258e:	bc 01       	movw	r22, r24
    2590:	80 e0       	ldi	r24, 0x00	; 0
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	08 95       	ret

00002596 <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    2596:	12 d9       	rcall	.-3548   	; 0x17bc <xTaskGetTickCount>
    2598:	9c 01       	movw	r18, r24
    259a:	36 95       	lsr	r19
    259c:	27 95       	ror	r18
    259e:	36 95       	lsr	r19
    25a0:	27 95       	ror	r18
    25a2:	36 95       	lsr	r19
    25a4:	27 95       	ror	r18
    25a6:	a5 ec       	ldi	r26, 0xC5	; 197
    25a8:	b0 e2       	ldi	r27, 0x20	; 32
    25aa:	0e 94 ec 2b 	call	0x57d8	; 0x57d8 <__umulhisi3>
    25ae:	92 95       	swap	r25
    25b0:	82 95       	swap	r24
    25b2:	8f 70       	andi	r24, 0x0F	; 15
    25b4:	89 27       	eor	r24, r25
    25b6:	9f 70       	andi	r25, 0x0F	; 15
    25b8:	89 27       	eor	r24, r25
    25ba:	bc 01       	movw	r22, r24
    25bc:	80 e0       	ldi	r24, 0x00	; 0
    25be:	90 e0       	ldi	r25, 0x00	; 0
}
    25c0:	08 95       	ret

000025c2 <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    25c2:	cf 92       	push	r12
    25c4:	df 92       	push	r13
    25c6:	ef 92       	push	r14
    25c8:	ff 92       	push	r15
    25ca:	0f 93       	push	r16
    25cc:	1f 93       	push	r17
    25ce:	cf 93       	push	r28
    25d0:	df 93       	push	r29
    25d2:	1f 92       	push	r1
    25d4:	1f 92       	push	r1
    25d6:	cd b7       	in	r28, 0x3d	; 61
    25d8:	de b7       	in	r29, 0x3e	; 62
    25da:	80 93 09 3d 	sts	0x3D09, r24
    25de:	90 93 0a 3d 	sts	0x3D0A, r25
    25e2:	60 93 07 3d 	sts	0x3D07, r22
    25e6:	70 93 08 3d 	sts	0x3D08, r23
    25ea:	6b 01       	movw	r12, r22
    25ec:	25 e0       	ldi	r18, 0x05	; 5
    25ee:	c2 0e       	add	r12, r18
    25f0:	d1 1c       	adc	r13, r1
    25f2:	e8 94       	clt
    25f4:	c0 f8       	bld	r12, 0
    25f6:	c8 9e       	mul	r12, r24
    25f8:	80 01       	movw	r16, r0
    25fa:	c9 9e       	mul	r12, r25
    25fc:	10 0d       	add	r17, r0
    25fe:	d8 9e       	mul	r13, r24
    2600:	10 0d       	add	r17, r0
    2602:	11 24       	eor	r1, r1
    2604:	c8 01       	movw	r24, r16
    2606:	bd de       	rcall	.-646    	; 0x2382 <csp_malloc>
    2608:	80 93 0b 3d 	sts	0x3D0B, r24
    260c:	90 93 0c 3d 	sts	0x3D0C, r25
    2610:	89 2b       	or	r24, r25
    2612:	09 f4       	brne	.+2      	; 0x2616 <csp_buffer_init+0x54>
    2614:	4d c0       	rjmp	.+154    	; 0x26b0 <csp_buffer_init+0xee>
    2616:	62 e0       	ldi	r22, 0x02	; 2
    2618:	70 e0       	ldi	r23, 0x00	; 0
    261a:	80 91 09 3d 	lds	r24, 0x3D09
    261e:	90 91 0a 3d 	lds	r25, 0x3D0A
    2622:	b5 de       	rcall	.-662    	; 0x238e <csp_queue_create>
    2624:	80 93 0d 3d 	sts	0x3D0D, r24
    2628:	90 93 0e 3d 	sts	0x3D0E, r25
    262c:	89 2b       	or	r24, r25
    262e:	c1 f1       	breq	.+112    	; 0x26a0 <csp_buffer_init+0xde>
    2630:	a8 01       	movw	r20, r16
    2632:	60 e0       	ldi	r22, 0x00	; 0
    2634:	70 e0       	ldi	r23, 0x00	; 0
    2636:	80 91 0b 3d 	lds	r24, 0x3D0B
    263a:	90 91 0c 3d 	lds	r25, 0x3D0C
    263e:	0e 94 5f 2d 	call	0x5abe	; 0x5abe <memset>
    2642:	80 91 09 3d 	lds	r24, 0x3D09
    2646:	90 91 0a 3d 	lds	r25, 0x3D0A
    264a:	89 2b       	or	r24, r25
    264c:	a1 f1       	breq	.+104    	; 0x26b6 <csp_buffer_init+0xf4>
    264e:	e1 2c       	mov	r14, r1
    2650:	f1 2c       	mov	r15, r1
    2652:	00 e0       	ldi	r16, 0x00	; 0
    2654:	10 e0       	ldi	r17, 0x00	; 0
    2656:	e0 91 0b 3d 	lds	r30, 0x3D0B
    265a:	f0 91 0c 3d 	lds	r31, 0x3D0C
    265e:	ee 0d       	add	r30, r14
    2660:	ff 1d       	adc	r31, r15
    2662:	e9 83       	std	Y+1, r30	; 0x01
    2664:	fa 83       	std	Y+2, r31	; 0x02
    2666:	10 82       	st	Z, r1
    2668:	11 82       	std	Z+1, r1	; 0x01
    266a:	e9 81       	ldd	r30, Y+1	; 0x01
    266c:	fa 81       	ldd	r31, Y+2	; 0x02
    266e:	e2 83       	std	Z+2, r30	; 0x02
    2670:	f3 83       	std	Z+3, r31	; 0x03
    2672:	20 e0       	ldi	r18, 0x00	; 0
    2674:	30 e0       	ldi	r19, 0x00	; 0
    2676:	a9 01       	movw	r20, r18
    2678:	be 01       	movw	r22, r28
    267a:	6f 5f       	subi	r22, 0xFF	; 255
    267c:	7f 4f       	sbci	r23, 0xFF	; 255
    267e:	80 91 0d 3d 	lds	r24, 0x3D0D
    2682:	90 91 0e 3d 	lds	r25, 0x3D0E
    2686:	86 de       	rcall	.-756    	; 0x2394 <csp_queue_enqueue>
    2688:	0f 5f       	subi	r16, 0xFF	; 255
    268a:	1f 4f       	sbci	r17, 0xFF	; 255
    268c:	ec 0c       	add	r14, r12
    268e:	fd 1c       	adc	r15, r13
    2690:	80 91 09 3d 	lds	r24, 0x3D09
    2694:	90 91 0a 3d 	lds	r25, 0x3D0A
    2698:	08 17       	cp	r16, r24
    269a:	19 07       	cpc	r17, r25
    269c:	e0 f2       	brcs	.-72     	; 0x2656 <csp_buffer_init+0x94>
    269e:	0e c0       	rjmp	.+28     	; 0x26bc <csp_buffer_init+0xfa>
    26a0:	80 91 0b 3d 	lds	r24, 0x3D0B
    26a4:	90 91 0c 3d 	lds	r25, 0x3D0C
    26a8:	6f de       	rcall	.-802    	; 0x2388 <csp_free>
    26aa:	8f ef       	ldi	r24, 0xFF	; 255
    26ac:	9f ef       	ldi	r25, 0xFF	; 255
    26ae:	08 c0       	rjmp	.+16     	; 0x26c0 <csp_buffer_init+0xfe>
    26b0:	8f ef       	ldi	r24, 0xFF	; 255
    26b2:	9f ef       	ldi	r25, 0xFF	; 255
    26b4:	05 c0       	rjmp	.+10     	; 0x26c0 <csp_buffer_init+0xfe>
    26b6:	80 e0       	ldi	r24, 0x00	; 0
    26b8:	90 e0       	ldi	r25, 0x00	; 0
    26ba:	02 c0       	rjmp	.+4      	; 0x26c0 <csp_buffer_init+0xfe>
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	0f 90       	pop	r0
    26c2:	0f 90       	pop	r0
    26c4:	df 91       	pop	r29
    26c6:	cf 91       	pop	r28
    26c8:	1f 91       	pop	r17
    26ca:	0f 91       	pop	r16
    26cc:	ff 90       	pop	r15
    26ce:	ef 90       	pop	r14
    26d0:	df 90       	pop	r13
    26d2:	cf 90       	pop	r12
    26d4:	08 95       	ret

000026d6 <csp_buffer_get>:
    26d6:	cf 93       	push	r28
    26d8:	df 93       	push	r29
    26da:	1f 92       	push	r1
    26dc:	1f 92       	push	r1
    26de:	cd b7       	in	r28, 0x3d	; 61
    26e0:	de b7       	in	r29, 0x3e	; 62
    26e2:	19 82       	std	Y+1, r1	; 0x01
    26e4:	1a 82       	std	Y+2, r1	; 0x02
    26e6:	0e 96       	adiw	r24, 0x0e	; 14
    26e8:	20 91 07 3d 	lds	r18, 0x3D07
    26ec:	30 91 08 3d 	lds	r19, 0x3D08
    26f0:	28 17       	cp	r18, r24
    26f2:	39 07       	cpc	r19, r25
    26f4:	e8 f0       	brcs	.+58     	; 0x2730 <csp_buffer_get+0x5a>
    26f6:	20 e0       	ldi	r18, 0x00	; 0
    26f8:	30 e0       	ldi	r19, 0x00	; 0
    26fa:	a9 01       	movw	r20, r18
    26fc:	be 01       	movw	r22, r28
    26fe:	6f 5f       	subi	r22, 0xFF	; 255
    2700:	7f 4f       	sbci	r23, 0xFF	; 255
    2702:	80 91 0d 3d 	lds	r24, 0x3D0D
    2706:	90 91 0e 3d 	lds	r25, 0x3D0E
    270a:	56 de       	rcall	.-852    	; 0x23b8 <csp_queue_dequeue>
    270c:	e9 81       	ldd	r30, Y+1	; 0x01
    270e:	fa 81       	ldd	r31, Y+2	; 0x02
    2710:	30 97       	sbiw	r30, 0x00	; 0
    2712:	89 f0       	breq	.+34     	; 0x2736 <csp_buffer_get+0x60>
    2714:	82 81       	ldd	r24, Z+2	; 0x02
    2716:	93 81       	ldd	r25, Z+3	; 0x03
    2718:	e8 17       	cp	r30, r24
    271a:	f9 07       	cpc	r31, r25
    271c:	79 f4       	brne	.+30     	; 0x273c <csp_buffer_get+0x66>
    271e:	80 81       	ld	r24, Z
    2720:	91 81       	ldd	r25, Z+1	; 0x01
    2722:	01 96       	adiw	r24, 0x01	; 1
    2724:	80 83       	st	Z, r24
    2726:	91 83       	std	Z+1, r25	; 0x01
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	9a 81       	ldd	r25, Y+2	; 0x02
    272c:	04 96       	adiw	r24, 0x04	; 4
    272e:	08 c0       	rjmp	.+16     	; 0x2740 <csp_buffer_get+0x6a>
    2730:	80 e0       	ldi	r24, 0x00	; 0
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	05 c0       	rjmp	.+10     	; 0x2740 <csp_buffer_get+0x6a>
    2736:	80 e0       	ldi	r24, 0x00	; 0
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	02 c0       	rjmp	.+4      	; 0x2740 <csp_buffer_get+0x6a>
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	df 91       	pop	r29
    2746:	cf 91       	pop	r28
    2748:	08 95       	ret

0000274a <csp_buffer_free_isr>:
    274a:	cf 93       	push	r28
    274c:	df 93       	push	r29
    274e:	00 d0       	rcall	.+0      	; 0x2750 <csp_buffer_free_isr+0x6>
    2750:	cd b7       	in	r28, 0x3d	; 61
    2752:	de b7       	in	r29, 0x3e	; 62
    2754:	19 82       	std	Y+1, r1	; 0x01
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	51 f1       	breq	.+84     	; 0x27ae <csp_buffer_free_isr+0x64>
    275a:	9c 01       	movw	r18, r24
    275c:	24 50       	subi	r18, 0x04	; 4
    275e:	31 09       	sbc	r19, r1
    2760:	2a 83       	std	Y+2, r18	; 0x02
    2762:	3b 83       	std	Y+3, r19	; 0x03
    2764:	20 fd       	sbrc	r18, 0
    2766:	23 c0       	rjmp	.+70     	; 0x27ae <csp_buffer_free_isr+0x64>
    2768:	f9 01       	movw	r30, r18
    276a:	42 81       	ldd	r20, Z+2	; 0x02
    276c:	53 81       	ldd	r21, Z+3	; 0x03
    276e:	24 17       	cp	r18, r20
    2770:	35 07       	cpc	r19, r21
    2772:	e9 f4       	brne	.+58     	; 0x27ae <csp_buffer_free_isr+0x64>
    2774:	f9 01       	movw	r30, r18
    2776:	20 81       	ld	r18, Z
    2778:	31 81       	ldd	r19, Z+1	; 0x01
    277a:	21 15       	cp	r18, r1
    277c:	31 05       	cpc	r19, r1
    277e:	b9 f0       	breq	.+46     	; 0x27ae <csp_buffer_free_isr+0x64>
    2780:	22 30       	cpi	r18, 0x02	; 2
    2782:	31 05       	cpc	r19, r1
    2784:	28 f0       	brcs	.+10     	; 0x2790 <csp_buffer_free_isr+0x46>
    2786:	21 50       	subi	r18, 0x01	; 1
    2788:	31 09       	sbc	r19, r1
    278a:	20 83       	st	Z, r18
    278c:	31 83       	std	Z+1, r19	; 0x01
    278e:	0f c0       	rjmp	.+30     	; 0x27ae <csp_buffer_free_isr+0x64>
    2790:	fc 01       	movw	r30, r24
    2792:	34 97       	sbiw	r30, 0x04	; 4
    2794:	10 82       	st	Z, r1
    2796:	11 82       	std	Z+1, r1	; 0x01
    2798:	ae 01       	movw	r20, r28
    279a:	4f 5f       	subi	r20, 0xFF	; 255
    279c:	5f 4f       	sbci	r21, 0xFF	; 255
    279e:	be 01       	movw	r22, r28
    27a0:	6e 5f       	subi	r22, 0xFE	; 254
    27a2:	7f 4f       	sbci	r23, 0xFF	; 255
    27a4:	80 91 0d 3d 	lds	r24, 0x3D0D
    27a8:	90 91 0e 3d 	lds	r25, 0x3D0E
    27ac:	fe dd       	rcall	.-1028   	; 0x23aa <csp_queue_enqueue_isr>
    27ae:	23 96       	adiw	r28, 0x03	; 3
    27b0:	cd bf       	out	0x3d, r28	; 61
    27b2:	de bf       	out	0x3e, r29	; 62
    27b4:	df 91       	pop	r29
    27b6:	cf 91       	pop	r28
    27b8:	08 95       	ret

000027ba <csp_buffer_free>:
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	1f 92       	push	r1
    27c0:	1f 92       	push	r1
    27c2:	cd b7       	in	r28, 0x3d	; 61
    27c4:	de b7       	in	r29, 0x3e	; 62
    27c6:	00 97       	sbiw	r24, 0x00	; 0
    27c8:	51 f1       	breq	.+84     	; 0x281e <csp_buffer_free+0x64>
    27ca:	9c 01       	movw	r18, r24
    27cc:	24 50       	subi	r18, 0x04	; 4
    27ce:	31 09       	sbc	r19, r1
    27d0:	29 83       	std	Y+1, r18	; 0x01
    27d2:	3a 83       	std	Y+2, r19	; 0x02
    27d4:	20 fd       	sbrc	r18, 0
    27d6:	23 c0       	rjmp	.+70     	; 0x281e <csp_buffer_free+0x64>
    27d8:	f9 01       	movw	r30, r18
    27da:	42 81       	ldd	r20, Z+2	; 0x02
    27dc:	53 81       	ldd	r21, Z+3	; 0x03
    27de:	24 17       	cp	r18, r20
    27e0:	35 07       	cpc	r19, r21
    27e2:	e9 f4       	brne	.+58     	; 0x281e <csp_buffer_free+0x64>
    27e4:	f9 01       	movw	r30, r18
    27e6:	20 81       	ld	r18, Z
    27e8:	31 81       	ldd	r19, Z+1	; 0x01
    27ea:	21 15       	cp	r18, r1
    27ec:	31 05       	cpc	r19, r1
    27ee:	b9 f0       	breq	.+46     	; 0x281e <csp_buffer_free+0x64>
    27f0:	22 30       	cpi	r18, 0x02	; 2
    27f2:	31 05       	cpc	r19, r1
    27f4:	28 f0       	brcs	.+10     	; 0x2800 <csp_buffer_free+0x46>
    27f6:	21 50       	subi	r18, 0x01	; 1
    27f8:	31 09       	sbc	r19, r1
    27fa:	20 83       	st	Z, r18
    27fc:	31 83       	std	Z+1, r19	; 0x01
    27fe:	0f c0       	rjmp	.+30     	; 0x281e <csp_buffer_free+0x64>
    2800:	fc 01       	movw	r30, r24
    2802:	34 97       	sbiw	r30, 0x04	; 4
    2804:	10 82       	st	Z, r1
    2806:	11 82       	std	Z+1, r1	; 0x01
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	30 e0       	ldi	r19, 0x00	; 0
    280c:	a9 01       	movw	r20, r18
    280e:	be 01       	movw	r22, r28
    2810:	6f 5f       	subi	r22, 0xFF	; 255
    2812:	7f 4f       	sbci	r23, 0xFF	; 255
    2814:	80 91 0d 3d 	lds	r24, 0x3D0D
    2818:	90 91 0e 3d 	lds	r25, 0x3D0E
    281c:	bb dd       	rcall	.-1162   	; 0x2394 <csp_queue_enqueue>
    281e:	0f 90       	pop	r0
    2820:	0f 90       	pop	r0
    2822:	df 91       	pop	r29
    2824:	cf 91       	pop	r28
    2826:	08 95       	ret

00002828 <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    2828:	80 91 0d 3d 	lds	r24, 0x3D0D
    282c:	90 91 0e 3d 	lds	r25, 0x3D0E
    2830:	ce cd       	rjmp	.-1124   	; 0x23ce <csp_queue_size>
}
    2832:	08 95       	ret

00002834 <csp_conn_enqueue_packet>:
#endif

	/* We have a successful connection */
	return conn;

}
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	1f 92       	push	r1
    283a:	1f 92       	push	r1
    283c:	cd b7       	in	r28, 0x3d	; 61
    283e:	de b7       	in	r29, 0x3e	; 62
    2840:	69 83       	std	Y+1, r22	; 0x01
    2842:	7a 83       	std	Y+2, r23	; 0x02
    2844:	00 97       	sbiw	r24, 0x00	; 0
    2846:	a9 f0       	breq	.+42     	; 0x2872 <csp_conn_enqueue_packet+0x3e>
    2848:	20 e0       	ldi	r18, 0x00	; 0
    284a:	30 e0       	ldi	r19, 0x00	; 0
    284c:	a9 01       	movw	r20, r18
    284e:	be 01       	movw	r22, r28
    2850:	6f 5f       	subi	r22, 0xFF	; 255
    2852:	7f 4f       	sbci	r23, 0xFF	; 255
    2854:	fc 01       	movw	r30, r24
    2856:	84 85       	ldd	r24, Z+12	; 0x0c
    2858:	95 85       	ldd	r25, Z+13	; 0x0d
    285a:	9c dd       	rcall	.-1224   	; 0x2394 <csp_queue_enqueue>
    285c:	21 e0       	ldi	r18, 0x01	; 1
    285e:	30 e0       	ldi	r19, 0x00	; 0
    2860:	01 97       	sbiw	r24, 0x01	; 1
    2862:	11 f4       	brne	.+4      	; 0x2868 <csp_conn_enqueue_packet+0x34>
    2864:	20 e0       	ldi	r18, 0x00	; 0
    2866:	30 e0       	ldi	r19, 0x00	; 0
    2868:	88 27       	eor	r24, r24
    286a:	99 27       	eor	r25, r25
    286c:	82 1b       	sub	r24, r18
    286e:	93 0b       	sbc	r25, r19
    2870:	02 c0       	rjmp	.+4      	; 0x2876 <csp_conn_enqueue_packet+0x42>
    2872:	8e ef       	ldi	r24, 0xFE	; 254
    2874:	9f ef       	ldi	r25, 0xFF	; 255
    2876:	0f 90       	pop	r0
    2878:	0f 90       	pop	r0
    287a:	df 91       	pop	r29
    287c:	cf 91       	pop	r28
    287e:	08 95       	ret

00002880 <csp_conn_init>:
    2880:	0f 93       	push	r16
    2882:	1f 93       	push	r17
    2884:	cf 93       	push	r28
    2886:	df 93       	push	r29
    2888:	81 de       	rcall	.-766    	; 0x258c <csp_get_ms>
    288a:	cb 01       	movw	r24, r22
    288c:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <srand>
    2890:	0e 94 58 2c 	call	0x58b0	; 0x58b0 <rand>
    2894:	8f 71       	andi	r24, 0x1F	; 31
    2896:	90 78       	andi	r25, 0x80	; 128
    2898:	99 23       	and	r25, r25
    289a:	24 f4       	brge	.+8      	; 0x28a4 <csp_conn_init+0x24>
    289c:	01 97       	sbiw	r24, 0x01	; 1
    289e:	80 6e       	ori	r24, 0xE0	; 224
    28a0:	9f 6f       	ori	r25, 0xFF	; 255
    28a2:	01 96       	adiw	r24, 0x01	; 1
    28a4:	80 5e       	subi	r24, 0xE0	; 224
    28a6:	80 93 12 3d 	sts	0x3D12, r24
    28aa:	80 e1       	ldi	r24, 0x10	; 16
    28ac:	9d e3       	ldi	r25, 0x3D	; 61
    28ae:	a4 dd       	rcall	.-1208   	; 0x23f8 <csp_bin_sem_create>
    28b0:	01 97       	sbiw	r24, 0x01	; 1
    28b2:	31 f5       	brne	.+76     	; 0x2900 <csp_conn_init+0x80>
    28b4:	c7 e1       	ldi	r28, 0x17	; 23
    28b6:	dd e3       	ldi	r29, 0x3D	; 61
    28b8:	07 e0       	ldi	r16, 0x07	; 7
    28ba:	1e e3       	ldi	r17, 0x3E	; 62
    28bc:	04 c0       	rjmp	.+8      	; 0x28c6 <csp_conn_init+0x46>
    28be:	68 96       	adiw	r28, 0x18	; 24
    28c0:	c0 17       	cp	r28, r16
    28c2:	d1 07       	cpc	r29, r17
    28c4:	79 f0       	breq	.+30     	; 0x28e4 <csp_conn_init+0x64>
    28c6:	62 e0       	ldi	r22, 0x02	; 2
    28c8:	70 e0       	ldi	r23, 0x00	; 0
    28ca:	8a e0       	ldi	r24, 0x0A	; 10
    28cc:	90 e0       	ldi	r25, 0x00	; 0
    28ce:	5f dd       	rcall	.-1346   	; 0x238e <csp_queue_create>
    28d0:	8a 87       	std	Y+10, r24	; 0x0a
    28d2:	9b 87       	std	Y+11, r25	; 0x0b
    28d4:	fe 01       	movw	r30, r28
    28d6:	31 97       	sbiw	r30, 0x01	; 1
    28d8:	10 82       	st	Z, r1
    28da:	ce 01       	movw	r24, r28
    28dc:	7c dd       	rcall	.-1288   	; 0x23d6 <csp_mutex_create>
    28de:	01 97       	sbiw	r24, 0x01	; 1
    28e0:	71 f3       	breq	.-36     	; 0x28be <csp_conn_init+0x3e>
    28e2:	11 c0       	rjmp	.+34     	; 0x2906 <csp_conn_init+0x86>
    28e4:	83 e1       	ldi	r24, 0x13	; 19
    28e6:	9d e3       	ldi	r25, 0x3D	; 61
    28e8:	87 dd       	rcall	.-1266   	; 0x23f8 <csp_bin_sem_create>
    28ea:	21 e0       	ldi	r18, 0x01	; 1
    28ec:	30 e0       	ldi	r19, 0x00	; 0
    28ee:	01 97       	sbiw	r24, 0x01	; 1
    28f0:	11 f4       	brne	.+4      	; 0x28f6 <csp_conn_init+0x76>
    28f2:	20 e0       	ldi	r18, 0x00	; 0
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	88 27       	eor	r24, r24
    28f8:	99 27       	eor	r25, r25
    28fa:	82 1b       	sub	r24, r18
    28fc:	93 0b       	sbc	r25, r19
    28fe:	05 c0       	rjmp	.+10     	; 0x290a <csp_conn_init+0x8a>
    2900:	8f ef       	ldi	r24, 0xFF	; 255
    2902:	9f ef       	ldi	r25, 0xFF	; 255
    2904:	02 c0       	rjmp	.+4      	; 0x290a <csp_conn_init+0x8a>
    2906:	8f ef       	ldi	r24, 0xFF	; 255
    2908:	9f ef       	ldi	r25, 0xFF	; 255
    290a:	df 91       	pop	r29
    290c:	cf 91       	pop	r28
    290e:	1f 91       	pop	r17
    2910:	0f 91       	pop	r16
    2912:	08 95       	ret

00002914 <csp_conn_find>:
    2914:	cf 92       	push	r12
    2916:	df 92       	push	r13
    2918:	ef 92       	push	r14
    291a:	ff 92       	push	r15
    291c:	0f 93       	push	r16
    291e:	1f 93       	push	r17
    2920:	cf 93       	push	r28
    2922:	df 93       	push	r29
    2924:	e5 e1       	ldi	r30, 0x15	; 21
    2926:	fd e3       	ldi	r31, 0x3D	; 61
    2928:	05 e0       	ldi	r16, 0x05	; 5
    292a:	1e e3       	ldi	r17, 0x3E	; 62
    292c:	ef 01       	movw	r28, r30
    292e:	a1 81       	ldd	r26, Z+1	; 0x01
    2930:	aa 23       	and	r26, r26
    2932:	99 f0       	breq	.+38     	; 0x295a <csp_conn_find+0x46>
    2934:	a0 81       	ld	r26, Z
    2936:	a1 11       	cpse	r26, r1
    2938:	10 c0       	rjmp	.+32     	; 0x295a <csp_conn_find+0x46>
    293a:	c4 80       	ldd	r12, Z+4	; 0x04
    293c:	d5 80       	ldd	r13, Z+5	; 0x05
    293e:	e6 80       	ldd	r14, Z+6	; 0x06
    2940:	f7 80       	ldd	r15, Z+7	; 0x07
    2942:	c6 26       	eor	r12, r22
    2944:	d7 26       	eor	r13, r23
    2946:	e8 26       	eor	r14, r24
    2948:	f9 26       	eor	r15, r25
    294a:	c2 22       	and	r12, r18
    294c:	d3 22       	and	r13, r19
    294e:	e4 22       	and	r14, r20
    2950:	f5 22       	and	r15, r21
    2952:	cd 28       	or	r12, r13
    2954:	ce 28       	or	r12, r14
    2956:	cf 28       	or	r12, r15
    2958:	29 f0       	breq	.+10     	; 0x2964 <csp_conn_find+0x50>
    295a:	78 96       	adiw	r30, 0x18	; 24
    295c:	e0 17       	cp	r30, r16
    295e:	f1 07       	cpc	r31, r17
    2960:	29 f7       	brne	.-54     	; 0x292c <csp_conn_find+0x18>
    2962:	03 c0       	rjmp	.+6      	; 0x296a <csp_conn_find+0x56>
    2964:	8e 2f       	mov	r24, r30
    2966:	9d 2f       	mov	r25, r29
    2968:	02 c0       	rjmp	.+4      	; 0x296e <csp_conn_find+0x5a>
    296a:	80 e0       	ldi	r24, 0x00	; 0
    296c:	90 e0       	ldi	r25, 0x00	; 0
    296e:	df 91       	pop	r29
    2970:	cf 91       	pop	r28
    2972:	1f 91       	pop	r17
    2974:	0f 91       	pop	r16
    2976:	ff 90       	pop	r15
    2978:	ef 90       	pop	r14
    297a:	df 90       	pop	r13
    297c:	cf 90       	pop	r12
    297e:	08 95       	ret

00002980 <csp_conn_flush_rx_queue>:
    2980:	0f 93       	push	r16
    2982:	1f 93       	push	r17
    2984:	cf 93       	push	r28
    2986:	df 93       	push	r29
    2988:	1f 92       	push	r1
    298a:	1f 92       	push	r1
    298c:	cd b7       	in	r28, 0x3d	; 61
    298e:	de b7       	in	r29, 0x3e	; 62
    2990:	8c 01       	movw	r16, r24
    2992:	05 c0       	rjmp	.+10     	; 0x299e <csp_conn_flush_rx_queue+0x1e>
    2994:	89 81       	ldd	r24, Y+1	; 0x01
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
    2998:	00 97       	sbiw	r24, 0x00	; 0
    299a:	09 f0       	breq	.+2      	; 0x299e <csp_conn_flush_rx_queue+0x1e>
    299c:	0e df       	rcall	.-484    	; 0x27ba <csp_buffer_free>
    299e:	20 e0       	ldi	r18, 0x00	; 0
    29a0:	30 e0       	ldi	r19, 0x00	; 0
    29a2:	a9 01       	movw	r20, r18
    29a4:	be 01       	movw	r22, r28
    29a6:	6f 5f       	subi	r22, 0xFF	; 255
    29a8:	7f 4f       	sbci	r23, 0xFF	; 255
    29aa:	f8 01       	movw	r30, r16
    29ac:	84 85       	ldd	r24, Z+12	; 0x0c
    29ae:	95 85       	ldd	r25, Z+13	; 0x0d
    29b0:	03 dd       	rcall	.-1530   	; 0x23b8 <csp_queue_dequeue>
    29b2:	01 97       	sbiw	r24, 0x01	; 1
    29b4:	79 f3       	breq	.-34     	; 0x2994 <csp_conn_flush_rx_queue+0x14>
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	0f 90       	pop	r0
    29bc:	0f 90       	pop	r0
    29be:	df 91       	pop	r29
    29c0:	cf 91       	pop	r28
    29c2:	1f 91       	pop	r17
    29c4:	0f 91       	pop	r16
    29c6:	08 95       	ret

000029c8 <csp_conn_allocate>:
    29c8:	1f 93       	push	r17
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	18 2f       	mov	r17, r24
    29d0:	44 e6       	ldi	r20, 0x64	; 100
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	60 e0       	ldi	r22, 0x00	; 0
    29d6:	70 e0       	ldi	r23, 0x00	; 0
    29d8:	83 e1       	ldi	r24, 0x13	; 19
    29da:	9d e3       	ldi	r25, 0x3D	; 61
    29dc:	24 dd       	rcall	.-1464   	; 0x2426 <csp_bin_sem_wait>
    29de:	01 97       	sbiw	r24, 0x01	; 1
    29e0:	09 f0       	breq	.+2      	; 0x29e4 <csp_conn_allocate+0x1c>
    29e2:	47 c0       	rjmp	.+142    	; 0x2a72 <csp_conn_allocate+0xaa>
    29e4:	80 91 0f 3d 	lds	r24, 0x3D0F
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	01 96       	adiw	r24, 0x01	; 1
    29ec:	6a e0       	ldi	r22, 0x0A	; 10
    29ee:	70 e0       	ldi	r23, 0x00	; 0
    29f0:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    29f4:	ec 01       	movw	r28, r24
    29f6:	cc 0f       	add	r28, r28
    29f8:	dd 1f       	adc	r29, r29
    29fa:	c8 0f       	add	r28, r24
    29fc:	d9 1f       	adc	r29, r25
    29fe:	cc 0f       	add	r28, r28
    2a00:	dd 1f       	adc	r29, r29
    2a02:	cc 0f       	add	r28, r28
    2a04:	dd 1f       	adc	r29, r29
    2a06:	cc 0f       	add	r28, r28
    2a08:	dd 1f       	adc	r29, r29
    2a0a:	cb 5e       	subi	r28, 0xEB	; 235
    2a0c:	d2 4c       	sbci	r29, 0xC2	; 194
    2a0e:	49 81       	ldd	r20, Y+1	; 0x01
    2a10:	41 11       	cpse	r20, r1
    2a12:	32 c0       	rjmp	.+100    	; 0x2a78 <csp_conn_allocate+0xb0>
    2a14:	21 c0       	rjmp	.+66     	; 0x2a58 <csp_conn_allocate+0x90>
    2a16:	ec 01       	movw	r28, r24
    2a18:	cc 0f       	add	r28, r28
    2a1a:	dd 1f       	adc	r29, r29
    2a1c:	c8 0f       	add	r28, r24
    2a1e:	d9 1f       	adc	r29, r25
    2a20:	cc 0f       	add	r28, r28
    2a22:	dd 1f       	adc	r29, r29
    2a24:	cc 0f       	add	r28, r28
    2a26:	dd 1f       	adc	r29, r29
    2a28:	cc 0f       	add	r28, r28
    2a2a:	dd 1f       	adc	r29, r29
    2a2c:	cb 5e       	subi	r28, 0xEB	; 235
    2a2e:	d2 4c       	sbci	r29, 0xC2	; 194
    2a30:	49 81       	ldd	r20, Y+1	; 0x01
    2a32:	44 23       	and	r20, r20
    2a34:	89 f0       	breq	.+34     	; 0x2a58 <csp_conn_allocate+0x90>
    2a36:	01 96       	adiw	r24, 0x01	; 1
    2a38:	bf 01       	movw	r22, r30
    2a3a:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    2a3e:	21 50       	subi	r18, 0x01	; 1
    2a40:	31 09       	sbc	r19, r1
    2a42:	21 15       	cp	r18, r1
    2a44:	31 05       	cpc	r19, r1
    2a46:	39 f7       	brne	.-50     	; 0x2a16 <csp_conn_allocate+0x4e>
    2a48:	41 30       	cpi	r20, 0x01	; 1
    2a4a:	31 f4       	brne	.+12     	; 0x2a58 <csp_conn_allocate+0x90>
    2a4c:	83 e1       	ldi	r24, 0x13	; 19
    2a4e:	9d e3       	ldi	r25, 0x3D	; 61
    2a50:	fa dc       	rcall	.-1548   	; 0x2446 <csp_bin_sem_post>
    2a52:	80 e0       	ldi	r24, 0x00	; 0
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	1a c0       	rjmp	.+52     	; 0x2a8c <csp_conn_allocate+0xc4>
    2a58:	91 e0       	ldi	r25, 0x01	; 1
    2a5a:	99 83       	std	Y+1, r25	; 0x01
    2a5c:	1e 86       	std	Y+14, r1	; 0x0e
    2a5e:	1f 86       	std	Y+15, r1	; 0x0f
    2a60:	18 83       	st	Y, r17
    2a62:	80 93 0f 3d 	sts	0x3D0F, r24
    2a66:	83 e1       	ldi	r24, 0x13	; 19
    2a68:	9d e3       	ldi	r25, 0x3D	; 61
    2a6a:	ed dc       	rcall	.-1574   	; 0x2446 <csp_bin_sem_post>
    2a6c:	8c 2f       	mov	r24, r28
    2a6e:	9d 2f       	mov	r25, r29
    2a70:	0d c0       	rjmp	.+26     	; 0x2a8c <csp_conn_allocate+0xc4>
    2a72:	80 e0       	ldi	r24, 0x00	; 0
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	0a c0       	rjmp	.+20     	; 0x2a8c <csp_conn_allocate+0xc4>
    2a78:	01 96       	adiw	r24, 0x01	; 1
    2a7a:	6a e0       	ldi	r22, 0x0A	; 10
    2a7c:	70 e0       	ldi	r23, 0x00	; 0
    2a7e:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    2a82:	29 e0       	ldi	r18, 0x09	; 9
    2a84:	30 e0       	ldi	r19, 0x00	; 0
    2a86:	ea e0       	ldi	r30, 0x0A	; 10
    2a88:	f0 e0       	ldi	r31, 0x00	; 0
    2a8a:	c5 cf       	rjmp	.-118    	; 0x2a16 <csp_conn_allocate+0x4e>
    2a8c:	df 91       	pop	r29
    2a8e:	cf 91       	pop	r28
    2a90:	1f 91       	pop	r17
    2a92:	08 95       	ret

00002a94 <csp_conn_new>:
    2a94:	8f 92       	push	r8
    2a96:	9f 92       	push	r9
    2a98:	af 92       	push	r10
    2a9a:	bf 92       	push	r11
    2a9c:	cf 92       	push	r12
    2a9e:	df 92       	push	r13
    2aa0:	ef 92       	push	r14
    2aa2:	ff 92       	push	r15
    2aa4:	cf 93       	push	r28
    2aa6:	df 93       	push	r29
    2aa8:	4b 01       	movw	r8, r22
    2aaa:	5c 01       	movw	r10, r24
    2aac:	69 01       	movw	r12, r18
    2aae:	7a 01       	movw	r14, r20
    2ab0:	80 e0       	ldi	r24, 0x00	; 0
    2ab2:	8a df       	rcall	.-236    	; 0x29c8 <csp_conn_allocate>
    2ab4:	ec 01       	movw	r28, r24
    2ab6:	00 97       	sbiw	r24, 0x00	; 0
    2ab8:	79 f0       	breq	.+30     	; 0x2ad8 <csp_conn_new+0x44>
    2aba:	8c 82       	std	Y+4, r8	; 0x04
    2abc:	9d 82       	std	Y+5, r9	; 0x05
    2abe:	ae 82       	std	Y+6, r10	; 0x06
    2ac0:	bf 82       	std	Y+7, r11	; 0x07
    2ac2:	c8 86       	std	Y+8, r12	; 0x08
    2ac4:	d9 86       	std	Y+9, r13	; 0x09
    2ac6:	ea 86       	std	Y+10, r14	; 0x0a
    2ac8:	fb 86       	std	Y+11, r15	; 0x0b
    2aca:	60 dd       	rcall	.-1344   	; 0x258c <csp_get_ms>
    2acc:	68 8b       	std	Y+16, r22	; 0x10
    2ace:	79 8b       	std	Y+17, r23	; 0x11
    2ad0:	8a 8b       	std	Y+18, r24	; 0x12
    2ad2:	9b 8b       	std	Y+19, r25	; 0x13
    2ad4:	ce 01       	movw	r24, r28
    2ad6:	54 df       	rcall	.-344    	; 0x2980 <csp_conn_flush_rx_queue>
    2ad8:	ce 01       	movw	r24, r28
    2ada:	df 91       	pop	r29
    2adc:	cf 91       	pop	r28
    2ade:	ff 90       	pop	r15
    2ae0:	ef 90       	pop	r14
    2ae2:	df 90       	pop	r13
    2ae4:	cf 90       	pop	r12
    2ae6:	bf 90       	pop	r11
    2ae8:	af 90       	pop	r10
    2aea:	9f 90       	pop	r9
    2aec:	8f 90       	pop	r8
    2aee:	08 95       	ret

00002af0 <csp_close>:
    2af0:	cf 93       	push	r28
    2af2:	df 93       	push	r29
    2af4:	ec 01       	movw	r28, r24
    2af6:	00 97       	sbiw	r24, 0x00	; 0
    2af8:	a9 f0       	breq	.+42     	; 0x2b24 <csp_close+0x34>
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	88 23       	and	r24, r24
    2afe:	a9 f0       	breq	.+42     	; 0x2b2a <csp_close+0x3a>
    2b00:	44 e6       	ldi	r20, 0x64	; 100
    2b02:	50 e0       	ldi	r21, 0x00	; 0
    2b04:	60 e0       	ldi	r22, 0x00	; 0
    2b06:	70 e0       	ldi	r23, 0x00	; 0
    2b08:	83 e1       	ldi	r24, 0x13	; 19
    2b0a:	9d e3       	ldi	r25, 0x3D	; 61
    2b0c:	8c dc       	rcall	.-1768   	; 0x2426 <csp_bin_sem_wait>
    2b0e:	01 97       	sbiw	r24, 0x01	; 1
    2b10:	79 f4       	brne	.+30     	; 0x2b30 <csp_close+0x40>
    2b12:	19 82       	std	Y+1, r1	; 0x01
    2b14:	ce 01       	movw	r24, r28
    2b16:	34 df       	rcall	.-408    	; 0x2980 <csp_conn_flush_rx_queue>
    2b18:	83 e1       	ldi	r24, 0x13	; 19
    2b1a:	9d e3       	ldi	r25, 0x3D	; 61
    2b1c:	94 dc       	rcall	.-1752   	; 0x2446 <csp_bin_sem_post>
    2b1e:	80 e0       	ldi	r24, 0x00	; 0
    2b20:	90 e0       	ldi	r25, 0x00	; 0
    2b22:	08 c0       	rjmp	.+16     	; 0x2b34 <csp_close+0x44>
    2b24:	8e ef       	ldi	r24, 0xFE	; 254
    2b26:	9f ef       	ldi	r25, 0xFF	; 255
    2b28:	05 c0       	rjmp	.+10     	; 0x2b34 <csp_close+0x44>
    2b2a:	80 e0       	ldi	r24, 0x00	; 0
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	02 c0       	rjmp	.+4      	; 0x2b34 <csp_close+0x44>
    2b30:	8d ef       	ldi	r24, 0xFD	; 253
    2b32:	9f ef       	ldi	r25, 0xFF	; 255
    2b34:	df 91       	pop	r29
    2b36:	cf 91       	pop	r28
    2b38:	08 95       	ret

00002b3a <csp_conn_dport>:

inline int csp_conn_dport(csp_conn_t * conn) {
    2b3a:	fc 01       	movw	r30, r24

	return conn->idin.dport;
    2b3c:	95 81       	ldd	r25, Z+5	; 0x05
    2b3e:	92 95       	swap	r25
    2b40:	96 95       	lsr	r25
    2b42:	96 95       	lsr	r25
    2b44:	93 70       	andi	r25, 0x03	; 3
    2b46:	86 81       	ldd	r24, Z+6	; 0x06
    2b48:	8f 70       	andi	r24, 0x0F	; 15
    2b4a:	88 0f       	add	r24, r24
    2b4c:	88 0f       	add	r24, r24
    2b4e:	89 2b       	or	r24, r25

}
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	08 95       	ret

00002b54 <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    2b54:	8f 92       	push	r8
    2b56:	9f 92       	push	r9
    2b58:	af 92       	push	r10
    2b5a:	bf 92       	push	r11
    2b5c:	cf 92       	push	r12
    2b5e:	df 92       	push	r13
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	0f 93       	push	r16
    2b66:	1f 93       	push	r17
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    2b68:	8a 01       	movw	r16, r20
    2b6a:	9b 01       	movw	r18, r22
    2b6c:	01 50       	subi	r16, 0x01	; 1
    2b6e:	11 09       	sbc	r17, r1
    2b70:	21 09       	sbc	r18, r1
    2b72:	31 09       	sbc	r19, r1
    2b74:	45 2b       	or	r20, r21
    2b76:	46 2b       	or	r20, r22
    2b78:	47 2b       	or	r20, r23
    2b7a:	49 f1       	breq	.+82     	; 0x2bce <csp_crc32_memory+0x7a>
    2b7c:	a8 2f       	mov	r26, r24
    2b7e:	b9 2f       	mov	r27, r25
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    2b80:	88 24       	eor	r8, r8
    2b82:	8a 94       	dec	r8
    2b84:	98 2c       	mov	r9, r8
    2b86:	54 01       	movw	r10, r8
   while (length--)
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    2b88:	4d 91       	ld	r20, X+
    2b8a:	75 01       	movw	r14, r10
    2b8c:	64 01       	movw	r12, r8
    2b8e:	c4 26       	eor	r12, r20
    2b90:	dd 24       	eor	r13, r13
    2b92:	ee 24       	eor	r14, r14
    2b94:	ff 24       	eor	r15, r15
    2b96:	c6 01       	movw	r24, r12
    2b98:	88 0f       	add	r24, r24
    2b9a:	99 1f       	adc	r25, r25
    2b9c:	88 0f       	add	r24, r24
    2b9e:	99 1f       	adc	r25, r25
    2ba0:	fc 01       	movw	r30, r24
    2ba2:	e6 5f       	subi	r30, 0xF6	; 246
    2ba4:	fd 4f       	sbci	r31, 0xFD	; 253
    2ba6:	c5 90       	lpm	r12, Z+
    2ba8:	d5 90       	lpm	r13, Z+
    2baa:	e5 90       	lpm	r14, Z+
    2bac:	f4 90       	lpm	r15, Z
    2bae:	77 27       	eor	r23, r23
    2bb0:	6b 2d       	mov	r22, r11
    2bb2:	5a 2d       	mov	r21, r10
    2bb4:	49 2d       	mov	r20, r9
    2bb6:	4a 01       	movw	r8, r20
    2bb8:	5b 01       	movw	r10, r22
    2bba:	8c 24       	eor	r8, r12
    2bbc:	9d 24       	eor	r9, r13
    2bbe:	ae 24       	eor	r10, r14
    2bc0:	bf 24       	eor	r11, r15

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    2bc2:	01 50       	subi	r16, 0x01	; 1
    2bc4:	11 09       	sbc	r17, r1
    2bc6:	21 09       	sbc	r18, r1
    2bc8:	31 09       	sbc	r19, r1
    2bca:	f0 f6       	brcc	.-68     	; 0x2b88 <csp_crc32_memory+0x34>
    2bcc:	04 c0       	rjmp	.+8      	; 0x2bd6 <csp_crc32_memory+0x82>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    2bce:	88 24       	eor	r8, r8
    2bd0:	8a 94       	dec	r8
    2bd2:	98 2c       	mov	r9, r8
    2bd4:	54 01       	movw	r10, r8
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    2bd6:	c5 01       	movw	r24, r10
    2bd8:	b4 01       	movw	r22, r8
    2bda:	60 95       	com	r22
    2bdc:	70 95       	com	r23
    2bde:	80 95       	com	r24
    2be0:	90 95       	com	r25
}
    2be2:	1f 91       	pop	r17
    2be4:	0f 91       	pop	r16
    2be6:	ff 90       	pop	r15
    2be8:	ef 90       	pop	r14
    2bea:	df 90       	pop	r13
    2bec:	cf 90       	pop	r12
    2bee:	bf 90       	pop	r11
    2bf0:	af 90       	pop	r10
    2bf2:	9f 90       	pop	r9
    2bf4:	8f 90       	pop	r8
    2bf6:	08 95       	ret

00002bf8 <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet) {
    2bf8:	cf 93       	push	r28
    2bfa:	df 93       	push	r29
    2bfc:	ec 01       	movw	r28, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    2bfe:	00 97       	sbiw	r24, 0x00	; 0
    2c00:	b9 f0       	breq	.+46     	; 0x2c30 <csp_crc32_append+0x38>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length);
    2c02:	48 85       	ldd	r20, Y+8	; 0x08
    2c04:	59 85       	ldd	r21, Y+9	; 0x09
    2c06:	60 e0       	ldi	r22, 0x00	; 0
    2c08:	70 e0       	ldi	r23, 0x00	; 0
    2c0a:	0e 96       	adiw	r24, 0x0e	; 14
    2c0c:	a3 df       	rcall	.-186    	; 0x2b54 <csp_crc32_memory>
	crc = csp_hton32(crc);
    2c0e:	5e d0       	rcall	.+188    	; 0x2ccc <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    2c10:	e8 85       	ldd	r30, Y+8	; 0x08
    2c12:	f9 85       	ldd	r31, Y+9	; 0x09
    2c14:	ec 0f       	add	r30, r28
    2c16:	fd 1f       	adc	r31, r29
    2c18:	66 87       	std	Z+14, r22	; 0x0e
    2c1a:	77 87       	std	Z+15, r23	; 0x0f
    2c1c:	80 8b       	std	Z+16, r24	; 0x10
    2c1e:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    2c20:	88 85       	ldd	r24, Y+8	; 0x08
    2c22:	99 85       	ldd	r25, Y+9	; 0x09
    2c24:	04 96       	adiw	r24, 0x04	; 4
    2c26:	88 87       	std	Y+8, r24	; 0x08
    2c28:	99 87       	std	Y+9, r25	; 0x09

	return CSP_ERR_NONE;
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	02 c0       	rjmp	.+4      	; 0x2c34 <csp_crc32_append+0x3c>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    2c30:	8e ef       	ldi	r24, 0xFE	; 254
    2c32:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	08 95       	ret

00002c3a <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet) {
    2c3a:	ef 92       	push	r14
    2c3c:	ff 92       	push	r15
    2c3e:	0f 93       	push	r16
    2c40:	1f 93       	push	r17
    2c42:	cf 93       	push	r28
    2c44:	df 93       	push	r29
    2c46:	00 d0       	rcall	.+0      	; 0x2c48 <csp_crc32_verify+0xe>
    2c48:	1f 92       	push	r1
    2c4a:	cd b7       	in	r28, 0x3d	; 61
    2c4c:	de b7       	in	r29, 0x3e	; 62
    2c4e:	8c 01       	movw	r16, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	51 f1       	breq	.+84     	; 0x2ca8 <csp_crc32_verify+0x6e>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    2c54:	fc 01       	movw	r30, r24
    2c56:	80 85       	ldd	r24, Z+8	; 0x08
    2c58:	91 85       	ldd	r25, Z+9	; 0x09
    2c5a:	84 30       	cpi	r24, 0x04	; 4
    2c5c:	91 05       	cpc	r25, r1
    2c5e:	38 f1       	brcs	.+78     	; 0x2cae <csp_crc32_verify+0x74>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    2c60:	ac 01       	movw	r20, r24
    2c62:	44 50       	subi	r20, 0x04	; 4
    2c64:	51 09       	sbc	r21, r1
    2c66:	60 e0       	ldi	r22, 0x00	; 0
    2c68:	70 e0       	ldi	r23, 0x00	; 0
    2c6a:	c8 01       	movw	r24, r16
    2c6c:	0e 96       	adiw	r24, 0x0e	; 14
    2c6e:	72 df       	rcall	.-284    	; 0x2b54 <csp_crc32_memory>
	crc = csp_hton32(crc);
    2c70:	2d d0       	rcall	.+90     	; 0x2ccc <csp_hton32>
    2c72:	69 83       	std	Y+1, r22	; 0x01
    2c74:	7a 83       	std	Y+2, r23	; 0x02
    2c76:	8b 83       	std	Y+3, r24	; 0x03
    2c78:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    2c7a:	f8 01       	movw	r30, r16
    2c7c:	80 85       	ldd	r24, Z+8	; 0x08
    2c7e:	91 85       	ldd	r25, Z+9	; 0x09
    2c80:	7c 01       	movw	r14, r24
    2c82:	f4 e0       	ldi	r31, 0x04	; 4
    2c84:	ef 1a       	sub	r14, r31
    2c86:	f1 08       	sbc	r15, r1
    2c88:	0a 96       	adiw	r24, 0x0a	; 10
    2c8a:	44 e0       	ldi	r20, 0x04	; 4
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	be 01       	movw	r22, r28
    2c90:	6f 5f       	subi	r22, 0xFF	; 255
    2c92:	7f 4f       	sbci	r23, 0xFF	; 255
    2c94:	80 0f       	add	r24, r16
    2c96:	91 1f       	adc	r25, r17
    2c98:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <memcmp>
    2c9c:	00 97       	sbiw	r24, 0x00	; 0
    2c9e:	51 f4       	brne	.+20     	; 0x2cb4 <csp_crc32_verify+0x7a>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    2ca0:	f8 01       	movw	r30, r16
    2ca2:	e0 86       	std	Z+8, r14	; 0x08
    2ca4:	f1 86       	std	Z+9, r15	; 0x09
		return CSP_ERR_NONE;
    2ca6:	08 c0       	rjmp	.+16     	; 0x2cb8 <csp_crc32_verify+0x7e>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    2ca8:	8e ef       	ldi	r24, 0xFE	; 254
    2caa:	9f ef       	ldi	r25, 0xFF	; 255
    2cac:	05 c0       	rjmp	.+10     	; 0x2cb8 <csp_crc32_verify+0x7e>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    2cae:	8e ef       	ldi	r24, 0xFE	; 254
    2cb0:	9f ef       	ldi	r25, 0xFF	; 255
    2cb2:	02 c0       	rjmp	.+4      	; 0x2cb8 <csp_crc32_verify+0x7e>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    2cb4:	8e ef       	ldi	r24, 0xFE	; 254
    2cb6:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    2cb8:	24 96       	adiw	r28, 0x04	; 4
    2cba:	cd bf       	out	0x3d, r28	; 61
    2cbc:	de bf       	out	0x3e, r29	; 62
    2cbe:	df 91       	pop	r29
    2cc0:	cf 91       	pop	r28
    2cc2:	1f 91       	pop	r17
    2cc4:	0f 91       	pop	r16
    2cc6:	ff 90       	pop	r15
    2cc8:	ef 90       	pop	r14
    2cca:	08 95       	ret

00002ccc <csp_hton32>:
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    2ccc:	cf 92       	push	r12
    2cce:	df 92       	push	r13
    2cd0:	ef 92       	push	r14
    2cd2:	ff 92       	push	r15
    2cd4:	0f 93       	push	r16
    2cd6:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2cd8:	f6 2e       	mov	r15, r22
    2cda:	ee 24       	eor	r14, r14
    2cdc:	dd 24       	eor	r13, r13
    2cde:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2ce0:	09 2f       	mov	r16, r25
    2ce2:	11 27       	eor	r17, r17
    2ce4:	22 27       	eor	r18, r18
    2ce6:	33 27       	eor	r19, r19
    2ce8:	0c 29       	or	r16, r12
    2cea:	1d 29       	or	r17, r13
    2cec:	2e 29       	or	r18, r14
    2cee:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    2cf0:	6b 01       	movw	r12, r22
    2cf2:	7c 01       	movw	r14, r24
    2cf4:	cc 24       	eor	r12, r12
    2cf6:	ee 24       	eor	r14, r14
    2cf8:	ff 24       	eor	r15, r15
    2cfa:	fe 2c       	mov	r15, r14
    2cfc:	ed 2c       	mov	r14, r13
    2cfe:	dc 2c       	mov	r13, r12
    2d00:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2d02:	0c 29       	or	r16, r12
    2d04:	1d 29       	or	r17, r13
    2d06:	2e 29       	or	r18, r14
    2d08:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    2d0a:	dc 01       	movw	r26, r24
    2d0c:	cb 01       	movw	r24, r22
    2d0e:	88 27       	eor	r24, r24
    2d10:	99 27       	eor	r25, r25
    2d12:	bb 27       	eor	r27, r27
    2d14:	89 2f       	mov	r24, r25
    2d16:	9a 2f       	mov	r25, r26
    2d18:	ab 2f       	mov	r26, r27
    2d1a:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2d1c:	bc 01       	movw	r22, r24
    2d1e:	cd 01       	movw	r24, r26
    2d20:	60 2b       	or	r22, r16
    2d22:	71 2b       	or	r23, r17
    2d24:	82 2b       	or	r24, r18
    2d26:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    2d28:	1f 91       	pop	r17
    2d2a:	0f 91       	pop	r16
    2d2c:	ff 90       	pop	r15
    2d2e:	ef 90       	pop	r14
    2d30:	df 90       	pop	r13
    2d32:	cf 90       	pop	r12
    2d34:	08 95       	ret

00002d36 <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    2d36:	cf 92       	push	r12
    2d38:	df 92       	push	r13
    2d3a:	ef 92       	push	r14
    2d3c:	ff 92       	push	r15
    2d3e:	0f 93       	push	r16
    2d40:	1f 93       	push	r17
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2d42:	f6 2e       	mov	r15, r22
    2d44:	ee 24       	eor	r14, r14
    2d46:	dd 24       	eor	r13, r13
    2d48:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2d4a:	09 2f       	mov	r16, r25
    2d4c:	11 27       	eor	r17, r17
    2d4e:	22 27       	eor	r18, r18
    2d50:	33 27       	eor	r19, r19
    2d52:	0c 29       	or	r16, r12
    2d54:	1d 29       	or	r17, r13
    2d56:	2e 29       	or	r18, r14
    2d58:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    2d5a:	6b 01       	movw	r12, r22
    2d5c:	7c 01       	movw	r14, r24
    2d5e:	cc 24       	eor	r12, r12
    2d60:	ee 24       	eor	r14, r14
    2d62:	ff 24       	eor	r15, r15
    2d64:	fe 2c       	mov	r15, r14
    2d66:	ed 2c       	mov	r14, r13
    2d68:	dc 2c       	mov	r13, r12
    2d6a:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    2d6c:	0c 29       	or	r16, r12
    2d6e:	1d 29       	or	r17, r13
    2d70:	2e 29       	or	r18, r14
    2d72:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    2d74:	dc 01       	movw	r26, r24
    2d76:	cb 01       	movw	r24, r22
    2d78:	88 27       	eor	r24, r24
    2d7a:	99 27       	eor	r25, r25
    2d7c:	bb 27       	eor	r27, r27
    2d7e:	89 2f       	mov	r24, r25
    2d80:	9a 2f       	mov	r25, r26
    2d82:	ab 2f       	mov	r26, r27
    2d84:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    2d86:	bc 01       	movw	r22, r24
    2d88:	cd 01       	movw	r24, r26
    2d8a:	60 2b       	or	r22, r16
    2d8c:	71 2b       	or	r23, r17
    2d8e:	82 2b       	or	r24, r18
    2d90:	93 2b       	or	r25, r19
}

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
	return csp_hton32(n32);
}
    2d92:	1f 91       	pop	r17
    2d94:	0f 91       	pop	r16
    2d96:	ff 90       	pop	r15
    2d98:	ef 90       	pop	r14
    2d9a:	df 90       	pop	r13
    2d9c:	cf 90       	pop	r12
    2d9e:	08 95       	ret

00002da0 <csp_get_hostname>:
	csp_packet_t * packet = NULL;
	csp_queue_dequeue(socket->socket, &packet, timeout);

	return packet;

}
    2da0:	80 91 07 3e 	lds	r24, 0x3E07
    2da4:	90 91 08 3e 	lds	r25, 0x3E08
    2da8:	08 95       	ret

00002daa <csp_get_model>:
    2daa:	80 91 05 3e 	lds	r24, 0x3E05
    2dae:	90 91 06 3e 	lds	r25, 0x3E06
    2db2:	08 95       	ret

00002db4 <csp_init>:
    2db4:	80 93 7f 3f 	sts	0x3F7F, r24
    2db8:	63 dd       	rcall	.-1338   	; 0x2880 <csp_conn_init>
    2dba:	9c 01       	movw	r18, r24
    2dbc:	00 97       	sbiw	r24, 0x00	; 0
    2dbe:	31 f4       	brne	.+12     	; 0x2dcc <csp_init+0x18>
    2dc0:	08 d2       	rcall	.+1040   	; 0x31d2 <csp_port_init>
    2dc2:	9c 01       	movw	r18, r24
    2dc4:	00 97       	sbiw	r24, 0x00	; 0
    2dc6:	21 f4       	brne	.+8      	; 0x2dd0 <csp_init+0x1c>
    2dc8:	37 c3       	rjmp	.+1646   	; 0x3438 <csp_route_table_init>
    2dca:	08 95       	ret
    2dcc:	93 2f       	mov	r25, r19
    2dce:	08 95       	ret
    2dd0:	93 2f       	mov	r25, r19
    2dd2:	08 95       	ret

00002dd4 <csp_socket>:
    2dd4:	cf 92       	push	r12
    2dd6:	df 92       	push	r13
    2dd8:	ef 92       	push	r14
    2dda:	ff 92       	push	r15
    2ddc:	cf 93       	push	r28
    2dde:	df 93       	push	r29
    2de0:	6b 01       	movw	r12, r22
    2de2:	7c 01       	movw	r14, r24
    2de4:	dc 01       	movw	r26, r24
    2de6:	cb 01       	movw	r24, r22
    2de8:	81 71       	andi	r24, 0x11	; 17
    2dea:	99 27       	eor	r25, r25
    2dec:	aa 27       	eor	r26, r26
    2dee:	bb 27       	eor	r27, r27
    2df0:	89 2b       	or	r24, r25
    2df2:	8a 2b       	or	r24, r26
    2df4:	8b 2b       	or	r24, r27
    2df6:	11 f5       	brne	.+68     	; 0x2e3c <csp_socket+0x68>
    2df8:	d7 01       	movw	r26, r14
    2dfa:	c6 01       	movw	r24, r12
    2dfc:	8e 7a       	andi	r24, 0xAE	; 174
    2dfe:	9e 7f       	andi	r25, 0xFE	; 254
    2e00:	89 2b       	or	r24, r25
    2e02:	8a 2b       	or	r24, r26
    2e04:	8b 2b       	or	r24, r27
    2e06:	e9 f4       	brne	.+58     	; 0x2e42 <csp_socket+0x6e>
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	de dd       	rcall	.-1092   	; 0x29c8 <csp_conn_allocate>
    2e0c:	ec 01       	movw	r28, r24
    2e0e:	00 97       	sbiw	r24, 0x00	; 0
    2e10:	d9 f0       	breq	.+54     	; 0x2e48 <csp_socket+0x74>
    2e12:	d0 fe       	sbrs	r13, 0
    2e14:	0a c0       	rjmp	.+20     	; 0x2e2a <csp_socket+0x56>
    2e16:	62 e0       	ldi	r22, 0x02	; 2
    2e18:	70 e0       	ldi	r23, 0x00	; 0
    2e1a:	8a e0       	ldi	r24, 0x0A	; 10
    2e1c:	90 e0       	ldi	r25, 0x00	; 0
    2e1e:	b7 da       	rcall	.-2706   	; 0x238e <csp_queue_create>
    2e20:	8e 87       	std	Y+14, r24	; 0x0e
    2e22:	9f 87       	std	Y+15, r25	; 0x0f
    2e24:	89 2b       	or	r24, r25
    2e26:	19 f4       	brne	.+6      	; 0x2e2e <csp_socket+0x5a>
    2e28:	12 c0       	rjmp	.+36     	; 0x2e4e <csp_socket+0x7a>
    2e2a:	1e 86       	std	Y+14, r1	; 0x0e
    2e2c:	1f 86       	std	Y+15, r1	; 0x0f
    2e2e:	cc 8a       	std	Y+20, r12	; 0x14
    2e30:	dd 8a       	std	Y+21, r13	; 0x15
    2e32:	ee 8a       	std	Y+22, r14	; 0x16
    2e34:	ff 8a       	std	Y+23, r15	; 0x17
    2e36:	8c 2f       	mov	r24, r28
    2e38:	9d 2f       	mov	r25, r29
    2e3a:	0b c0       	rjmp	.+22     	; 0x2e52 <csp_socket+0x7e>
    2e3c:	80 e0       	ldi	r24, 0x00	; 0
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	08 c0       	rjmp	.+16     	; 0x2e52 <csp_socket+0x7e>
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	90 e0       	ldi	r25, 0x00	; 0
    2e46:	05 c0       	rjmp	.+10     	; 0x2e52 <csp_socket+0x7e>
    2e48:	80 e0       	ldi	r24, 0x00	; 0
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	02 c0       	rjmp	.+4      	; 0x2e52 <csp_socket+0x7e>
    2e4e:	80 e0       	ldi	r24, 0x00	; 0
    2e50:	90 e0       	ldi	r25, 0x00	; 0
    2e52:	df 91       	pop	r29
    2e54:	cf 91       	pop	r28
    2e56:	ff 90       	pop	r15
    2e58:	ef 90       	pop	r14
    2e5a:	df 90       	pop	r13
    2e5c:	cf 90       	pop	r12
    2e5e:	08 95       	ret

00002e60 <csp_accept>:
    2e60:	cf 93       	push	r28
    2e62:	df 93       	push	r29
    2e64:	1f 92       	push	r1
    2e66:	1f 92       	push	r1
    2e68:	cd b7       	in	r28, 0x3d	; 61
    2e6a:	de b7       	in	r29, 0x3e	; 62
    2e6c:	00 97       	sbiw	r24, 0x00	; 0
    2e6e:	81 f0       	breq	.+32     	; 0x2e90 <csp_accept+0x30>
    2e70:	fc 01       	movw	r30, r24
    2e72:	86 85       	ldd	r24, Z+14	; 0x0e
    2e74:	97 85       	ldd	r25, Z+15	; 0x0f
    2e76:	00 97       	sbiw	r24, 0x00	; 0
    2e78:	71 f0       	breq	.+28     	; 0x2e96 <csp_accept+0x36>
    2e7a:	9a 01       	movw	r18, r20
    2e7c:	ab 01       	movw	r20, r22
    2e7e:	be 01       	movw	r22, r28
    2e80:	6f 5f       	subi	r22, 0xFF	; 255
    2e82:	7f 4f       	sbci	r23, 0xFF	; 255
    2e84:	99 da       	rcall	.-2766   	; 0x23b8 <csp_queue_dequeue>
    2e86:	01 97       	sbiw	r24, 0x01	; 1
    2e88:	49 f4       	brne	.+18     	; 0x2e9c <csp_accept+0x3c>
    2e8a:	89 81       	ldd	r24, Y+1	; 0x01
    2e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8e:	08 c0       	rjmp	.+16     	; 0x2ea0 <csp_accept+0x40>
    2e90:	80 e0       	ldi	r24, 0x00	; 0
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	05 c0       	rjmp	.+10     	; 0x2ea0 <csp_accept+0x40>
    2e96:	80 e0       	ldi	r24, 0x00	; 0
    2e98:	90 e0       	ldi	r25, 0x00	; 0
    2e9a:	02 c0       	rjmp	.+4      	; 0x2ea0 <csp_accept+0x40>
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	0f 90       	pop	r0
    2ea2:	0f 90       	pop	r0
    2ea4:	df 91       	pop	r29
    2ea6:	cf 91       	pop	r28
    2ea8:	08 95       	ret

00002eaa <csp_read>:
    2eaa:	cf 93       	push	r28
    2eac:	df 93       	push	r29
    2eae:	1f 92       	push	r1
    2eb0:	1f 92       	push	r1
    2eb2:	cd b7       	in	r28, 0x3d	; 61
    2eb4:	de b7       	in	r29, 0x3e	; 62
    2eb6:	19 82       	std	Y+1, r1	; 0x01
    2eb8:	1a 82       	std	Y+2, r1	; 0x02
    2eba:	00 97       	sbiw	r24, 0x00	; 0
    2ebc:	89 f0       	breq	.+34     	; 0x2ee0 <csp_read+0x36>
    2ebe:	fc 01       	movw	r30, r24
    2ec0:	21 81       	ldd	r18, Z+1	; 0x01
    2ec2:	21 30       	cpi	r18, 0x01	; 1
    2ec4:	81 f4       	brne	.+32     	; 0x2ee6 <csp_read+0x3c>
    2ec6:	9a 01       	movw	r18, r20
    2ec8:	ab 01       	movw	r20, r22
    2eca:	be 01       	movw	r22, r28
    2ecc:	6f 5f       	subi	r22, 0xFF	; 255
    2ece:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed0:	84 85       	ldd	r24, Z+12	; 0x0c
    2ed2:	95 85       	ldd	r25, Z+13	; 0x0d
    2ed4:	71 da       	rcall	.-2846   	; 0x23b8 <csp_queue_dequeue>
    2ed6:	01 97       	sbiw	r24, 0x01	; 1
    2ed8:	49 f4       	brne	.+18     	; 0x2eec <csp_read+0x42>
    2eda:	89 81       	ldd	r24, Y+1	; 0x01
    2edc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ede:	08 c0       	rjmp	.+16     	; 0x2ef0 <csp_read+0x46>
    2ee0:	80 e0       	ldi	r24, 0x00	; 0
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	05 c0       	rjmp	.+10     	; 0x2ef0 <csp_read+0x46>
    2ee6:	80 e0       	ldi	r24, 0x00	; 0
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
    2eea:	02 c0       	rjmp	.+4      	; 0x2ef0 <csp_read+0x46>
    2eec:	80 e0       	ldi	r24, 0x00	; 0
    2eee:	90 e0       	ldi	r25, 0x00	; 0
    2ef0:	0f 90       	pop	r0
    2ef2:	0f 90       	pop	r0
    2ef4:	df 91       	pop	r29
    2ef6:	cf 91       	pop	r28
    2ef8:	08 95       	ret

00002efa <csp_send_direct>:
    2efa:	8f 92       	push	r8
    2efc:	9f 92       	push	r9
    2efe:	af 92       	push	r10
    2f00:	bf 92       	push	r11
    2f02:	cf 92       	push	r12
    2f04:	df 92       	push	r13
    2f06:	ef 92       	push	r14
    2f08:	ff 92       	push	r15
    2f0a:	0f 93       	push	r16
    2f0c:	1f 93       	push	r17
    2f0e:	cf 93       	push	r28
    2f10:	df 93       	push	r29
    2f12:	96 2e       	mov	r9, r22
    2f14:	87 2e       	mov	r8, r23
    2f16:	d8 2f       	mov	r29, r24
    2f18:	c9 2f       	mov	r28, r25
    2f1a:	5a 01       	movw	r10, r20
    2f1c:	68 01       	movw	r12, r16
    2f1e:	79 01       	movw	r14, r18
    2f20:	41 15       	cp	r20, r1
    2f22:	51 05       	cpc	r21, r1
    2f24:	09 f4       	brne	.+2      	; 0x2f28 <csp_send_direct+0x2e>
    2f26:	7b c0       	rjmp	.+246    	; 0x301e <csp_send_direct+0x124>
    2f28:	89 2f       	mov	r24, r25
    2f2a:	81 70       	andi	r24, 0x01	; 1
    2f2c:	82 95       	swap	r24
    2f2e:	80 7f       	andi	r24, 0xF0	; 240
    2f30:	9d 2f       	mov	r25, r29
    2f32:	92 95       	swap	r25
    2f34:	9f 70       	andi	r25, 0x0F	; 15
    2f36:	89 2b       	or	r24, r25
    2f38:	a9 d2       	rcall	.+1362   	; 0x348c <csp_route_if>
    2f3a:	8c 01       	movw	r16, r24
    2f3c:	00 97       	sbiw	r24, 0x00	; 0
    2f3e:	09 f4       	brne	.+2      	; 0x2f42 <csp_send_direct+0x48>
    2f40:	71 c0       	rjmp	.+226    	; 0x3024 <csp_send_direct+0x12a>
    2f42:	dc 01       	movw	r26, r24
    2f44:	ed 91       	ld	r30, X+
    2f46:	fc 91       	ld	r31, X
    2f48:	30 97       	sbiw	r30, 0x00	; 0
    2f4a:	09 f4       	brne	.+2      	; 0x2f4e <csp_send_direct+0x54>
    2f4c:	6e c0       	rjmp	.+220    	; 0x302a <csp_send_direct+0x130>
    2f4e:	24 81       	ldd	r18, Z+4	; 0x04
    2f50:	35 81       	ldd	r19, Z+5	; 0x05
    2f52:	23 2b       	or	r18, r19
    2f54:	09 f4       	brne	.+2      	; 0x2f58 <csp_send_direct+0x5e>
    2f56:	6c c0       	rjmp	.+216    	; 0x3030 <csp_send_direct+0x136>
    2f58:	2c 2f       	mov	r18, r28
    2f5a:	26 95       	lsr	r18
    2f5c:	2f 71       	andi	r18, 0x1F	; 31
    2f5e:	30 e0       	ldi	r19, 0x00	; 0
    2f60:	80 91 7f 3f 	lds	r24, 0x3F7F
    2f64:	90 e0       	ldi	r25, 0x00	; 0
    2f66:	28 17       	cp	r18, r24
    2f68:	39 07       	cpc	r19, r25
    2f6a:	59 f4       	brne	.+22     	; 0x2f82 <csp_send_direct+0x88>
    2f6c:	93 fc       	sbrc	r9, 3
    2f6e:	46 c0       	rjmp	.+140    	; 0x2ffc <csp_send_direct+0x102>
    2f70:	90 fe       	sbrs	r9, 0
    2f72:	05 c0       	rjmp	.+10     	; 0x2f7e <csp_send_direct+0x84>
    2f74:	c5 01       	movw	r24, r10
    2f76:	40 de       	rcall	.-896    	; 0x2bf8 <csp_crc32_append>
    2f78:	89 2b       	or	r24, r25
    2f7a:	09 f0       	breq	.+2      	; 0x2f7e <csp_send_direct+0x84>
    2f7c:	3f c0       	rjmp	.+126    	; 0x2ffc <csp_send_direct+0x102>
    2f7e:	92 fc       	sbrc	r9, 2
    2f80:	3d c0       	rjmp	.+122    	; 0x2ffc <csp_send_direct+0x102>
    2f82:	f5 01       	movw	r30, r10
    2f84:	92 86       	std	Z+10, r9	; 0x0a
    2f86:	83 86       	std	Z+11, r8	; 0x0b
    2f88:	d4 87       	std	Z+12, r29	; 0x0c
    2f8a:	c5 87       	std	Z+13, r28	; 0x0d
    2f8c:	c0 85       	ldd	r28, Z+8	; 0x08
    2f8e:	d1 85       	ldd	r29, Z+9	; 0x09
    2f90:	f8 01       	movw	r30, r16
    2f92:	a0 81       	ld	r26, Z
    2f94:	b1 81       	ldd	r27, Z+1	; 0x01
    2f96:	17 96       	adiw	r26, 0x07	; 7
    2f98:	8d 91       	ld	r24, X+
    2f9a:	9c 91       	ld	r25, X
    2f9c:	18 97       	sbiw	r26, 0x08	; 8
    2f9e:	00 97       	sbiw	r24, 0x00	; 0
    2fa0:	19 f0       	breq	.+6      	; 0x2fa8 <csp_send_direct+0xae>
    2fa2:	8c 17       	cp	r24, r28
    2fa4:	9d 07       	cpc	r25, r29
    2fa6:	50 f1       	brcs	.+84     	; 0x2ffc <csp_send_direct+0x102>
    2fa8:	14 96       	adiw	r26, 0x04	; 4
    2faa:	ed 91       	ld	r30, X+
    2fac:	fc 91       	ld	r31, X
    2fae:	15 97       	sbiw	r26, 0x05	; 5
    2fb0:	a7 01       	movw	r20, r14
    2fb2:	96 01       	movw	r18, r12
    2fb4:	b5 01       	movw	r22, r10
    2fb6:	cd 01       	movw	r24, r26
    2fb8:	19 95       	eicall
    2fba:	00 97       	sbiw	r24, 0x00	; 0
    2fbc:	f9 f4       	brne	.+62     	; 0x2ffc <csp_send_direct+0x102>
    2fbe:	d8 01       	movw	r26, r16
    2fc0:	ed 91       	ld	r30, X+
    2fc2:	fc 91       	ld	r31, X
    2fc4:	11 97       	sbiw	r26, 0x01	; 1
    2fc6:	42 85       	ldd	r20, Z+10	; 0x0a
    2fc8:	53 85       	ldd	r21, Z+11	; 0x0b
    2fca:	64 85       	ldd	r22, Z+12	; 0x0c
    2fcc:	75 85       	ldd	r23, Z+13	; 0x0d
    2fce:	4f 5f       	subi	r20, 0xFF	; 255
    2fd0:	5f 4f       	sbci	r21, 0xFF	; 255
    2fd2:	6f 4f       	sbci	r22, 0xFF	; 255
    2fd4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fd6:	42 87       	std	Z+10, r20	; 0x0a
    2fd8:	53 87       	std	Z+11, r21	; 0x0b
    2fda:	64 87       	std	Z+12, r22	; 0x0c
    2fdc:	75 87       	std	Z+13, r23	; 0x0d
    2fde:	ed 91       	ld	r30, X+
    2fe0:	fc 91       	ld	r31, X
    2fe2:	46 a1       	ldd	r20, Z+38	; 0x26
    2fe4:	57 a1       	ldd	r21, Z+39	; 0x27
    2fe6:	60 a5       	ldd	r22, Z+40	; 0x28
    2fe8:	71 a5       	ldd	r23, Z+41	; 0x29
    2fea:	4c 0f       	add	r20, r28
    2fec:	5d 1f       	adc	r21, r29
    2fee:	61 1d       	adc	r22, r1
    2ff0:	71 1d       	adc	r23, r1
    2ff2:	46 a3       	std	Z+38, r20	; 0x26
    2ff4:	57 a3       	std	Z+39, r21	; 0x27
    2ff6:	60 a7       	std	Z+40, r22	; 0x28
    2ff8:	71 a7       	std	Z+41, r23	; 0x29
    2ffa:	1c c0       	rjmp	.+56     	; 0x3034 <csp_send_direct+0x13a>
    2ffc:	d8 01       	movw	r26, r16
    2ffe:	ed 91       	ld	r30, X+
    3000:	fc 91       	ld	r31, X
    3002:	82 89       	ldd	r24, Z+18	; 0x12
    3004:	93 89       	ldd	r25, Z+19	; 0x13
    3006:	a4 89       	ldd	r26, Z+20	; 0x14
    3008:	b5 89       	ldd	r27, Z+21	; 0x15
    300a:	01 96       	adiw	r24, 0x01	; 1
    300c:	a1 1d       	adc	r26, r1
    300e:	b1 1d       	adc	r27, r1
    3010:	82 8b       	std	Z+18, r24	; 0x12
    3012:	93 8b       	std	Z+19, r25	; 0x13
    3014:	a4 8b       	std	Z+20, r26	; 0x14
    3016:	b5 8b       	std	Z+21, r27	; 0x15
    3018:	86 ef       	ldi	r24, 0xF6	; 246
    301a:	9f ef       	ldi	r25, 0xFF	; 255
    301c:	0b c0       	rjmp	.+22     	; 0x3034 <csp_send_direct+0x13a>
    301e:	86 ef       	ldi	r24, 0xF6	; 246
    3020:	9f ef       	ldi	r25, 0xFF	; 255
    3022:	08 c0       	rjmp	.+16     	; 0x3034 <csp_send_direct+0x13a>
    3024:	86 ef       	ldi	r24, 0xF6	; 246
    3026:	9f ef       	ldi	r25, 0xFF	; 255
    3028:	05 c0       	rjmp	.+10     	; 0x3034 <csp_send_direct+0x13a>
    302a:	86 ef       	ldi	r24, 0xF6	; 246
    302c:	9f ef       	ldi	r25, 0xFF	; 255
    302e:	02 c0       	rjmp	.+4      	; 0x3034 <csp_send_direct+0x13a>
    3030:	86 ef       	ldi	r24, 0xF6	; 246
    3032:	9f ef       	ldi	r25, 0xFF	; 255
    3034:	df 91       	pop	r29
    3036:	cf 91       	pop	r28
    3038:	1f 91       	pop	r17
    303a:	0f 91       	pop	r16
    303c:	ff 90       	pop	r15
    303e:	ef 90       	pop	r14
    3040:	df 90       	pop	r13
    3042:	cf 90       	pop	r12
    3044:	bf 90       	pop	r11
    3046:	af 90       	pop	r10
    3048:	9f 90       	pop	r9
    304a:	8f 90       	pop	r8
    304c:	08 95       	ret

0000304e <csp_send>:
    304e:	0f 93       	push	r16
    3050:	1f 93       	push	r17
    3052:	fb 01       	movw	r30, r22
    3054:	00 97       	sbiw	r24, 0x00	; 0
    3056:	d1 f0       	breq	.+52     	; 0x308c <csp_send+0x3e>
    3058:	30 97       	sbiw	r30, 0x00	; 0
    305a:	d9 f0       	breq	.+54     	; 0x3092 <csp_send+0x44>
    305c:	dc 01       	movw	r26, r24
    305e:	11 96       	adiw	r26, 0x01	; 1
    3060:	6c 91       	ld	r22, X
    3062:	11 97       	sbiw	r26, 0x01	; 1
    3064:	61 30       	cpi	r22, 0x01	; 1
    3066:	c1 f4       	brne	.+48     	; 0x3098 <csp_send+0x4a>
    3068:	18 96       	adiw	r26, 0x08	; 8
    306a:	6d 91       	ld	r22, X+
    306c:	7d 91       	ld	r23, X+
    306e:	8d 91       	ld	r24, X+
    3070:	9c 91       	ld	r25, X
    3072:	1b 97       	sbiw	r26, 0x0b	; 11
    3074:	89 01       	movw	r16, r18
    3076:	9a 01       	movw	r18, r20
    3078:	af 01       	movw	r20, r30
    307a:	3f df       	rcall	.-386    	; 0x2efa <csp_send_direct>
    307c:	31 e0       	ldi	r19, 0x01	; 1
    307e:	20 e0       	ldi	r18, 0x00	; 0
    3080:	89 2b       	or	r24, r25
    3082:	09 f0       	breq	.+2      	; 0x3086 <csp_send+0x38>
    3084:	30 e0       	ldi	r19, 0x00	; 0
    3086:	83 2f       	mov	r24, r19
    3088:	92 2f       	mov	r25, r18
    308a:	08 c0       	rjmp	.+16     	; 0x309c <csp_send+0x4e>
    308c:	80 e0       	ldi	r24, 0x00	; 0
    308e:	90 e0       	ldi	r25, 0x00	; 0
    3090:	05 c0       	rjmp	.+10     	; 0x309c <csp_send+0x4e>
    3092:	80 e0       	ldi	r24, 0x00	; 0
    3094:	90 e0       	ldi	r25, 0x00	; 0
    3096:	02 c0       	rjmp	.+4      	; 0x309c <csp_send+0x4e>
    3098:	80 e0       	ldi	r24, 0x00	; 0
    309a:	90 e0       	ldi	r25, 0x00	; 0
    309c:	1f 91       	pop	r17
    309e:	0f 91       	pop	r16
    30a0:	08 95       	ret

000030a2 <csp_sendto>:

int csp_sendto(uint8_t prio, uint8_t dest, uint8_t dport, uint8_t src_port, uint32_t opts, csp_packet_t * packet, uint32_t timeout) {
    30a2:	4f 92       	push	r4
    30a4:	5f 92       	push	r5
    30a6:	6f 92       	push	r6
    30a8:	7f 92       	push	r7
    30aa:	8f 92       	push	r8
    30ac:	9f 92       	push	r9
    30ae:	af 92       	push	r10
    30b0:	bf 92       	push	r11
    30b2:	cf 92       	push	r12
    30b4:	df 92       	push	r13
    30b6:	ef 92       	push	r14
    30b8:	ff 92       	push	r15
    30ba:	0f 93       	push	r16
    30bc:	1f 93       	push	r17
    30be:	cf 93       	push	r28
    30c0:	df 93       	push	r29
    30c2:	cd b7       	in	r28, 0x3d	; 61
    30c4:	de b7       	in	r29, 0x3e	; 62
    30c6:	f6 01       	movw	r30, r12

	packet->id.flags = 0;
    30c8:	12 86       	std	Z+10, r1	; 0x0a

	if (opts & CSP_O_RDP) {
    30ca:	e0 fc       	sbrc	r14, 0
    30cc:	45 c0       	rjmp	.+138    	; 0x3158 <csp_sendto+0xb6>
    30ce:	27 01       	movw	r4, r14
    30d0:	38 01       	movw	r6, r16
    30d2:	94 e1       	ldi	r25, 0x14	; 20
    30d4:	49 22       	and	r4, r25
    30d6:	55 24       	eor	r5, r5
    30d8:	66 24       	eor	r6, r6
    30da:	77 24       	eor	r7, r7
		csp_log_error("Attempt to create HMAC authenticated packet, but CSP was compiled without HMAC support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_XTEA) {
    30dc:	45 28       	or	r4, r5
    30de:	46 28       	or	r4, r6
    30e0:	47 28       	or	r4, r7
    30e2:	e9 f5       	brne	.+122    	; 0x315e <csp_sendto+0xbc>
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_CRC32) {
    30e4:	e6 fe       	sbrs	r14, 6
    30e6:	02 c0       	rjmp	.+4      	; 0x30ec <csp_sendto+0x4a>
#ifdef CSP_USE_CRC32
		packet->id.flags |= CSP_FCRC32;
    30e8:	91 e0       	ldi	r25, 0x01	; 1
    30ea:	92 87       	std	Z+10, r25	; 0x0a
		csp_log_error("Attempt to create CRC32 validated packet, but CSP was compiled without CRC32 support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	packet->id.dst = dest;
    30ec:	64 fb       	bst	r22, 4
    30ee:	99 27       	eor	r25, r25
    30f0:	90 f9       	bld	r25, 0
    30f2:	35 85       	ldd	r19, Z+13	; 0x0d
    30f4:	3e 7f       	andi	r19, 0xFE	; 254
    30f6:	39 2b       	or	r19, r25
    30f8:	35 87       	std	Z+13, r19	; 0x0d
	packet->id.dport = dport;
    30fa:	54 2f       	mov	r21, r20
    30fc:	52 95       	swap	r21
    30fe:	55 0f       	add	r21, r21
    3100:	55 0f       	add	r21, r21
    3102:	50 7c       	andi	r21, 0xC0	; 192
    3104:	93 85       	ldd	r25, Z+11	; 0x0b
    3106:	9f 73       	andi	r25, 0x3F	; 63
    3108:	95 2b       	or	r25, r21
    310a:	93 87       	std	Z+11, r25	; 0x0b
    310c:	46 95       	lsr	r20
    310e:	46 95       	lsr	r20
    3110:	4f 70       	andi	r20, 0x0F	; 15
    3112:	62 95       	swap	r22
    3114:	60 7f       	andi	r22, 0xF0	; 240
    3116:	64 2b       	or	r22, r20
    3118:	64 87       	std	Z+12, r22	; 0x0c
	packet->id.src = my_address;
    311a:	40 91 7f 3f 	lds	r20, 0x3F7F
    311e:	4f 71       	andi	r20, 0x1F	; 31
    3120:	44 0f       	add	r20, r20
    3122:	31 70       	andi	r19, 0x01	; 1
	packet->id.sport = src_port;
    3124:	2f 73       	andi	r18, 0x3F	; 63
    3126:	90 7c       	andi	r25, 0xC0	; 192
    3128:	29 2b       	or	r18, r25
    312a:	23 87       	std	Z+11, r18	; 0x0b
	packet->id.pri = prio;
    312c:	98 2f       	mov	r25, r24
    312e:	92 95       	swap	r25
    3130:	99 0f       	add	r25, r25
    3132:	99 0f       	add	r25, r25
    3134:	90 7c       	andi	r25, 0xC0	; 192
    3136:	83 2f       	mov	r24, r19
    3138:	84 2b       	or	r24, r20
    313a:	89 2b       	or	r24, r25
    313c:	85 87       	std	Z+13, r24	; 0x0d

	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
    313e:	62 85       	ldd	r22, Z+10	; 0x0a
    3140:	73 85       	ldd	r23, Z+11	; 0x0b
    3142:	84 85       	ldd	r24, Z+12	; 0x0c
    3144:	95 85       	ldd	r25, Z+13	; 0x0d
    3146:	95 01       	movw	r18, r10
    3148:	84 01       	movw	r16, r8
    314a:	af 01       	movw	r20, r30
    314c:	d6 de       	rcall	.-596    	; 0x2efa <csp_send_direct>
    314e:	00 97       	sbiw	r24, 0x00	; 0
    3150:	41 f0       	breq	.+16     	; 0x3162 <csp_sendto+0xc0>
		return CSP_ERR_NOTSUP;
    3152:	8b ef       	ldi	r24, 0xFB	; 251
    3154:	9f ef       	ldi	r25, 0xFF	; 255
    3156:	05 c0       	rjmp	.+10     	; 0x3162 <csp_sendto+0xc0>

	packet->id.flags = 0;

	if (opts & CSP_O_RDP) {
		csp_log_error("Attempt to create RDP packet on connection-less socket\r\n");
		return CSP_ERR_INVAL;
    3158:	8e ef       	ldi	r24, 0xFE	; 254
    315a:	9f ef       	ldi	r25, 0xFF	; 255
    315c:	02 c0       	rjmp	.+4      	; 0x3162 <csp_sendto+0xc0>
	if (opts & CSP_O_XTEA) {
#ifdef CSP_USE_XTEA
		packet->id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
    315e:	8b ef       	ldi	r24, 0xFB	; 251
    3160:	9f ef       	ldi	r25, 0xFF	; 255
	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
		return CSP_ERR_NOTSUP;
	
	return CSP_ERR_NONE;

}
    3162:	df 91       	pop	r29
    3164:	cf 91       	pop	r28
    3166:	1f 91       	pop	r17
    3168:	0f 91       	pop	r16
    316a:	ff 90       	pop	r15
    316c:	ef 90       	pop	r14
    316e:	df 90       	pop	r13
    3170:	cf 90       	pop	r12
    3172:	bf 90       	pop	r11
    3174:	af 90       	pop	r10
    3176:	9f 90       	pop	r9
    3178:	8f 90       	pop	r8
    317a:	7f 90       	pop	r7
    317c:	6f 90       	pop	r6
    317e:	5f 90       	pop	r5
    3180:	4f 90       	pop	r4
    3182:	08 95       	ret

00003184 <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
    3184:	81 32       	cpi	r24, 0x21	; 33
    3186:	91 05       	cpc	r25, r1
    3188:	f0 f4       	brcc	.+60     	; 0x31c6 <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    318a:	fc 01       	movw	r30, r24
    318c:	ee 0f       	add	r30, r30
    318e:	ff 1f       	adc	r31, r31
    3190:	e8 0f       	add	r30, r24
    3192:	f9 1f       	adc	r31, r25
    3194:	e7 5f       	subi	r30, 0xF7	; 247
    3196:	f1 4c       	sbci	r31, 0xC1	; 193
    3198:	20 81       	ld	r18, Z
    319a:	21 30       	cpi	r18, 0x01	; 1
    319c:	59 f4       	brne	.+22     	; 0x31b4 <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    319e:	fc 01       	movw	r30, r24
    31a0:	ee 0f       	add	r30, r30
    31a2:	ff 1f       	adc	r31, r31
    31a4:	8e 0f       	add	r24, r30
    31a6:	9f 1f       	adc	r25, r31
    31a8:	fc 01       	movw	r30, r24
    31aa:	e7 5f       	subi	r30, 0xF7	; 247
    31ac:	f1 4c       	sbci	r31, 0xC1	; 193
    31ae:	81 81       	ldd	r24, Z+1	; 0x01
    31b0:	92 81       	ldd	r25, Z+2	; 0x02
    31b2:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    31b4:	80 91 69 3e 	lds	r24, 0x3E69
    31b8:	81 30       	cpi	r24, 0x01	; 1
    31ba:	41 f4       	brne	.+16     	; 0x31cc <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    31bc:	80 91 6a 3e 	lds	r24, 0x3E6A
    31c0:	90 91 6b 3e 	lds	r25, 0x3E6B
    31c4:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
		return NULL;
    31c6:	80 e0       	ldi	r24, 0x00	; 0
    31c8:	90 e0       	ldi	r25, 0x00	; 0
    31ca:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    31cc:	80 e0       	ldi	r24, 0x00	; 0
    31ce:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    31d0:	08 95       	ret

000031d2 <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    31d2:	83 e6       	ldi	r24, 0x63	; 99
    31d4:	e9 e0       	ldi	r30, 0x09	; 9
    31d6:	fe e3       	ldi	r31, 0x3E	; 62
    31d8:	df 01       	movw	r26, r30
    31da:	1d 92       	st	X+, r1
    31dc:	8a 95       	dec	r24
    31de:	e9 f7       	brne	.-6      	; 0x31da <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    31e0:	80 e0       	ldi	r24, 0x00	; 0
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	08 95       	ret

000031e6 <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    31e6:	cf 93       	push	r28
    31e8:	df 93       	push	r29
    31ea:	ec 01       	movw	r28, r24
    31ec:	cb 01       	movw	r24, r22
	
	if (socket == NULL)
    31ee:	20 97       	sbiw	r28, 0x00	; 0
    31f0:	81 f0       	breq	.+32     	; 0x3212 <csp_listen+0x2c>
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    31f2:	62 e0       	ldi	r22, 0x02	; 2
    31f4:	70 e0       	ldi	r23, 0x00	; 0
    31f6:	cb d8       	rcall	.-3690   	; 0x238e <csp_queue_create>
    31f8:	8e 87       	std	Y+14, r24	; 0x0e
    31fa:	9f 87       	std	Y+15, r25	; 0x0f
	if (socket->socket == NULL)
    31fc:	21 e0       	ldi	r18, 0x01	; 1
    31fe:	30 e0       	ldi	r19, 0x00	; 0
    3200:	89 2b       	or	r24, r25
    3202:	11 f0       	breq	.+4      	; 0x3208 <csp_listen+0x22>
    3204:	20 e0       	ldi	r18, 0x00	; 0
    3206:	30 e0       	ldi	r19, 0x00	; 0
    3208:	88 27       	eor	r24, r24
    320a:	99 27       	eor	r25, r25
    320c:	82 1b       	sub	r24, r18
    320e:	93 0b       	sbc	r25, r19
    3210:	02 c0       	rjmp	.+4      	; 0x3216 <csp_listen+0x30>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    3212:	8e ef       	ldi	r24, 0xFE	; 254
    3214:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    3216:	df 91       	pop	r29
    3218:	cf 91       	pop	r28
    321a:	08 95       	ret

0000321c <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
    321c:	00 97       	sbiw	r24, 0x00	; 0
    321e:	e1 f0       	breq	.+56     	; 0x3258 <csp_bind+0x3c>
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    3220:	61 32       	cpi	r22, 0x21	; 33
    3222:	e8 f4       	brcc	.+58     	; 0x325e <csp_bind+0x42>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    3224:	70 e0       	ldi	r23, 0x00	; 0
    3226:	fb 01       	movw	r30, r22
    3228:	ee 0f       	add	r30, r30
    322a:	ff 1f       	adc	r31, r31
    322c:	e6 0f       	add	r30, r22
    322e:	f7 1f       	adc	r31, r23
    3230:	e7 5f       	subi	r30, 0xF7	; 247
    3232:	f1 4c       	sbci	r31, 0xC1	; 193
    3234:	20 81       	ld	r18, Z
    3236:	21 11       	cpse	r18, r1
    3238:	15 c0       	rjmp	.+42     	; 0x3264 <csp_bind+0x48>
	}

	csp_log_info("Binding socket %p to port %u\r\n", socket, port);

	/* Save listener */
	ports[port].socket = socket;
    323a:	fb 01       	movw	r30, r22
    323c:	ee 0f       	add	r30, r30
    323e:	ff 1f       	adc	r31, r31
    3240:	6e 0f       	add	r22, r30
    3242:	7f 1f       	adc	r23, r31
    3244:	fb 01       	movw	r30, r22
    3246:	e7 5f       	subi	r30, 0xF7	; 247
    3248:	f1 4c       	sbci	r31, 0xC1	; 193
    324a:	81 83       	std	Z+1, r24	; 0x01
    324c:	92 83       	std	Z+2, r25	; 0x02
	ports[port].state = PORT_OPEN;
    324e:	81 e0       	ldi	r24, 0x01	; 1
    3250:	80 83       	st	Z, r24

	return CSP_ERR_NONE;
    3252:	80 e0       	ldi	r24, 0x00	; 0
    3254:	90 e0       	ldi	r25, 0x00	; 0
    3256:	08 95       	ret
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    3258:	8e ef       	ldi	r24, 0xFE	; 254
    325a:	9f ef       	ldi	r25, 0xFF	; 255
    325c:	08 95       	ret

	if (port > CSP_ANY) {
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
    325e:	8e ef       	ldi	r24, 0xFE	; 254
    3260:	9f ef       	ldi	r25, 0xFF	; 255
    3262:	08 95       	ret
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
		csp_log_error("Port %d is already in use\r\n", port);
		return CSP_ERR_USED;
    3264:	8c ef       	ldi	r24, 0xFC	; 252
    3266:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    3268:	08 95       	ret

0000326a <csp_route_security_check>:
	return prio;
#else
	return 0;
#endif

}
    326a:	0f 93       	push	r16
    326c:	1f 93       	push	r17
    326e:	cf 93       	push	r28
    3270:	df 93       	push	r29
    3272:	ea 01       	movw	r28, r20
    3274:	89 01       	movw	r16, r18
    3276:	f9 01       	movw	r30, r18
    3278:	82 85       	ldd	r24, Z+10	; 0x0a
    327a:	82 ff       	sbrs	r24, 2
    327c:	0e c0       	rjmp	.+28     	; 0x329a <csp_route_security_check+0x30>
    327e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3280:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3282:	a8 a1       	ldd	r26, Y+32	; 0x20
    3284:	b9 a1       	ldd	r27, Y+33	; 0x21
    3286:	01 96       	adiw	r24, 0x01	; 1
    3288:	a1 1d       	adc	r26, r1
    328a:	b1 1d       	adc	r27, r1
    328c:	8e 8f       	std	Y+30, r24	; 0x1e
    328e:	9f 8f       	std	Y+31, r25	; 0x1f
    3290:	a8 a3       	std	Y+32, r26	; 0x20
    3292:	b9 a3       	std	Y+33, r27	; 0x21
    3294:	8b ef       	ldi	r24, 0xFB	; 251
    3296:	9f ef       	ldi	r25, 0xFF	; 255
    3298:	28 c0       	rjmp	.+80     	; 0x32ea <csp_route_security_check+0x80>
    329a:	80 ff       	sbrs	r24, 0
    329c:	12 c0       	rjmp	.+36     	; 0x32c2 <csp_route_security_check+0x58>
    329e:	c9 01       	movw	r24, r18
    32a0:	cc dc       	rcall	.-1640   	; 0x2c3a <csp_crc32_verify>
    32a2:	89 2b       	or	r24, r25
    32a4:	71 f0       	breq	.+28     	; 0x32c2 <csp_route_security_check+0x58>
    32a6:	8e 89       	ldd	r24, Y+22	; 0x16
    32a8:	9f 89       	ldd	r25, Y+23	; 0x17
    32aa:	a8 8d       	ldd	r26, Y+24	; 0x18
    32ac:	b9 8d       	ldd	r27, Y+25	; 0x19
    32ae:	01 96       	adiw	r24, 0x01	; 1
    32b0:	a1 1d       	adc	r26, r1
    32b2:	b1 1d       	adc	r27, r1
    32b4:	8e 8b       	std	Y+22, r24	; 0x16
    32b6:	9f 8b       	std	Y+23, r25	; 0x17
    32b8:	a8 8f       	std	Y+24, r26	; 0x18
    32ba:	b9 8f       	std	Y+25, r27	; 0x19
    32bc:	8a e9       	ldi	r24, 0x9A	; 154
    32be:	9f ef       	ldi	r25, 0xFF	; 255
    32c0:	14 c0       	rjmp	.+40     	; 0x32ea <csp_route_security_check+0x80>
    32c2:	f8 01       	movw	r30, r16
    32c4:	82 85       	ldd	r24, Z+10	; 0x0a
    32c6:	83 ff       	sbrs	r24, 3
    32c8:	0e c0       	rjmp	.+28     	; 0x32e6 <csp_route_security_check+0x7c>
    32ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    32cc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    32ce:	a8 a1       	ldd	r26, Y+32	; 0x20
    32d0:	b9 a1       	ldd	r27, Y+33	; 0x21
    32d2:	01 96       	adiw	r24, 0x01	; 1
    32d4:	a1 1d       	adc	r26, r1
    32d6:	b1 1d       	adc	r27, r1
    32d8:	8e 8f       	std	Y+30, r24	; 0x1e
    32da:	9f 8f       	std	Y+31, r25	; 0x1f
    32dc:	a8 a3       	std	Y+32, r26	; 0x20
    32de:	b9 a3       	std	Y+33, r27	; 0x21
    32e0:	8b ef       	ldi	r24, 0xFB	; 251
    32e2:	9f ef       	ldi	r25, 0xFF	; 255
    32e4:	02 c0       	rjmp	.+4      	; 0x32ea <csp_route_security_check+0x80>
    32e6:	80 e0       	ldi	r24, 0x00	; 0
    32e8:	90 e0       	ldi	r25, 0x00	; 0
    32ea:	df 91       	pop	r29
    32ec:	cf 91       	pop	r28
    32ee:	1f 91       	pop	r17
    32f0:	0f 91       	pop	r16
    32f2:	08 95       	ret

000032f4 <csp_route_next_packet>:
    32f4:	2f ef       	ldi	r18, 0xFF	; 255
    32f6:	3f ef       	ldi	r19, 0xFF	; 255
    32f8:	40 e0       	ldi	r20, 0x00	; 0
    32fa:	50 e0       	ldi	r21, 0x00	; 0
    32fc:	bc 01       	movw	r22, r24
    32fe:	80 91 6c 3e 	lds	r24, 0x3E6C
    3302:	90 91 6d 3e 	lds	r25, 0x3E6D
    3306:	58 d8       	rcall	.-3920   	; 0x23b8 <csp_queue_dequeue>
    3308:	01 97       	sbiw	r24, 0x01	; 1
    330a:	19 f0       	breq	.+6      	; 0x3312 <csp_route_next_packet+0x1e>
    330c:	8d ef       	ldi	r24, 0xFD	; 253
    330e:	9f ef       	ldi	r25, 0xFF	; 255
    3310:	08 95       	ret
    3312:	80 e0       	ldi	r24, 0x00	; 0
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	08 95       	ret

00003318 <csp_route_start_task>:
    3318:	ef 92       	push	r14
    331a:	ff 92       	push	r15
    331c:	0f 93       	push	r16
    331e:	1f 93       	push	r17
    3320:	0f 2e       	mov	r0, r31
    3322:	fe e6       	ldi	r31, 0x6E	; 110
    3324:	ef 2e       	mov	r14, r31
    3326:	fe e3       	ldi	r31, 0x3E	; 62
    3328:	ff 2e       	mov	r15, r31
    332a:	f0 2d       	mov	r31, r0
    332c:	8b 01       	movw	r16, r22
    332e:	20 e0       	ldi	r18, 0x00	; 0
    3330:	30 e0       	ldi	r19, 0x00	; 0
    3332:	ac 01       	movw	r20, r24
    3334:	6e e8       	ldi	r22, 0x8E	; 142
    3336:	70 e2       	ldi	r23, 0x20	; 32
    3338:	80 e6       	ldi	r24, 0x60	; 96
    333a:	9a e1       	ldi	r25, 0x1A	; 26
    333c:	09 d9       	rcall	.-3566   	; 0x2550 <csp_thread_create>
    333e:	21 e0       	ldi	r18, 0x01	; 1
    3340:	30 e0       	ldi	r19, 0x00	; 0
    3342:	89 2b       	or	r24, r25
    3344:	11 f4       	brne	.+4      	; 0x334a <csp_route_start_task+0x32>
    3346:	20 e0       	ldi	r18, 0x00	; 0
    3348:	30 e0       	ldi	r19, 0x00	; 0
    334a:	88 27       	eor	r24, r24
    334c:	99 27       	eor	r25, r25
    334e:	82 1b       	sub	r24, r18
    3350:	93 0b       	sbc	r25, r19
    3352:	1f 91       	pop	r17
    3354:	0f 91       	pop	r16
    3356:	ff 90       	pop	r15
    3358:	ef 90       	pop	r14
    335a:	08 95       	ret

0000335c <csp_route_get_if_by_name>:
    335c:	0f 93       	push	r16
    335e:	1f 93       	push	r17
    3360:	cf 93       	push	r28
    3362:	df 93       	push	r29
    3364:	8c 01       	movw	r16, r24
    3366:	c0 91 d3 3e 	lds	r28, 0x3ED3
    336a:	d0 91 d4 3e 	lds	r29, 0x3ED4
    336e:	20 97       	sbiw	r28, 0x00	; 0
    3370:	71 f0       	breq	.+28     	; 0x338e <csp_route_get_if_by_name+0x32>
    3372:	4a e0       	ldi	r20, 0x0A	; 10
    3374:	50 e0       	ldi	r21, 0x00	; 0
    3376:	b8 01       	movw	r22, r16
    3378:	88 81       	ld	r24, Y
    337a:	99 81       	ldd	r25, Y+1	; 0x01
    337c:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <strncmp>
    3380:	89 2b       	or	r24, r25
    3382:	29 f0       	breq	.+10     	; 0x338e <csp_route_get_if_by_name+0x32>
    3384:	0a a8       	ldd	r0, Y+50	; 0x32
    3386:	db a9       	ldd	r29, Y+51	; 0x33
    3388:	c0 2d       	mov	r28, r0
    338a:	20 97       	sbiw	r28, 0x00	; 0
    338c:	91 f7       	brne	.-28     	; 0x3372 <csp_route_get_if_by_name+0x16>
    338e:	ce 01       	movw	r24, r28
    3390:	df 91       	pop	r29
    3392:	cf 91       	pop	r28
    3394:	1f 91       	pop	r17
    3396:	0f 91       	pop	r16
    3398:	08 95       	ret

0000339a <csp_route_add_if>:
    339a:	a0 91 d3 3e 	lds	r26, 0x3ED3
    339e:	b0 91 d4 3e 	lds	r27, 0x3ED4
    33a2:	10 97       	sbiw	r26, 0x00	; 0
    33a4:	41 f4       	brne	.+16     	; 0x33b6 <csp_route_add_if+0x1c>
    33a6:	80 93 d3 3e 	sts	0x3ED3, r24
    33aa:	90 93 d4 3e 	sts	0x3ED4, r25
    33ae:	fc 01       	movw	r30, r24
    33b0:	12 aa       	std	Z+50, r1	; 0x32
    33b2:	13 aa       	std	Z+51, r1	; 0x33
    33b4:	08 95       	ret
    33b6:	a8 17       	cp	r26, r24
    33b8:	b9 07       	cpc	r27, r25
    33ba:	b9 f0       	breq	.+46     	; 0x33ea <csp_route_add_if+0x50>
    33bc:	d2 96       	adiw	r26, 0x32	; 50
    33be:	ed 91       	ld	r30, X+
    33c0:	fc 91       	ld	r31, X
    33c2:	d3 97       	sbiw	r26, 0x33	; 51
    33c4:	30 97       	sbiw	r30, 0x00	; 0
    33c6:	39 f4       	brne	.+14     	; 0x33d6 <csp_route_add_if+0x3c>
    33c8:	0a c0       	rjmp	.+20     	; 0x33de <csp_route_add_if+0x44>
    33ca:	22 a9       	ldd	r18, Z+50	; 0x32
    33cc:	33 a9       	ldd	r19, Z+51	; 0x33
    33ce:	21 15       	cp	r18, r1
    33d0:	31 05       	cpc	r19, r1
    33d2:	31 f0       	breq	.+12     	; 0x33e0 <csp_route_add_if+0x46>
    33d4:	f9 01       	movw	r30, r18
    33d6:	8e 17       	cp	r24, r30
    33d8:	9f 07       	cpc	r25, r31
    33da:	b9 f7       	brne	.-18     	; 0x33ca <csp_route_add_if+0x30>
    33dc:	08 95       	ret
    33de:	fd 01       	movw	r30, r26
    33e0:	82 ab       	std	Z+50, r24	; 0x32
    33e2:	93 ab       	std	Z+51, r25	; 0x33
    33e4:	fc 01       	movw	r30, r24
    33e6:	12 aa       	std	Z+50, r1	; 0x32
    33e8:	13 aa       	std	Z+51, r1	; 0x33
    33ea:	08 95       	ret

000033ec <csp_route_set>:
    33ec:	0f 93       	push	r16
    33ee:	1f 93       	push	r17
    33f0:	cf 93       	push	r28
    33f2:	df 93       	push	r29
    33f4:	18 2f       	mov	r17, r24
    33f6:	eb 01       	movw	r28, r22
    33f8:	04 2f       	mov	r16, r20
    33fa:	20 97       	sbiw	r28, 0x00	; 0
    33fc:	99 f0       	breq	.+38     	; 0x3424 <csp_route_set+0x38>
    33fe:	cb 01       	movw	r24, r22
    3400:	cc df       	rcall	.-104    	; 0x339a <csp_route_add_if>
    3402:	11 32       	cpi	r17, 0x21	; 33
    3404:	90 f4       	brcc	.+36     	; 0x342a <csp_route_set+0x3e>
    3406:	81 2f       	mov	r24, r17
    3408:	90 e0       	ldi	r25, 0x00	; 0
    340a:	fc 01       	movw	r30, r24
    340c:	ee 0f       	add	r30, r30
    340e:	ff 1f       	adc	r31, r31
    3410:	e8 0f       	add	r30, r24
    3412:	f9 1f       	adc	r31, r25
    3414:	e0 59       	subi	r30, 0x90	; 144
    3416:	f1 4c       	sbci	r31, 0xC1	; 193
    3418:	c0 83       	st	Z, r28
    341a:	d1 83       	std	Z+1, r29	; 0x01
    341c:	02 83       	std	Z+2, r16	; 0x02
    341e:	80 e0       	ldi	r24, 0x00	; 0
    3420:	90 e0       	ldi	r25, 0x00	; 0
    3422:	05 c0       	rjmp	.+10     	; 0x342e <csp_route_set+0x42>
    3424:	8e ef       	ldi	r24, 0xFE	; 254
    3426:	9f ef       	ldi	r25, 0xFF	; 255
    3428:	02 c0       	rjmp	.+4      	; 0x342e <csp_route_set+0x42>
    342a:	8e ef       	ldi	r24, 0xFE	; 254
    342c:	9f ef       	ldi	r25, 0xFF	; 255
    342e:	df 91       	pop	r29
    3430:	cf 91       	pop	r28
    3432:	1f 91       	pop	r17
    3434:	0f 91       	pop	r16
    3436:	08 95       	ret

00003438 <csp_route_table_init>:
    3438:	83 e6       	ldi	r24, 0x63	; 99
    343a:	e0 e7       	ldi	r30, 0x70	; 112
    343c:	fe e3       	ldi	r31, 0x3E	; 62
    343e:	df 01       	movw	r26, r30
    3440:	1d 92       	st	X+, r1
    3442:	8a 95       	dec	r24
    3444:	e9 f7       	brne	.-6      	; 0x3440 <csp_route_table_init+0x8>
    3446:	80 91 6c 3e 	lds	r24, 0x3E6C
    344a:	90 91 6d 3e 	lds	r25, 0x3E6D
    344e:	89 2b       	or	r24, r25
    3450:	61 f4       	brne	.+24     	; 0x346a <csp_route_table_init+0x32>
    3452:	64 e0       	ldi	r22, 0x04	; 4
    3454:	70 e0       	ldi	r23, 0x00	; 0
    3456:	8a e0       	ldi	r24, 0x0A	; 10
    3458:	90 e0       	ldi	r25, 0x00	; 0
    345a:	0e 94 c7 11 	call	0x238e	; 0x238e <csp_queue_create>
    345e:	80 93 6c 3e 	sts	0x3E6C, r24
    3462:	90 93 6d 3e 	sts	0x3E6D, r25
    3466:	89 2b       	or	r24, r25
    3468:	71 f0       	breq	.+28     	; 0x3486 <csp_route_table_init+0x4e>
    346a:	4f ef       	ldi	r20, 0xFF	; 255
    346c:	6b e3       	ldi	r22, 0x3B	; 59
    346e:	70 e2       	ldi	r23, 0x20	; 32
    3470:	80 91 7f 3f 	lds	r24, 0x3F7F
    3474:	bb df       	rcall	.-138    	; 0x33ec <csp_route_set>
    3476:	4f ef       	ldi	r20, 0xFF	; 255
    3478:	6b e3       	ldi	r22, 0x3B	; 59
    347a:	70 e2       	ldi	r23, 0x20	; 32
    347c:	80 e2       	ldi	r24, 0x20	; 32
    347e:	b6 df       	rcall	.-148    	; 0x33ec <csp_route_set>
    3480:	80 e0       	ldi	r24, 0x00	; 0
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	08 95       	ret
    3486:	8f ef       	ldi	r24, 0xFF	; 255
    3488:	9f ef       	ldi	r25, 0xFF	; 255
    348a:	08 95       	ret

0000348c <csp_route_if>:
    348c:	90 e0       	ldi	r25, 0x00	; 0
    348e:	fc 01       	movw	r30, r24
    3490:	ee 0f       	add	r30, r30
    3492:	ff 1f       	adc	r31, r31
    3494:	e8 0f       	add	r30, r24
    3496:	f9 1f       	adc	r31, r25
    3498:	e0 59       	subi	r30, 0x90	; 144
    349a:	f1 4c       	sbci	r31, 0xC1	; 193
    349c:	20 81       	ld	r18, Z
    349e:	31 81       	ldd	r19, Z+1	; 0x01
    34a0:	23 2b       	or	r18, r19
    34a2:	11 f0       	breq	.+4      	; 0x34a8 <csp_route_if+0x1c>
    34a4:	cf 01       	movw	r24, r30
    34a6:	08 95       	ret
    34a8:	80 91 d0 3e 	lds	r24, 0x3ED0
    34ac:	90 91 d1 3e 	lds	r25, 0x3ED1
    34b0:	89 2b       	or	r24, r25
    34b2:	19 f0       	breq	.+6      	; 0x34ba <csp_route_if+0x2e>
    34b4:	80 ed       	ldi	r24, 0xD0	; 208
    34b6:	9e e3       	ldi	r25, 0x3E	; 62
    34b8:	08 95       	ret
    34ba:	80 e0       	ldi	r24, 0x00	; 0
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	08 95       	ret

000034c0 <csp_task_router>:
    34c0:	cf 93       	push	r28
    34c2:	df 93       	push	r29
    34c4:	00 d0       	rcall	.+0      	; 0x34c6 <csp_task_router+0x6>
    34c6:	00 d0       	rcall	.+0      	; 0x34c8 <csp_task_router+0x8>
    34c8:	cd b7       	in	r28, 0x3d	; 61
    34ca:	de b7       	in	r29, 0x3e	; 62
    34cc:	ce 01       	movw	r24, r28
    34ce:	01 96       	adiw	r24, 0x01	; 1
    34d0:	11 df       	rcall	.-478    	; 0x32f4 <csp_route_next_packet>
    34d2:	89 2b       	or	r24, r25
    34d4:	d9 f7       	brne	.-10     	; 0x34cc <csp_task_router+0xc>
    34d6:	cb 80       	ldd	r12, Y+3	; 0x03
    34d8:	dc 80       	ldd	r13, Y+4	; 0x04
    34da:	cd 82       	std	Y+5, r12	; 0x05
    34dc:	de 82       	std	Y+6, r13	; 0x06
    34de:	d6 01       	movw	r26, r12
    34e0:	1c 96       	adiw	r26, 0x0c	; 12
    34e2:	9c 91       	ld	r25, X
    34e4:	1c 97       	sbiw	r26, 0x0c	; 12
    34e6:	92 95       	swap	r25
    34e8:	9f 70       	andi	r25, 0x0F	; 15
    34ea:	1d 96       	adiw	r26, 0x0d	; 13
    34ec:	8c 91       	ld	r24, X
    34ee:	81 70       	andi	r24, 0x01	; 1
    34f0:	82 95       	swap	r24
    34f2:	80 7f       	andi	r24, 0xF0	; 240
    34f4:	89 2b       	or	r24, r25
    34f6:	48 2f       	mov	r20, r24
    34f8:	50 e0       	ldi	r21, 0x00	; 0
    34fa:	20 91 7f 3f 	lds	r18, 0x3F7F
    34fe:	30 e0       	ldi	r19, 0x00	; 0
    3500:	42 17       	cp	r20, r18
    3502:	53 07       	cpc	r21, r19
    3504:	21 f1       	breq	.+72     	; 0x354e <csp_task_router+0x8e>
    3506:	8f 31       	cpi	r24, 0x1F	; 31
    3508:	11 f1       	breq	.+68     	; 0x354e <csp_task_router+0x8e>
    350a:	c0 df       	rcall	.-128    	; 0x348c <csp_route_if>
    350c:	00 97       	sbiw	r24, 0x00	; 0
    350e:	59 f0       	breq	.+22     	; 0x3526 <csp_task_router+0x66>
    3510:	dc 01       	movw	r26, r24
    3512:	ed 91       	ld	r30, X+
    3514:	fc 91       	ld	r31, X
    3516:	89 81       	ldd	r24, Y+1	; 0x01
    3518:	9a 81       	ldd	r25, Y+2	; 0x02
    351a:	e8 17       	cp	r30, r24
    351c:	f9 07       	cpc	r31, r25
    351e:	31 f4       	brne	.+12     	; 0x352c <csp_task_router+0x6c>
    3520:	81 85       	ldd	r24, Z+9	; 0x09
    3522:	81 11       	cpse	r24, r1
    3524:	03 c0       	rjmp	.+6      	; 0x352c <csp_task_router+0x6c>
    3526:	c6 01       	movw	r24, r12
    3528:	48 d9       	rcall	.-3440   	; 0x27ba <csp_buffer_free>
    352a:	d0 cf       	rjmp	.-96     	; 0x34cc <csp_task_router+0xc>
    352c:	f6 01       	movw	r30, r12
    352e:	62 85       	ldd	r22, Z+10	; 0x0a
    3530:	73 85       	ldd	r23, Z+11	; 0x0b
    3532:	84 85       	ldd	r24, Z+12	; 0x0c
    3534:	95 85       	ldd	r25, Z+13	; 0x0d
    3536:	00 e0       	ldi	r16, 0x00	; 0
    3538:	10 e0       	ldi	r17, 0x00	; 0
    353a:	98 01       	movw	r18, r16
    353c:	a6 01       	movw	r20, r12
    353e:	dd dc       	rcall	.-1606   	; 0x2efa <csp_send_direct>
    3540:	89 2b       	or	r24, r25
    3542:	09 f4       	brne	.+2      	; 0x3546 <csp_task_router+0x86>
    3544:	c3 cf       	rjmp	.-122    	; 0x34cc <csp_task_router+0xc>
    3546:	8d 81       	ldd	r24, Y+5	; 0x05
    3548:	9e 81       	ldd	r25, Y+6	; 0x06
    354a:	37 d9       	rcall	.-3474   	; 0x27ba <csp_buffer_free>
    354c:	bf cf       	rjmp	.-130    	; 0x34cc <csp_task_router+0xc>
    354e:	d6 01       	movw	r26, r12
    3550:	1b 96       	adiw	r26, 0x0b	; 11
    3552:	9c 91       	ld	r25, X
    3554:	1b 97       	sbiw	r26, 0x0b	; 11
    3556:	92 95       	swap	r25
    3558:	96 95       	lsr	r25
    355a:	96 95       	lsr	r25
    355c:	93 70       	andi	r25, 0x03	; 3
    355e:	1c 96       	adiw	r26, 0x0c	; 12
    3560:	8c 91       	ld	r24, X
    3562:	8f 70       	andi	r24, 0x0F	; 15
    3564:	88 0f       	add	r24, r24
    3566:	88 0f       	add	r24, r24
    3568:	89 2b       	or	r24, r25
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	0b de       	rcall	.-1002   	; 0x3184 <csp_port_get_socket>
    356e:	8c 01       	movw	r16, r24
    3570:	00 97       	sbiw	r24, 0x00	; 0
    3572:	09 f4       	brne	.+2      	; 0x3576 <csp_task_router+0xb6>
    3574:	b5 c0       	rjmp	.+362    	; 0x36e0 <csp_task_router+0x220>
    3576:	fc 01       	movw	r30, r24
    3578:	64 89       	ldd	r22, Z+20	; 0x14
    357a:	75 89       	ldd	r23, Z+21	; 0x15
    357c:	86 89       	ldd	r24, Z+22	; 0x16
    357e:	97 89       	ldd	r25, Z+23	; 0x17
    3580:	70 ff       	sbrs	r23, 0
    3582:	bd c0       	rjmp	.+378    	; 0x36fe <csp_task_router+0x23e>
    3584:	2d 81       	ldd	r18, Y+5	; 0x05
    3586:	3e 81       	ldd	r19, Y+6	; 0x06
    3588:	49 81       	ldd	r20, Y+1	; 0x01
    358a:	5a 81       	ldd	r21, Y+2	; 0x02
    358c:	6e de       	rcall	.-804    	; 0x326a <csp_route_security_check>
    358e:	99 23       	and	r25, r25
    3590:	24 f4       	brge	.+8      	; 0x359a <csp_task_router+0xda>
    3592:	8d 81       	ldd	r24, Y+5	; 0x05
    3594:	9e 81       	ldd	r25, Y+6	; 0x06
    3596:	11 d9       	rcall	.-3550   	; 0x27ba <csp_buffer_free>
    3598:	99 cf       	rjmp	.-206    	; 0x34cc <csp_task_router+0xc>
    359a:	20 e0       	ldi	r18, 0x00	; 0
    359c:	30 e0       	ldi	r19, 0x00	; 0
    359e:	a9 01       	movw	r20, r18
    35a0:	be 01       	movw	r22, r28
    35a2:	6b 5f       	subi	r22, 0xFB	; 251
    35a4:	7f 4f       	sbci	r23, 0xFF	; 255
    35a6:	d8 01       	movw	r26, r16
    35a8:	1e 96       	adiw	r26, 0x0e	; 14
    35aa:	8d 91       	ld	r24, X+
    35ac:	9c 91       	ld	r25, X
    35ae:	1f 97       	sbiw	r26, 0x0f	; 15
    35b0:	0e 94 ca 11 	call	0x2394	; 0x2394 <csp_queue_enqueue>
    35b4:	01 97       	sbiw	r24, 0x01	; 1
    35b6:	09 f4       	brne	.+2      	; 0x35ba <csp_task_router+0xfa>
    35b8:	89 cf       	rjmp	.-238    	; 0x34cc <csp_task_router+0xc>
    35ba:	8d 81       	ldd	r24, Y+5	; 0x05
    35bc:	9e 81       	ldd	r25, Y+6	; 0x06
    35be:	fd d8       	rcall	.-3590   	; 0x27ba <csp_buffer_free>
    35c0:	85 cf       	rjmp	.-246    	; 0x34cc <csp_task_router+0xc>
    35c2:	8d 81       	ldd	r24, Y+5	; 0x05
    35c4:	9e 81       	ldd	r25, Y+6	; 0x06
    35c6:	f9 d8       	rcall	.-3598   	; 0x27ba <csp_buffer_free>
    35c8:	81 cf       	rjmp	.-254    	; 0x34cc <csp_task_router+0xc>
    35ca:	2d 81       	ldd	r18, Y+5	; 0x05
    35cc:	3e 81       	ldd	r19, Y+6	; 0x06
    35ce:	49 81       	ldd	r20, Y+1	; 0x01
    35d0:	5a 81       	ldd	r21, Y+2	; 0x02
    35d2:	f8 01       	movw	r30, r16
    35d4:	64 89       	ldd	r22, Z+20	; 0x14
    35d6:	75 89       	ldd	r23, Z+21	; 0x15
    35d8:	86 89       	ldd	r24, Z+22	; 0x16
    35da:	97 89       	ldd	r25, Z+23	; 0x17
    35dc:	46 de       	rcall	.-884    	; 0x326a <csp_route_security_check>
    35de:	99 23       	and	r25, r25
    35e0:	24 f4       	brge	.+8      	; 0x35ea <csp_task_router+0x12a>
    35e2:	8d 81       	ldd	r24, Y+5	; 0x05
    35e4:	9e 81       	ldd	r25, Y+6	; 0x06
    35e6:	e9 d8       	rcall	.-3630   	; 0x27ba <csp_buffer_free>
    35e8:	71 cf       	rjmp	.-286    	; 0x34cc <csp_task_router+0xc>
    35ea:	ed 81       	ldd	r30, Y+5	; 0x05
    35ec:	fe 81       	ldd	r31, Y+6	; 0x06
    35ee:	95 85       	ldd	r25, Z+13	; 0x0d
    35f0:	89 2f       	mov	r24, r25
    35f2:	80 7c       	andi	r24, 0xC0	; 192
    35f4:	2f 2d       	mov	r18, r15
    35f6:	2f 73       	andi	r18, 0x3F	; 63
    35f8:	f2 2e       	mov	r15, r18
    35fa:	f8 2a       	or	r15, r24
    35fc:	80 91 7f 3f 	lds	r24, 0x3F7F
    3600:	8f 71       	andi	r24, 0x1F	; 31
    3602:	88 0f       	add	r24, r24
    3604:	2f 2d       	mov	r18, r15
    3606:	21 7c       	andi	r18, 0xC1	; 193
    3608:	f2 2e       	mov	r15, r18
    360a:	f8 2a       	or	r15, r24
    360c:	96 95       	lsr	r25
    360e:	94 fb       	bst	r25, 4
    3610:	88 27       	eor	r24, r24
    3612:	80 f9       	bld	r24, 0
    3614:	80 fb       	bst	r24, 0
    3616:	f0 f8       	bld	r15, 0
    3618:	83 85       	ldd	r24, Z+11	; 0x0b
    361a:	48 2f       	mov	r20, r24
    361c:	4f 73       	andi	r20, 0x3F	; 63
    361e:	46 95       	lsr	r20
    3620:	46 95       	lsr	r20
    3622:	92 95       	swap	r25
    3624:	90 7f       	andi	r25, 0xF0	; 240
    3626:	49 2b       	or	r20, r25
    3628:	98 2f       	mov	r25, r24
    362a:	92 95       	swap	r25
    362c:	96 95       	lsr	r25
    362e:	96 95       	lsr	r25
    3630:	93 70       	andi	r25, 0x03	; 3
    3632:	34 85       	ldd	r19, Z+12	; 0x0c
    3634:	3f 70       	andi	r19, 0x0F	; 15
    3636:	33 0f       	add	r19, r19
    3638:	33 0f       	add	r19, r19
    363a:	39 2b       	or	r19, r25
    363c:	82 95       	swap	r24
    363e:	88 0f       	add	r24, r24
    3640:	88 0f       	add	r24, r24
    3642:	80 7c       	andi	r24, 0xC0	; 192
    3644:	38 2b       	or	r19, r24
    3646:	22 85       	ldd	r18, Z+10	; 0x0a
    3648:	62 85       	ldd	r22, Z+10	; 0x0a
    364a:	73 85       	ldd	r23, Z+11	; 0x0b
    364c:	84 85       	ldd	r24, Z+12	; 0x0c
    364e:	95 85       	ldd	r25, Z+13	; 0x0d
    3650:	5f 2d       	mov	r21, r15
    3652:	20 da       	rcall	.-3008   	; 0x2a94 <csp_conn_new>
    3654:	6c 01       	movw	r12, r24
    3656:	00 97       	sbiw	r24, 0x00	; 0
    3658:	21 f4       	brne	.+8      	; 0x3662 <csp_task_router+0x1a2>
    365a:	8d 81       	ldd	r24, Y+5	; 0x05
    365c:	9e 81       	ldd	r25, Y+6	; 0x06
    365e:	ad d8       	rcall	.-3750   	; 0x27ba <csp_buffer_free>
    3660:	35 cf       	rjmp	.-406    	; 0x34cc <csp_task_router+0xc>
    3662:	d8 01       	movw	r26, r16
    3664:	1e 96       	adiw	r26, 0x0e	; 14
    3666:	8d 91       	ld	r24, X+
    3668:	9c 91       	ld	r25, X
    366a:	1f 97       	sbiw	r26, 0x0f	; 15
    366c:	f6 01       	movw	r30, r12
    366e:	86 87       	std	Z+14, r24	; 0x0e
    3670:	97 87       	std	Z+15, r25	; 0x0f
    3672:	54 96       	adiw	r26, 0x14	; 20
    3674:	8d 91       	ld	r24, X+
    3676:	9d 91       	ld	r25, X+
    3678:	0d 90       	ld	r0, X+
    367a:	bc 91       	ld	r27, X
    367c:	a0 2d       	mov	r26, r0
    367e:	84 8b       	std	Z+20, r24	; 0x14
    3680:	95 8b       	std	Z+21, r25	; 0x15
    3682:	a6 8b       	std	Z+22, r26	; 0x16
    3684:	b7 8b       	std	Z+23, r27	; 0x17
    3686:	12 c0       	rjmp	.+36     	; 0x36ac <csp_task_router+0x1ec>
    3688:	2d 81       	ldd	r18, Y+5	; 0x05
    368a:	3e 81       	ldd	r19, Y+6	; 0x06
    368c:	49 81       	ldd	r20, Y+1	; 0x01
    368e:	5a 81       	ldd	r21, Y+2	; 0x02
    3690:	d6 01       	movw	r26, r12
    3692:	54 96       	adiw	r26, 0x14	; 20
    3694:	6d 91       	ld	r22, X+
    3696:	7d 91       	ld	r23, X+
    3698:	8d 91       	ld	r24, X+
    369a:	9c 91       	ld	r25, X
    369c:	57 97       	sbiw	r26, 0x17	; 23
    369e:	e5 dd       	rcall	.-1078   	; 0x326a <csp_route_security_check>
    36a0:	99 23       	and	r25, r25
    36a2:	24 f4       	brge	.+8      	; 0x36ac <csp_task_router+0x1ec>
    36a4:	8d 81       	ldd	r24, Y+5	; 0x05
    36a6:	9e 81       	ldd	r25, Y+6	; 0x06
    36a8:	88 d8       	rcall	.-3824   	; 0x27ba <csp_buffer_free>
    36aa:	10 cf       	rjmp	.-480    	; 0x34cc <csp_task_router+0xc>
    36ac:	8d 81       	ldd	r24, Y+5	; 0x05
    36ae:	9e 81       	ldd	r25, Y+6	; 0x06
    36b0:	fc 01       	movw	r30, r24
    36b2:	22 85       	ldd	r18, Z+10	; 0x0a
    36b4:	21 ff       	sbrs	r18, 1
    36b6:	10 c0       	rjmp	.+32     	; 0x36d8 <csp_task_router+0x218>
    36b8:	e9 81       	ldd	r30, Y+1	; 0x01
    36ba:	fa 81       	ldd	r31, Y+2	; 0x02
    36bc:	46 89       	ldd	r20, Z+22	; 0x16
    36be:	57 89       	ldd	r21, Z+23	; 0x17
    36c0:	60 8d       	ldd	r22, Z+24	; 0x18
    36c2:	71 8d       	ldd	r23, Z+25	; 0x19
    36c4:	4f 5f       	subi	r20, 0xFF	; 255
    36c6:	5f 4f       	sbci	r21, 0xFF	; 255
    36c8:	6f 4f       	sbci	r22, 0xFF	; 255
    36ca:	7f 4f       	sbci	r23, 0xFF	; 255
    36cc:	46 8b       	std	Z+22, r20	; 0x16
    36ce:	57 8b       	std	Z+23, r21	; 0x17
    36d0:	60 8f       	std	Z+24, r22	; 0x18
    36d2:	71 8f       	std	Z+25, r23	; 0x19
    36d4:	72 d8       	rcall	.-3868   	; 0x27ba <csp_buffer_free>
    36d6:	fa ce       	rjmp	.-524    	; 0x34cc <csp_task_router+0xc>
    36d8:	bc 01       	movw	r22, r24
    36da:	c6 01       	movw	r24, r12
    36dc:	8a d3       	rcall	.+1812   	; 0x3df2 <csp_udp_new_packet>
    36de:	f6 ce       	rjmp	.-532    	; 0x34cc <csp_task_router+0xc>
    36e0:	ed 81       	ldd	r30, Y+5	; 0x05
    36e2:	fe 81       	ldd	r31, Y+6	; 0x06
    36e4:	62 85       	ldd	r22, Z+10	; 0x0a
    36e6:	73 85       	ldd	r23, Z+11	; 0x0b
    36e8:	84 85       	ldd	r24, Z+12	; 0x0c
    36ea:	95 85       	ldd	r25, Z+13	; 0x0d
    36ec:	20 e0       	ldi	r18, 0x00	; 0
    36ee:	3f ef       	ldi	r19, 0xFF	; 255
    36f0:	4f ef       	ldi	r20, 0xFF	; 255
    36f2:	5f e3       	ldi	r21, 0x3F	; 63
    36f4:	0f d9       	rcall	.-3554   	; 0x2914 <csp_conn_find>
    36f6:	6c 01       	movw	r12, r24
    36f8:	00 97       	sbiw	r24, 0x00	; 0
    36fa:	31 f6       	brne	.-116    	; 0x3688 <csp_task_router+0x1c8>
    36fc:	62 cf       	rjmp	.-316    	; 0x35c2 <csp_task_router+0x102>
    36fe:	ed 81       	ldd	r30, Y+5	; 0x05
    3700:	fe 81       	ldd	r31, Y+6	; 0x06
    3702:	62 85       	ldd	r22, Z+10	; 0x0a
    3704:	73 85       	ldd	r23, Z+11	; 0x0b
    3706:	84 85       	ldd	r24, Z+12	; 0x0c
    3708:	95 85       	ldd	r25, Z+13	; 0x0d
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	3f ef       	ldi	r19, 0xFF	; 255
    370e:	4f ef       	ldi	r20, 0xFF	; 255
    3710:	5f e3       	ldi	r21, 0x3F	; 63
    3712:	00 d9       	rcall	.-3584   	; 0x2914 <csp_conn_find>
    3714:	6c 01       	movw	r12, r24
    3716:	00 97       	sbiw	r24, 0x00	; 0
    3718:	09 f0       	breq	.+2      	; 0x371c <csp_task_router+0x25c>
    371a:	b6 cf       	rjmp	.-148    	; 0x3688 <csp_task_router+0x1c8>
    371c:	56 cf       	rjmp	.-340    	; 0x35ca <csp_task_router+0x10a>

0000371e <csp_route_enqueue>:
    371e:	0f 93       	push	r16
    3720:	1f 93       	push	r17
    3722:	01 15       	cp	r16, r1
    3724:	11 05       	cpc	r17, r1
    3726:	19 f4       	brne	.+6      	; 0x372e <csp_route_enqueue+0x10>
    3728:	0e 94 ca 11 	call	0x2394	; 0x2394 <csp_queue_enqueue>
    372c:	03 c0       	rjmp	.+6      	; 0x3734 <csp_route_enqueue+0x16>
    372e:	a8 01       	movw	r20, r16
    3730:	0e 94 d5 11 	call	0x23aa	; 0x23aa <csp_queue_enqueue_isr>
    3734:	01 97       	sbiw	r24, 0x01	; 1
    3736:	19 f4       	brne	.+6      	; 0x373e <csp_route_enqueue+0x20>
    3738:	80 e0       	ldi	r24, 0x00	; 0
    373a:	90 e0       	ldi	r25, 0x00	; 0
    373c:	02 c0       	rjmp	.+4      	; 0x3742 <csp_route_enqueue+0x24>
    373e:	87 ef       	ldi	r24, 0xF7	; 247
    3740:	9f ef       	ldi	r25, 0xFF	; 255
    3742:	1f 91       	pop	r17
    3744:	0f 91       	pop	r16
    3746:	08 95       	ret

00003748 <csp_new_packet>:

void csp_new_packet(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    3748:	af 92       	push	r10
    374a:	bf 92       	push	r11
    374c:	cf 92       	push	r12
    374e:	df 92       	push	r13
    3750:	ef 92       	push	r14
    3752:	ff 92       	push	r15
    3754:	0f 93       	push	r16
    3756:	1f 93       	push	r17
    3758:	cf 93       	push	r28
    375a:	df 93       	push	r29
    375c:	00 d0       	rcall	.+0      	; 0x375e <csp_new_packet+0x16>
    375e:	1f 92       	push	r1
    3760:	cd b7       	in	r28, 0x3d	; 61
    3762:	de b7       	in	r29, 0x3e	; 62
    3764:	6c 01       	movw	r12, r24
    3766:	7b 01       	movw	r14, r22
    3768:	5a 01       	movw	r10, r20

	int result, fifo;

	if (packet == NULL) {
    376a:	00 97       	sbiw	r24, 0x00	; 0
    376c:	09 f4       	brne	.+2      	; 0x3770 <csp_new_packet+0x28>
    376e:	50 c0       	rjmp	.+160    	; 0x3810 <csp_new_packet+0xc8>
		csp_log_warn("csp_new packet called with NULL packet\r\n");
		return;
	} else if (interface == NULL) {
    3770:	61 15       	cp	r22, r1
    3772:	71 05       	cpc	r23, r1
    3774:	41 f4       	brne	.+16     	; 0x3786 <csp_new_packet+0x3e>
		csp_log_warn("csp_new packet called with NULL interface\r\n");
		if (pxTaskWoken == NULL)
    3776:	41 15       	cp	r20, r1
    3778:	51 05       	cpc	r21, r1
    377a:	11 f4       	brne	.+4      	; 0x3780 <csp_new_packet+0x38>
			csp_buffer_free(packet);
    377c:	1e d8       	rcall	.-4036   	; 0x27ba <csp_buffer_free>
    377e:	48 c0       	rjmp	.+144    	; 0x3810 <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    3780:	0e 94 a5 13 	call	0x274a	; 0x274a <csp_buffer_free_isr>
    3784:	45 c0       	rjmp	.+138    	; 0x3810 <csp_new_packet+0xc8>
		return;
	}

	csp_route_queue_t queue_element;
	queue_element.interface = interface;
    3786:	69 83       	std	Y+1, r22	; 0x01
    3788:	7a 83       	std	Y+2, r23	; 0x02
	queue_element.outcomingPacket = packet;
    378a:	8b 83       	std	Y+3, r24	; 0x03
    378c:	9c 83       	std	Y+4, r25	; 0x04

	fifo = csp_route_get_fifo(packet->id.pri);
	result = csp_route_enqueue(router_input_fifo[fifo], &queue_element, 0, pxTaskWoken);
    378e:	8a 01       	movw	r16, r20
    3790:	20 e0       	ldi	r18, 0x00	; 0
    3792:	30 e0       	ldi	r19, 0x00	; 0
    3794:	a9 01       	movw	r20, r18
    3796:	be 01       	movw	r22, r28
    3798:	6f 5f       	subi	r22, 0xFF	; 255
    379a:	7f 4f       	sbci	r23, 0xFF	; 255
    379c:	80 91 6c 3e 	lds	r24, 0x3E6C
    37a0:	90 91 6d 3e 	lds	r25, 0x3E6D
    37a4:	bc df       	rcall	.-136    	; 0x371e <csp_route_enqueue>

	if (result != CSP_ERR_NONE) {
    37a6:	89 2b       	or	r24, r25
    37a8:	b1 f0       	breq	.+44     	; 0x37d6 <csp_new_packet+0x8e>
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.\r\n");
		interface->drop++;
    37aa:	f7 01       	movw	r30, r14
    37ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    37ae:	93 8d       	ldd	r25, Z+27	; 0x1b
    37b0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    37b2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    37b4:	01 96       	adiw	r24, 0x01	; 1
    37b6:	a1 1d       	adc	r26, r1
    37b8:	b1 1d       	adc	r27, r1
    37ba:	82 8f       	std	Z+26, r24	; 0x1a
    37bc:	93 8f       	std	Z+27, r25	; 0x1b
    37be:	a4 8f       	std	Z+28, r26	; 0x1c
    37c0:	b5 8f       	std	Z+29, r27	; 0x1d
		if (pxTaskWoken == NULL)
    37c2:	ab 28       	or	r10, r11
    37c4:	21 f4       	brne	.+8      	; 0x37ce <csp_new_packet+0x86>
			csp_buffer_free(packet);
    37c6:	c6 01       	movw	r24, r12
    37c8:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
    37cc:	21 c0       	rjmp	.+66     	; 0x3810 <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    37ce:	c6 01       	movw	r24, r12
    37d0:	0e 94 a5 13 	call	0x274a	; 0x274a <csp_buffer_free_isr>
    37d4:	1d c0       	rjmp	.+58     	; 0x3810 <csp_new_packet+0xc8>
	} else {
		interface->rx++;
    37d6:	f7 01       	movw	r30, r14
    37d8:	46 85       	ldd	r20, Z+14	; 0x0e
    37da:	57 85       	ldd	r21, Z+15	; 0x0f
    37dc:	60 89       	ldd	r22, Z+16	; 0x10
    37de:	71 89       	ldd	r23, Z+17	; 0x11
    37e0:	4f 5f       	subi	r20, 0xFF	; 255
    37e2:	5f 4f       	sbci	r21, 0xFF	; 255
    37e4:	6f 4f       	sbci	r22, 0xFF	; 255
    37e6:	7f 4f       	sbci	r23, 0xFF	; 255
    37e8:	46 87       	std	Z+14, r20	; 0x0e
    37ea:	57 87       	std	Z+15, r21	; 0x0f
    37ec:	60 8b       	std	Z+16, r22	; 0x10
    37ee:	71 8b       	std	Z+17, r23	; 0x11
		interface->rxbytes += packet->length;
    37f0:	f6 01       	movw	r30, r12
    37f2:	20 85       	ldd	r18, Z+8	; 0x08
    37f4:	31 85       	ldd	r19, Z+9	; 0x09
    37f6:	f7 01       	movw	r30, r14
    37f8:	82 a5       	ldd	r24, Z+42	; 0x2a
    37fa:	93 a5       	ldd	r25, Z+43	; 0x2b
    37fc:	a4 a5       	ldd	r26, Z+44	; 0x2c
    37fe:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3800:	82 0f       	add	r24, r18
    3802:	93 1f       	adc	r25, r19
    3804:	a1 1d       	adc	r26, r1
    3806:	b1 1d       	adc	r27, r1
    3808:	82 a7       	std	Z+42, r24	; 0x2a
    380a:	93 a7       	std	Z+43, r25	; 0x2b
    380c:	a4 a7       	std	Z+44, r26	; 0x2c
    380e:	b5 a7       	std	Z+45, r27	; 0x2d
	}

}
    3810:	24 96       	adiw	r28, 0x04	; 4
    3812:	cd bf       	out	0x3d, r28	; 61
    3814:	de bf       	out	0x3e, r29	; 62
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	1f 91       	pop	r17
    381c:	0f 91       	pop	r16
    381e:	ff 90       	pop	r15
    3820:	ef 90       	pop	r14
    3822:	df 90       	pop	r13
    3824:	cf 90       	pop	r12
    3826:	bf 90       	pop	r11
    3828:	af 90       	pop	r10
    382a:	08 95       	ret

0000382c <csp_route_get_nexthop_mac>:

uint8_t csp_route_get_nexthop_mac(uint8_t node) {

	csp_route_t * route = csp_route_if(node);
    382c:	2f de       	rcall	.-930    	; 0x348c <csp_route_if>
	return route->nexthop_mac_addr;

}
    382e:	fc 01       	movw	r30, r24
    3830:	82 81       	ldd	r24, Z+2	; 0x02
    3832:	08 95       	ret

00003834 <csp_cmp_handler>:
	return CSP_ERR_NONE;

}

/* CSP Management Protocol handler */
int csp_cmp_handler(csp_conn_t * conn, csp_packet_t * packet) {
    3834:	0f 93       	push	r16
    3836:	1f 93       	push	r17
    3838:	cf 93       	push	r28
    383a:	df 93       	push	r29
    383c:	eb 01       	movw	r28, r22

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    383e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3840:	81 11       	cpse	r24, r1
    3842:	55 c1       	rjmp	.+682    	; 0x3aee <csp_cmp_handler+0x2ba>
		return ret;

	switch (cmp->code) {
    3844:	8f 85       	ldd	r24, Y+15	; 0x0f
    3846:	83 30       	cpi	r24, 0x03	; 3
    3848:	09 f4       	brne	.+2      	; 0x384c <csp_cmp_handler+0x18>
    384a:	6d c0       	rjmp	.+218    	; 0x3926 <csp_cmp_handler+0xf2>
    384c:	30 f4       	brcc	.+12     	; 0x385a <csp_cmp_handler+0x26>
    384e:	81 30       	cpi	r24, 0x01	; 1
    3850:	69 f0       	breq	.+26     	; 0x386c <csp_cmp_handler+0x38>
    3852:	82 30       	cpi	r24, 0x02	; 2
    3854:	09 f4       	brne	.+2      	; 0x3858 <csp_cmp_handler+0x24>
    3856:	4f c0       	rjmp	.+158    	; 0x38f6 <csp_cmp_handler+0xc2>
    3858:	45 c1       	rjmp	.+650    	; 0x3ae4 <csp_cmp_handler+0x2b0>
    385a:	85 30       	cpi	r24, 0x05	; 5
    385c:	09 f4       	brne	.+2      	; 0x3860 <csp_cmp_handler+0x2c>
    385e:	f1 c0       	rjmp	.+482    	; 0x3a42 <csp_cmp_handler+0x20e>
    3860:	08 f4       	brcc	.+2      	; 0x3864 <csp_cmp_handler+0x30>
    3862:	d8 c0       	rjmp	.+432    	; 0x3a14 <csp_cmp_handler+0x1e0>
    3864:	86 30       	cpi	r24, 0x06	; 6
    3866:	09 f4       	brne	.+2      	; 0x386a <csp_cmp_handler+0x36>
    3868:	06 c1       	rjmp	.+524    	; 0x3a76 <csp_cmp_handler+0x242>
    386a:	3c c1       	rjmp	.+632    	; 0x3ae4 <csp_cmp_handler+0x2b0>
#define CSP_RPS_MTU	196

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, GIT_REV, CSP_CMP_IDENT_REV_LEN);
    386c:	44 e1       	ldi	r20, 0x14	; 20
    386e:	50 e0       	ldi	r21, 0x00	; 0
    3870:	62 e9       	ldi	r22, 0x92	; 146
    3872:	70 e2       	ldi	r23, 0x20	; 32
    3874:	ce 01       	movw	r24, r28
    3876:	8e 5b       	subi	r24, 0xBE	; 190
    3878:	9f 4f       	sbci	r25, 0xFF	; 255
    387a:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    387e:	fe 01       	movw	r30, r28
    3880:	eb 5a       	subi	r30, 0xAB	; 171
    3882:	ff 4f       	sbci	r31, 0xFF	; 255
    3884:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    3886:	8c e0       	ldi	r24, 0x0C	; 12
    3888:	ea e9       	ldi	r30, 0x9A	; 154
    388a:	f0 e2       	ldi	r31, 0x20	; 32
    388c:	de 01       	movw	r26, r28
    388e:	aa 5a       	subi	r26, 0xAA	; 170
    3890:	bf 4f       	sbci	r27, 0xFF	; 255
    3892:	01 90       	ld	r0, Z+
    3894:	0d 92       	st	X+, r0
    3896:	8a 95       	dec	r24
    3898:	e1 f7       	brne	.-8      	; 0x3892 <csp_cmp_handler+0x5e>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    389a:	fe 01       	movw	r30, r28
    389c:	ef 59       	subi	r30, 0x9F	; 159
    389e:	ff 4f       	sbci	r31, 0xFF	; 255
    38a0:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    38a2:	89 e0       	ldi	r24, 0x09	; 9
    38a4:	e6 ea       	ldi	r30, 0xA6	; 166
    38a6:	f0 e2       	ldi	r31, 0x20	; 32
    38a8:	de 01       	movw	r26, r28
    38aa:	ae 59       	subi	r26, 0x9E	; 158
    38ac:	bf 4f       	sbci	r27, 0xFF	; 255
    38ae:	01 90       	ld	r0, Z+
    38b0:	0d 92       	st	X+, r0
    38b2:	8a 95       	dec	r24
    38b4:	e1 f7       	brne	.-8      	; 0x38ae <csp_cmp_handler+0x7a>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    38b6:	fe 01       	movw	r30, r28
    38b8:	e6 59       	subi	r30, 0x96	; 150
    38ba:	ff 4f       	sbci	r31, 0xFF	; 255
    38bc:	10 82       	st	Z, r1

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    38be:	70 da       	rcall	.-2848   	; 0x2da0 <csp_get_hostname>
    38c0:	44 e1       	ldi	r20, 0x14	; 20
    38c2:	50 e0       	ldi	r21, 0x00	; 0
    38c4:	bc 01       	movw	r22, r24
    38c6:	ce 01       	movw	r24, r28
    38c8:	40 96       	adiw	r24, 0x10	; 16
    38ca:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';
    38ce:	1b a2       	std	Y+35, r1	; 0x23

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    38d0:	6c da       	rcall	.-2856   	; 0x2daa <csp_get_model>
    38d2:	4e e1       	ldi	r20, 0x1E	; 30
    38d4:	50 e0       	ldi	r21, 0x00	; 0
    38d6:	bc 01       	movw	r22, r24
    38d8:	ce 01       	movw	r24, r28
    38da:	84 96       	adiw	r24, 0x24	; 36
    38dc:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    38e0:	fe 01       	movw	r30, r28
    38e2:	ef 5b       	subi	r30, 0xBF	; 191
    38e4:	ff 4f       	sbci	r31, 0xFF	; 255
    38e6:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    38e8:	8d e5       	ldi	r24, 0x5D	; 93
    38ea:	90 e0       	ldi	r25, 0x00	; 0
    38ec:	88 87       	std	Y+8, r24	; 0x08
    38ee:	99 87       	std	Y+9, r25	; 0x09
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
    38f0:	80 e0       	ldi	r24, 0x00	; 0
    38f2:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;
    38f4:	f9 c0       	rjmp	.+498    	; 0x3ae8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
    38f6:	cb 01       	movw	r24, r22
    38f8:	42 96       	adiw	r24, 0x12	; 18
    38fa:	30 dd       	rcall	.-1440   	; 0x335c <csp_route_get_if_by_name>
	if (ifc == NULL)
    38fc:	00 97       	sbiw	r24, 0x00	; 0
    38fe:	49 f0       	breq	.+18     	; 0x3912 <csp_cmp_handler+0xde>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    3900:	49 89       	ldd	r20, Y+17	; 0x11
    3902:	bc 01       	movw	r22, r24
    3904:	88 89       	ldd	r24, Y+16	; 0x10
    3906:	72 dd       	rcall	.-1308   	; 0x33ec <csp_route_set>
    3908:	89 2b       	or	r24, r25
    390a:	31 f0       	breq	.+12     	; 0x3918 <csp_cmp_handler+0xe4>
		return CSP_ERR_INVAL;
    390c:	8e ef       	ldi	r24, 0xFE	; 254
    390e:	9f ef       	ldi	r25, 0xFF	; 255
    3910:	05 c0       	rjmp	.+10     	; 0x391c <csp_cmp_handler+0xe8>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    3912:	8e ef       	ldi	r24, 0xFE	; 254
    3914:	9f ef       	ldi	r25, 0xFF	; 255
    3916:	02 c0       	rjmp	.+4      	; 0x391c <csp_cmp_handler+0xe8>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    3918:	80 e0       	ldi	r24, 0x00	; 0
    391a:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    391c:	2f e0       	ldi	r18, 0x0F	; 15
    391e:	30 e0       	ldi	r19, 0x00	; 0
    3920:	28 87       	std	Y+8, r18	; 0x08
    3922:	39 87       	std	Y+9, r19	; 0x09
			break;
    3924:	e1 c0       	rjmp	.+450    	; 0x3ae8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
    3926:	cb 01       	movw	r24, r22
    3928:	40 96       	adiw	r24, 0x10	; 16
    392a:	18 dd       	rcall	.-1488   	; 0x335c <csp_route_get_if_by_name>
    392c:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    392e:	00 97       	sbiw	r24, 0x00	; 0
    3930:	09 f4       	brne	.+2      	; 0x3934 <csp_cmp_handler+0x100>
    3932:	69 c0       	rjmp	.+210    	; 0x3a06 <csp_cmp_handler+0x1d2>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    3934:	fc 01       	movw	r30, r24
    3936:	62 85       	ldd	r22, Z+10	; 0x0a
    3938:	73 85       	ldd	r23, Z+11	; 0x0b
    393a:	84 85       	ldd	r24, Z+12	; 0x0c
    393c:	95 85       	ldd	r25, Z+13	; 0x0d
    393e:	c6 d9       	rcall	.-3188   	; 0x2ccc <csp_hton32>
    3940:	6b 8f       	std	Y+27, r22	; 0x1b
    3942:	7c 8f       	std	Y+28, r23	; 0x1c
    3944:	8d 8f       	std	Y+29, r24	; 0x1d
    3946:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    3948:	f8 01       	movw	r30, r16
    394a:	66 85       	ldd	r22, Z+14	; 0x0e
    394c:	77 85       	ldd	r23, Z+15	; 0x0f
    394e:	80 89       	ldd	r24, Z+16	; 0x10
    3950:	91 89       	ldd	r25, Z+17	; 0x11
    3952:	bc d9       	rcall	.-3208   	; 0x2ccc <csp_hton32>
    3954:	6f 8f       	std	Y+31, r22	; 0x1f
    3956:	78 a3       	std	Y+32, r23	; 0x20
    3958:	89 a3       	std	Y+33, r24	; 0x21
    395a:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    395c:	f8 01       	movw	r30, r16
    395e:	62 89       	ldd	r22, Z+18	; 0x12
    3960:	73 89       	ldd	r23, Z+19	; 0x13
    3962:	84 89       	ldd	r24, Z+20	; 0x14
    3964:	95 89       	ldd	r25, Z+21	; 0x15
    3966:	b2 d9       	rcall	.-3228   	; 0x2ccc <csp_hton32>
    3968:	6b a3       	std	Y+35, r22	; 0x23
    396a:	7c a3       	std	Y+36, r23	; 0x24
    396c:	8d a3       	std	Y+37, r24	; 0x25
    396e:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    3970:	f8 01       	movw	r30, r16
    3972:	66 89       	ldd	r22, Z+22	; 0x16
    3974:	77 89       	ldd	r23, Z+23	; 0x17
    3976:	80 8d       	ldd	r24, Z+24	; 0x18
    3978:	91 8d       	ldd	r25, Z+25	; 0x19
    397a:	a8 d9       	rcall	.-3248   	; 0x2ccc <csp_hton32>
    397c:	6f a3       	std	Y+39, r22	; 0x27
    397e:	78 a7       	std	Y+40, r23	; 0x28
    3980:	89 a7       	std	Y+41, r24	; 0x29
    3982:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    3984:	f8 01       	movw	r30, r16
    3986:	62 8d       	ldd	r22, Z+26	; 0x1a
    3988:	73 8d       	ldd	r23, Z+27	; 0x1b
    398a:	84 8d       	ldd	r24, Z+28	; 0x1c
    398c:	95 8d       	ldd	r25, Z+29	; 0x1d
    398e:	9e d9       	rcall	.-3268   	; 0x2ccc <csp_hton32>
    3990:	6b a7       	std	Y+43, r22	; 0x2b
    3992:	7c a7       	std	Y+44, r23	; 0x2c
    3994:	8d a7       	std	Y+45, r24	; 0x2d
    3996:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    3998:	f8 01       	movw	r30, r16
    399a:	66 8d       	ldd	r22, Z+30	; 0x1e
    399c:	77 8d       	ldd	r23, Z+31	; 0x1f
    399e:	80 a1       	ldd	r24, Z+32	; 0x20
    39a0:	91 a1       	ldd	r25, Z+33	; 0x21
    39a2:	94 d9       	rcall	.-3288   	; 0x2ccc <csp_hton32>
    39a4:	6f a7       	std	Y+47, r22	; 0x2f
    39a6:	78 ab       	std	Y+48, r23	; 0x30
    39a8:	89 ab       	std	Y+49, r24	; 0x31
    39aa:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    39ac:	f8 01       	movw	r30, r16
    39ae:	62 a1       	ldd	r22, Z+34	; 0x22
    39b0:	73 a1       	ldd	r23, Z+35	; 0x23
    39b2:	84 a1       	ldd	r24, Z+36	; 0x24
    39b4:	95 a1       	ldd	r25, Z+37	; 0x25
    39b6:	8a d9       	rcall	.-3308   	; 0x2ccc <csp_hton32>
    39b8:	6b ab       	std	Y+51, r22	; 0x33
    39ba:	7c ab       	std	Y+52, r23	; 0x34
    39bc:	8d ab       	std	Y+53, r24	; 0x35
    39be:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    39c0:	f8 01       	movw	r30, r16
    39c2:	66 a1       	ldd	r22, Z+38	; 0x26
    39c4:	77 a1       	ldd	r23, Z+39	; 0x27
    39c6:	80 a5       	ldd	r24, Z+40	; 0x28
    39c8:	91 a5       	ldd	r25, Z+41	; 0x29
    39ca:	80 d9       	rcall	.-3328   	; 0x2ccc <csp_hton32>
    39cc:	6f ab       	std	Y+55, r22	; 0x37
    39ce:	78 af       	std	Y+56, r23	; 0x38
    39d0:	89 af       	std	Y+57, r24	; 0x39
    39d2:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    39d4:	f8 01       	movw	r30, r16
    39d6:	62 a5       	ldd	r22, Z+42	; 0x2a
    39d8:	73 a5       	ldd	r23, Z+43	; 0x2b
    39da:	84 a5       	ldd	r24, Z+44	; 0x2c
    39dc:	95 a5       	ldd	r25, Z+45	; 0x2d
    39de:	76 d9       	rcall	.-3348   	; 0x2ccc <csp_hton32>
    39e0:	6b af       	std	Y+59, r22	; 0x3b
    39e2:	7c af       	std	Y+60, r23	; 0x3c
    39e4:	8d af       	std	Y+61, r24	; 0x3d
    39e6:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    39e8:	f8 01       	movw	r30, r16
    39ea:	66 a5       	ldd	r22, Z+46	; 0x2e
    39ec:	77 a5       	ldd	r23, Z+47	; 0x2f
    39ee:	80 a9       	ldd	r24, Z+48	; 0x30
    39f0:	91 a9       	ldd	r25, Z+49	; 0x31
    39f2:	6c d9       	rcall	.-3368   	; 0x2ccc <csp_hton32>
    39f4:	fe 01       	movw	r30, r28
    39f6:	ff 96       	adiw	r30, 0x3f	; 63
    39f8:	60 83       	st	Z, r22
    39fa:	71 83       	std	Z+1, r23	; 0x01
    39fc:	82 83       	std	Z+2, r24	; 0x02
    39fe:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    3a00:	80 e0       	ldi	r24, 0x00	; 0
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	02 c0       	rjmp	.+4      	; 0x3a0a <csp_cmp_handler+0x1d6>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    3a06:	8e ef       	ldi	r24, 0xFE	; 254
    3a08:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    3a0a:	25 e3       	ldi	r18, 0x35	; 53
    3a0c:	30 e0       	ldi	r19, 0x00	; 0
    3a0e:	28 87       	std	Y+8, r18	; 0x08
    3a10:	39 87       	std	Y+9, r19	; 0x09
			break;
    3a12:	6a c0       	rjmp	.+212    	; 0x3ae8 <csp_cmp_handler+0x2b4>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    3a14:	68 89       	ldd	r22, Y+16	; 0x10
    3a16:	79 89       	ldd	r23, Y+17	; 0x11
    3a18:	8a 89       	ldd	r24, Y+18	; 0x12
    3a1a:	9b 89       	ldd	r25, Y+19	; 0x13
    3a1c:	57 d9       	rcall	.-3410   	; 0x2ccc <csp_hton32>
    3a1e:	68 8b       	std	Y+16, r22	; 0x10
    3a20:	79 8b       	std	Y+17, r23	; 0x11
    3a22:	8a 8b       	std	Y+18, r24	; 0x12
    3a24:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    3a26:	4c 89       	ldd	r20, Y+20	; 0x14
    3a28:	49 3c       	cpi	r20, 0xC9	; 201
    3a2a:	40 f4       	brcc	.+16     	; 0x3a3c <csp_cmp_handler+0x208>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	memcpy(cmp->peek.data, (void *) (uintptr_t) cmp->peek.addr, cmp->peek.len);
    3a2c:	50 e0       	ldi	r21, 0x00	; 0
    3a2e:	ce 01       	movw	r24, r28
    3a30:	45 96       	adiw	r24, 0x15	; 21
    3a32:	0e 94 56 2d 	call	0x5aac	; 0x5aac <memcpy>

	return CSP_ERR_NONE;
    3a36:	80 e0       	ldi	r24, 0x00	; 0
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	56 c0       	rjmp	.+172    	; 0x3ae8 <csp_cmp_handler+0x2b4>

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
		return CSP_ERR_INVAL;
    3a3c:	8e ef       	ldi	r24, 0xFE	; 254
    3a3e:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(if_stats);
			break;

		case CSP_CMP_PEEK:
			ret = do_cmp_peek(cmp);
			break;
    3a40:	53 c0       	rjmp	.+166    	; 0x3ae8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    3a42:	68 89       	ldd	r22, Y+16	; 0x10
    3a44:	79 89       	ldd	r23, Y+17	; 0x11
    3a46:	8a 89       	ldd	r24, Y+18	; 0x12
    3a48:	9b 89       	ldd	r25, Y+19	; 0x13
    3a4a:	40 d9       	rcall	.-3456   	; 0x2ccc <csp_hton32>
    3a4c:	dc 01       	movw	r26, r24
    3a4e:	cb 01       	movw	r24, r22
    3a50:	88 8b       	std	Y+16, r24	; 0x10
    3a52:	99 8b       	std	Y+17, r25	; 0x11
    3a54:	aa 8b       	std	Y+18, r26	; 0x12
    3a56:	bb 8b       	std	Y+19, r27	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    3a58:	4c 89       	ldd	r20, Y+20	; 0x14
    3a5a:	49 3c       	cpi	r20, 0xC9	; 201
    3a5c:	48 f4       	brcc	.+18     	; 0x3a70 <csp_cmp_handler+0x23c>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	memcpy((void *) (uintptr_t) cmp->poke.addr, cmp->poke.data, cmp->poke.len);
    3a5e:	50 e0       	ldi	r21, 0x00	; 0
    3a60:	be 01       	movw	r22, r28
    3a62:	6b 5e       	subi	r22, 0xEB	; 235
    3a64:	7f 4f       	sbci	r23, 0xFF	; 255
    3a66:	0e 94 56 2d 	call	0x5aac	; 0x5aac <memcpy>

	return CSP_ERR_NONE;
    3a6a:	80 e0       	ldi	r24, 0x00	; 0
    3a6c:	90 e0       	ldi	r25, 0x00	; 0
    3a6e:	3c c0       	rjmp	.+120    	; 0x3ae8 <csp_cmp_handler+0x2b4>

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
		return CSP_ERR_INVAL;
    3a70:	8e ef       	ldi	r24, 0xFE	; 254
    3a72:	9f ef       	ldi	r25, 0xFF	; 255
			ret = do_cmp_peek(cmp);
			break;

		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;
    3a74:	39 c0       	rjmp	.+114    	; 0x3ae8 <csp_cmp_handler+0x2b4>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    3a76:	68 89       	ldd	r22, Y+16	; 0x10
    3a78:	79 89       	ldd	r23, Y+17	; 0x11
    3a7a:	8a 89       	ldd	r24, Y+18	; 0x12
    3a7c:	9b 89       	ldd	r25, Y+19	; 0x13
    3a7e:	5b d9       	rcall	.-3402   	; 0x2d36 <csp_ntoh32>
    3a80:	68 8b       	std	Y+16, r22	; 0x10
    3a82:	79 8b       	std	Y+17, r23	; 0x11
    3a84:	8a 8b       	std	Y+18, r24	; 0x12
    3a86:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    3a88:	6c 89       	ldd	r22, Y+20	; 0x14
    3a8a:	7d 89       	ldd	r23, Y+21	; 0x15
    3a8c:	8e 89       	ldd	r24, Y+22	; 0x16
    3a8e:	9f 89       	ldd	r25, Y+23	; 0x17
    3a90:	52 d9       	rcall	.-3420   	; 0x2d36 <csp_ntoh32>
    3a92:	6c 8b       	std	Y+20, r22	; 0x14
    3a94:	7d 8b       	std	Y+21, r23	; 0x15
    3a96:	8e 8b       	std	Y+22, r24	; 0x16
    3a98:	9f 8b       	std	Y+23, r25	; 0x17

	if (cmp->clock.tv_sec != 0) {
    3a9a:	88 89       	ldd	r24, Y+16	; 0x10
    3a9c:	99 89       	ldd	r25, Y+17	; 0x11
    3a9e:	aa 89       	ldd	r26, Y+18	; 0x12
    3aa0:	bb 89       	ldd	r27, Y+19	; 0x13
    3aa2:	89 2b       	or	r24, r25
    3aa4:	8a 2b       	or	r24, r26
    3aa6:	8b 2b       	or	r24, r27
    3aa8:	21 f0       	breq	.+8      	; 0x3ab2 <csp_cmp_handler+0x27e>
		clock_set_time(&cmp->clock);
    3aaa:	ce 01       	movw	r24, r28
    3aac:	40 96       	adiw	r24, 0x10	; 16
    3aae:	0e 94 a2 04 	call	0x944	; 0x944 <clock_set_time>
	}

	clock_get_time(&cmp->clock);
    3ab2:	ce 01       	movw	r24, r28
    3ab4:	40 96       	adiw	r24, 0x10	; 16
    3ab6:	0e 94 a1 04 	call	0x942	; 0x942 <clock_get_time>
	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    3aba:	68 89       	ldd	r22, Y+16	; 0x10
    3abc:	79 89       	ldd	r23, Y+17	; 0x11
    3abe:	8a 89       	ldd	r24, Y+18	; 0x12
    3ac0:	9b 89       	ldd	r25, Y+19	; 0x13
    3ac2:	04 d9       	rcall	.-3576   	; 0x2ccc <csp_hton32>
    3ac4:	68 8b       	std	Y+16, r22	; 0x10
    3ac6:	79 8b       	std	Y+17, r23	; 0x11
    3ac8:	8a 8b       	std	Y+18, r24	; 0x12
    3aca:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    3acc:	6c 89       	ldd	r22, Y+20	; 0x14
    3ace:	7d 89       	ldd	r23, Y+21	; 0x15
    3ad0:	8e 89       	ldd	r24, Y+22	; 0x16
    3ad2:	9f 89       	ldd	r25, Y+23	; 0x17
    3ad4:	fb d8       	rcall	.-3594   	; 0x2ccc <csp_hton32>
    3ad6:	6c 8b       	std	Y+20, r22	; 0x14
    3ad8:	7d 8b       	std	Y+21, r23	; 0x15
    3ada:	8e 8b       	std	Y+22, r24	; 0x16
    3adc:	9f 8b       	std	Y+23, r25	; 0x17
		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;

		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
    3ade:	80 e0       	ldi	r24, 0x00	; 0
    3ae0:	90 e0       	ldi	r25, 0x00	; 0
			break;
    3ae2:	02 c0       	rjmp	.+4      	; 0x3ae8 <csp_cmp_handler+0x2b4>

		default:
			ret = CSP_ERR_INVAL;
    3ae4:	8e ef       	ldi	r24, 0xFE	; 254
    3ae6:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    3ae8:	2f ef       	ldi	r18, 0xFF	; 255
    3aea:	2e 87       	std	Y+14, r18	; 0x0e

	return ret;
    3aec:	02 c0       	rjmp	.+4      	; 0x3af2 <csp_cmp_handler+0x2be>
	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;
    3aee:	8e ef       	ldi	r24, 0xFE	; 254
    3af0:	9f ef       	ldi	r25, 0xFF	; 255
	}

	cmp->type = CSP_CMP_REPLY;

	return ret;
}
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	1f 91       	pop	r17
    3af8:	0f 91       	pop	r16
    3afa:	08 95       	ret

00003afc <csp_service_handler>:

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    3afc:	af 92       	push	r10
    3afe:	bf 92       	push	r11
    3b00:	cf 92       	push	r12
    3b02:	df 92       	push	r13
    3b04:	ef 92       	push	r14
    3b06:	ff 92       	push	r15
    3b08:	0f 93       	push	r16
    3b0a:	1f 93       	push	r17
    3b0c:	cf 93       	push	r28
    3b0e:	df 93       	push	r29
    3b10:	8c 01       	movw	r16, r24
    3b12:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    3b14:	12 d8       	rcall	.-4060   	; 0x2b3a <csp_conn_dport>
    3b16:	87 30       	cpi	r24, 0x07	; 7
    3b18:	91 05       	cpc	r25, r1
    3b1a:	08 f0       	brcs	.+2      	; 0x3b1e <csp_service_handler+0x22>
    3b1c:	90 c0       	rjmp	.+288    	; 0x3c3e <csp_service_handler+0x142>
    3b1e:	fc 01       	movw	r30, r24
    3b20:	e2 50       	subi	r30, 0x02	; 2
    3b22:	ff 4f       	sbci	r31, 0xFF	; 255
    3b24:	0c 94 e6 2b 	jmp	0x57cc	; 0x57cc <__tablejump2__>

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    3b28:	be 01       	movw	r22, r28
    3b2a:	c8 01       	movw	r24, r16
    3b2c:	83 de       	rcall	.-762    	; 0x3834 <csp_cmp_handler>
    3b2e:	89 2b       	or	r24, r25
    3b30:	09 f4       	brne	.+2      	; 0x3b34 <csp_service_handler+0x38>
    3b32:	89 c0       	rjmp	.+274    	; 0x3c46 <csp_service_handler+0x14a>
			csp_buffer_free(packet);
    3b34:	ce 01       	movw	r24, r28
    3b36:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
			return;
    3b3a:	92 c0       	rjmp	.+292    	; 0x3c60 <csp_service_handler+0x164>
		break;

	case CSP_PS: {

		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    3b3c:	0e 94 39 12 	call	0x2472	; 0x2472 <csp_sys_tasklist_size>
    3b40:	7c 01       	movw	r14, r24
		char * pslist = csp_malloc(task_list_size);
    3b42:	0e 94 c1 11 	call	0x2382	; 0x2382 <csp_malloc>
    3b46:	5c 01       	movw	r10, r24

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    3b48:	0e 94 35 12 	call	0x246a	; 0x246a <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    3b4c:	b7 01       	movw	r22, r14
    3b4e:	c5 01       	movw	r24, r10
    3b50:	0e 94 95 2d 	call	0x5b2a	; 0x5b2a <strnlen>
    3b54:	6c 01       	movw	r12, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    3b56:	18 16       	cp	r1, r24
    3b58:	19 06       	cpc	r1, r25
    3b5a:	0c f0       	brlt	.+2      	; 0x3b5e <csp_service_handler+0x62>
    3b5c:	74 c0       	rjmp	.+232    	; 0x3c46 <csp_service_handler+0x14a>
		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
    3b5e:	e1 2c       	mov	r14, r1
    3b60:	f1 2c       	mov	r15, r1
		while(i < pslen) {

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    3b62:	20 97       	sbiw	r28, 0x00	; 0
    3b64:	41 f4       	brne	.+16     	; 0x3b76 <csp_service_handler+0x7a>
				packet = csp_buffer_get(CSP_RPS_MTU);
    3b66:	84 ec       	ldi	r24, 0xC4	; 196
    3b68:	90 e0       	ldi	r25, 0x00	; 0
    3b6a:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <csp_buffer_get>
    3b6e:	ec 01       	movw	r28, r24
			if (packet == NULL)
    3b70:	00 97       	sbiw	r24, 0x00	; 0
    3b72:	09 f4       	brne	.+2      	; 0x3b76 <csp_service_handler+0x7a>
    3b74:	75 c0       	rjmp	.+234    	; 0x3c60 <csp_service_handler+0x164>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    3b76:	a6 01       	movw	r20, r12
    3b78:	4e 19       	sub	r20, r14
    3b7a:	5f 09       	sbc	r21, r15
    3b7c:	45 3c       	cpi	r20, 0xC5	; 197
    3b7e:	51 05       	cpc	r21, r1
    3b80:	14 f0       	brlt	.+4      	; 0x3b86 <csp_service_handler+0x8a>
    3b82:	44 ec       	ldi	r20, 0xC4	; 196
    3b84:	50 e0       	ldi	r21, 0x00	; 0
    3b86:	48 87       	std	Y+8, r20	; 0x08
    3b88:	59 87       	std	Y+9, r21	; 0x09

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    3b8a:	b5 01       	movw	r22, r10
    3b8c:	6e 0d       	add	r22, r14
    3b8e:	7f 1d       	adc	r23, r15
    3b90:	ce 01       	movw	r24, r28
    3b92:	0e 96       	adiw	r24, 0x0e	; 14
    3b94:	0e 94 56 2d 	call	0x5aac	; 0x5aac <memcpy>
			i += packet->length;
    3b98:	88 85       	ldd	r24, Y+8	; 0x08
    3b9a:	99 85       	ldd	r25, Y+9	; 0x09
    3b9c:	e8 0e       	add	r14, r24
    3b9e:	f9 1e       	adc	r15, r25
			if (!csp_send(conn, packet, 0))
    3ba0:	20 e0       	ldi	r18, 0x00	; 0
    3ba2:	30 e0       	ldi	r19, 0x00	; 0
    3ba4:	a9 01       	movw	r20, r18
    3ba6:	be 01       	movw	r22, r28
    3ba8:	c8 01       	movw	r24, r16
    3baa:	51 da       	rcall	.-2910   	; 0x304e <csp_send>
    3bac:	89 2b       	or	r24, r25
    3bae:	19 f4       	brne	.+6      	; 0x3bb6 <csp_service_handler+0xba>
				csp_buffer_free(packet);
    3bb0:	ce 01       	movw	r24, r28
    3bb2:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    3bb6:	ec 14       	cp	r14, r12
    3bb8:	fd 04       	cpc	r15, r13
    3bba:	0c f0       	brlt	.+2      	; 0x3bbe <csp_service_handler+0xc2>
    3bbc:	51 c0       	rjmp	.+162    	; 0x3c60 <csp_service_handler+0x164>
    3bbe:	c0 e0       	ldi	r28, 0x00	; 0
    3bc0:	d0 e0       	ldi	r29, 0x00	; 0
    3bc2:	cf cf       	rjmp	.-98     	; 0x3b62 <csp_service_handler+0x66>
		}
		break;
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    3bc4:	0e 94 3f 12 	call	0x247e	; 0x247e <csp_sys_memfree>

		total = csp_hton32(total);
    3bc8:	81 d8       	rcall	.-3838   	; 0x2ccc <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    3bca:	6e 87       	std	Y+14, r22	; 0x0e
    3bcc:	7f 87       	std	Y+15, r23	; 0x0f
    3bce:	88 8b       	std	Y+16, r24	; 0x10
    3bd0:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    3bd2:	84 e0       	ldi	r24, 0x04	; 4
    3bd4:	90 e0       	ldi	r25, 0x00	; 0
    3bd6:	88 87       	std	Y+8, r24	; 0x08
    3bd8:	99 87       	std	Y+9, r25	; 0x09
    3bda:	35 c0       	rjmp	.+106    	; 0x3c46 <csp_service_handler+0x14a>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    3bdc:	6e 85       	ldd	r22, Y+14	; 0x0e
    3bde:	7f 85       	ldd	r23, Y+15	; 0x0f
    3be0:	88 89       	ldd	r24, Y+16	; 0x10
    3be2:	99 89       	ldd	r25, Y+17	; 0x11
    3be4:	a8 d8       	rcall	.-3760   	; 0x2d36 <csp_ntoh32>

		/* If the magic word is invalid, return */
		if (magic_word != 0x80078007) {
    3be6:	67 30       	cpi	r22, 0x07	; 7
    3be8:	70 48       	sbci	r23, 0x80	; 128
    3bea:	87 40       	sbci	r24, 0x07	; 7
    3bec:	90 48       	sbci	r25, 0x80	; 128
    3bee:	21 f0       	breq	.+8      	; 0x3bf8 <csp_service_handler+0xfc>
			csp_buffer_free(packet);
    3bf0:	ce 01       	movw	r24, r28
    3bf2:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
			return;
    3bf6:	34 c0       	rjmp	.+104    	; 0x3c60 <csp_service_handler+0x164>
		}

		/* Otherwise Reboot */
		csp_sys_reboot();
    3bf8:	0e 94 96 12 	call	0x252c	; 0x252c <csp_sys_reboot>
		
		csp_buffer_free(packet);
    3bfc:	ce 01       	movw	r24, r28
    3bfe:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
		return;
    3c02:	2e c0       	rjmp	.+92     	; 0x3c60 <csp_service_handler+0x164>
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    3c04:	0e 94 14 14 	call	0x2828	; 0x2828 <csp_buffer_remaining>
    3c08:	bc 01       	movw	r22, r24
    3c0a:	88 27       	eor	r24, r24
    3c0c:	77 fd       	sbrc	r23, 7
    3c0e:	80 95       	com	r24
    3c10:	98 2f       	mov	r25, r24
		size = csp_hton32(size);
    3c12:	5c d8       	rcall	.-3912   	; 0x2ccc <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    3c14:	6e 87       	std	Y+14, r22	; 0x0e
    3c16:	7f 87       	std	Y+15, r23	; 0x0f
    3c18:	88 8b       	std	Y+16, r24	; 0x10
    3c1a:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(size);
    3c1c:	84 e0       	ldi	r24, 0x04	; 4
    3c1e:	90 e0       	ldi	r25, 0x00	; 0
    3c20:	88 87       	std	Y+8, r24	; 0x08
    3c22:	99 87       	std	Y+9, r25	; 0x09
    3c24:	10 c0       	rjmp	.+32     	; 0x3c46 <csp_service_handler+0x14a>
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    3c26:	0e 94 cb 12 	call	0x2596	; 0x2596 <csp_get_s>
		time = csp_hton32(time);
    3c2a:	50 d8       	rcall	.-3936   	; 0x2ccc <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    3c2c:	6e 87       	std	Y+14, r22	; 0x0e
    3c2e:	7f 87       	std	Y+15, r23	; 0x0f
    3c30:	88 8b       	std	Y+16, r24	; 0x10
    3c32:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    3c34:	84 e0       	ldi	r24, 0x04	; 4
    3c36:	90 e0       	ldi	r25, 0x00	; 0
    3c38:	88 87       	std	Y+8, r24	; 0x08
    3c3a:	99 87       	std	Y+9, r25	; 0x09
    3c3c:	04 c0       	rjmp	.+8      	; 0x3c46 <csp_service_handler+0x14a>
		break;
	}

	default:
		csp_buffer_free(packet);
    3c3e:	ce 01       	movw	r24, r28
    3c40:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
		return;
    3c44:	0d c0       	rjmp	.+26     	; 0x3c60 <csp_service_handler+0x164>
	}

	if (packet != NULL) {
    3c46:	20 97       	sbiw	r28, 0x00	; 0
    3c48:	59 f0       	breq	.+22     	; 0x3c60 <csp_service_handler+0x164>
		if (!csp_send(conn, packet, 0))
    3c4a:	20 e0       	ldi	r18, 0x00	; 0
    3c4c:	30 e0       	ldi	r19, 0x00	; 0
    3c4e:	a9 01       	movw	r20, r18
    3c50:	be 01       	movw	r22, r28
    3c52:	c8 01       	movw	r24, r16
    3c54:	fc d9       	rcall	.-3080   	; 0x304e <csp_send>
    3c56:	89 2b       	or	r24, r25
    3c58:	19 f4       	brne	.+6      	; 0x3c60 <csp_service_handler+0x164>
			csp_buffer_free(packet);
    3c5a:	ce 01       	movw	r24, r28
    3c5c:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
	}

}
    3c60:	df 91       	pop	r29
    3c62:	cf 91       	pop	r28
    3c64:	1f 91       	pop	r17
    3c66:	0f 91       	pop	r16
    3c68:	ff 90       	pop	r15
    3c6a:	ef 90       	pop	r14
    3c6c:	df 90       	pop	r13
    3c6e:	cf 90       	pop	r12
    3c70:	bf 90       	pop	r11
    3c72:	af 90       	pop	r10
    3c74:	08 95       	ret

00003c76 <csp_i2c_tx>:
#include <csp/csp_interface.h>
#include <csp/csp_error.h>
#include <csp/interfaces/csp_if_i2c.h>
#include <csp/drivers/i2c.h>

int csp_i2c_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    3c76:	cf 92       	push	r12
    3c78:	df 92       	push	r13
    3c7a:	ef 92       	push	r14
    3c7c:	ff 92       	push	r15
    3c7e:	cf 93       	push	r28
    3c80:	df 93       	push	r29
    3c82:	eb 01       	movw	r28, r22
    3c84:	69 01       	movw	r12, r18
    3c86:	7a 01       	movw	r14, r20

	/* Cast the CSP packet buffer into an i2c frame */
	i2c_frame_t * frame = (i2c_frame_t *) packet;

	/* Insert destination node into the i2c destination field */
	if (csp_route_get_nexthop_mac(packet->id.dst) == CSP_NODE_MAC) {
    3c88:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c8a:	92 95       	swap	r25
    3c8c:	9f 70       	andi	r25, 0x0F	; 15
    3c8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c90:	81 70       	andi	r24, 0x01	; 1
    3c92:	82 95       	swap	r24
    3c94:	80 7f       	andi	r24, 0xF0	; 240
    3c96:	89 2b       	or	r24, r25
    3c98:	c9 dd       	rcall	.-1134   	; 0x382c <csp_route_get_nexthop_mac>
    3c9a:	8f 3f       	cpi	r24, 0xFF	; 255
    3c9c:	51 f4       	brne	.+20     	; 0x3cb2 <csp_i2c_tx+0x3c>
		frame->dest = packet->id.dst;
    3c9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3ca0:	92 95       	swap	r25
    3ca2:	9f 70       	andi	r25, 0x0F	; 15
    3ca4:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ca6:	81 70       	andi	r24, 0x01	; 1
    3ca8:	82 95       	swap	r24
    3caa:	80 7f       	andi	r24, 0xF0	; 240
    3cac:	89 2b       	or	r24, r25
    3cae:	8e 83       	std	Y+6, r24	; 0x06
    3cb0:	0a c0       	rjmp	.+20     	; 0x3cc6 <csp_i2c_tx+0x50>
	} else {
		frame->dest = csp_route_get_nexthop_mac(packet->id.dst);
    3cb2:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cb4:	92 95       	swap	r25
    3cb6:	9f 70       	andi	r25, 0x0F	; 15
    3cb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    3cba:	81 70       	andi	r24, 0x01	; 1
    3cbc:	82 95       	swap	r24
    3cbe:	80 7f       	andi	r24, 0xF0	; 240
    3cc0:	89 2b       	or	r24, r25
    3cc2:	b4 dd       	rcall	.-1176   	; 0x382c <csp_route_get_nexthop_mac>
    3cc4:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* Save the outgoing id in the buffer */
	packet->id.ext = csp_hton32(packet->id.ext);
    3cc6:	6a 85       	ldd	r22, Y+10	; 0x0a
    3cc8:	7b 85       	ldd	r23, Y+11	; 0x0b
    3cca:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ccc:	9d 85       	ldd	r25, Y+13	; 0x0d
    3cce:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <csp_hton32>
    3cd2:	6a 87       	std	Y+10, r22	; 0x0a
    3cd4:	7b 87       	std	Y+11, r23	; 0x0b
    3cd6:	8c 87       	std	Y+12, r24	; 0x0c
    3cd8:	9d 87       	std	Y+13, r25	; 0x0d

	/* Add the CSP header to the I2C length field */
	frame->len += sizeof(packet->id);
    3cda:	88 85       	ldd	r24, Y+8	; 0x08
    3cdc:	99 85       	ldd	r25, Y+9	; 0x09
    3cde:	04 96       	adiw	r24, 0x04	; 4
    3ce0:	88 87       	std	Y+8, r24	; 0x08
    3ce2:	99 87       	std	Y+9, r25	; 0x09
	frame->len_rx = 0;
    3ce4:	1f 82       	std	Y+7, r1	; 0x07

	/* Some I2C drivers support X number of retries
	 * CSP don't care about this. If it doesn't work the first
	 * time, don'y use time on it.
	 */
	frame->retries = 0;
    3ce6:	19 82       	std	Y+1, r1	; 0x01

	/* enqueue the frame */
	if (i2c_send(0, frame, timeout) != E_NO_ERR)
    3ce8:	a6 01       	movw	r20, r12
    3cea:	be 01       	movw	r22, r28
    3cec:	80 e0       	ldi	r24, 0x00	; 0
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	0e 94 8f 04 	call	0x91e	; 0x91e <i2c_send>
    3cf4:	01 96       	adiw	r24, 0x01	; 1
    3cf6:	19 f0       	breq	.+6      	; 0x3cfe <csp_i2c_tx+0x88>
		return CSP_ERR_DRIVER;
    3cf8:	85 ef       	ldi	r24, 0xF5	; 245
    3cfa:	9f ef       	ldi	r25, 0xFF	; 255
    3cfc:	02 c0       	rjmp	.+4      	; 0x3d02 <csp_i2c_tx+0x8c>

	return CSP_ERR_NONE;
    3cfe:	80 e0       	ldi	r24, 0x00	; 0
    3d00:	90 e0       	ldi	r25, 0x00	; 0

}
    3d02:	df 91       	pop	r29
    3d04:	cf 91       	pop	r28
    3d06:	ff 90       	pop	r15
    3d08:	ef 90       	pop	r14
    3d0a:	df 90       	pop	r13
    3d0c:	cf 90       	pop	r12
    3d0e:	08 95       	ret

00003d10 <csp_i2c_rx>:
 * When a frame is received, cast it to a csp_packet
 * and send it directly to the CSP new packet function.
 * Context: ISR only
 * @param frame
 */
void csp_i2c_rx(i2c_frame_t * frame, void * pxTaskWoken) {
    3d10:	0f 93       	push	r16
    3d12:	1f 93       	push	r17
    3d14:	cf 93       	push	r28
    3d16:	df 93       	push	r29
    3d18:	ec 01       	movw	r28, r24
    3d1a:	8b 01       	movw	r16, r22

	static csp_packet_t * packet;

	/* Validate input */
	if (frame == NULL)
    3d1c:	00 97       	sbiw	r24, 0x00	; 0
    3d1e:	79 f1       	breq	.+94     	; 0x3d7e <csp_i2c_rx+0x6e>
		return;

	if ((frame->len < 4) || (frame->len > I2C_MTU)) {
    3d20:	88 85       	ldd	r24, Y+8	; 0x08
    3d22:	99 85       	ldd	r25, Y+9	; 0x09
    3d24:	04 97       	sbiw	r24, 0x04	; 4
    3d26:	8d 3f       	cpi	r24, 0xFD	; 253
    3d28:	91 05       	cpc	r25, r1
    3d2a:	88 f0       	brcs	.+34     	; 0x3d4e <csp_i2c_rx+0x3e>
		csp_if_i2c.frame++;
    3d2c:	e9 e2       	ldi	r30, 0x29	; 41
    3d2e:	f0 e2       	ldi	r31, 0x20	; 32
    3d30:	80 81       	ld	r24, Z
    3d32:	91 81       	ldd	r25, Z+1	; 0x01
    3d34:	a2 81       	ldd	r26, Z+2	; 0x02
    3d36:	b3 81       	ldd	r27, Z+3	; 0x03
    3d38:	01 96       	adiw	r24, 0x01	; 1
    3d3a:	a1 1d       	adc	r26, r1
    3d3c:	b1 1d       	adc	r27, r1
    3d3e:	80 83       	st	Z, r24
    3d40:	91 83       	std	Z+1, r25	; 0x01
    3d42:	a2 83       	std	Z+2, r26	; 0x02
    3d44:	b3 83       	std	Z+3, r27	; 0x03
		csp_buffer_free_isr(frame);
    3d46:	ce 01       	movw	r24, r28
    3d48:	0e 94 a5 13 	call	0x274a	; 0x274a <csp_buffer_free_isr>
		return;
    3d4c:	18 c0       	rjmp	.+48     	; 0x3d7e <csp_i2c_rx+0x6e>
	}

	/* Strip the CSP header off the length field before converting to CSP packet */
	frame->len -= sizeof(csp_id_t);
    3d4e:	88 87       	std	Y+8, r24	; 0x08
    3d50:	99 87       	std	Y+9, r25	; 0x09

	/* Convert the packet from network to host order */
	packet = (csp_packet_t *) frame;
    3d52:	c0 93 d5 3e 	sts	0x3ED5, r28
    3d56:	d0 93 d6 3e 	sts	0x3ED6, r29
	packet->id.ext = csp_ntoh32(packet->id.ext);
    3d5a:	6a 85       	ldd	r22, Y+10	; 0x0a
    3d5c:	7b 85       	ldd	r23, Y+11	; 0x0b
    3d5e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d60:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d62:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <csp_ntoh32>
    3d66:	6a 87       	std	Y+10, r22	; 0x0a
    3d68:	7b 87       	std	Y+11, r23	; 0x0b
    3d6a:	8c 87       	std	Y+12, r24	; 0x0c
    3d6c:	9d 87       	std	Y+13, r25	; 0x0d

	/* Receive the packet in CSP */
	csp_new_packet(packet, &csp_if_i2c, pxTaskWoken);
    3d6e:	a8 01       	movw	r20, r16
    3d70:	67 e0       	ldi	r22, 0x07	; 7
    3d72:	70 e2       	ldi	r23, 0x20	; 32
    3d74:	80 91 d5 3e 	lds	r24, 0x3ED5
    3d78:	90 91 d6 3e 	lds	r25, 0x3ED6
    3d7c:	e5 dc       	rcall	.-1590   	; 0x3748 <csp_new_packet>

}
    3d7e:	df 91       	pop	r29
    3d80:	cf 91       	pop	r28
    3d82:	1f 91       	pop	r17
    3d84:	0f 91       	pop	r16
    3d86:	08 95       	ret

00003d88 <csp_i2c_init>:

int csp_i2c_init(uint8_t addr, int handle, int speed) {
    3d88:	cf 92       	push	r12
    3d8a:	df 92       	push	r13
    3d8c:	ef 92       	push	r14
    3d8e:	ff 92       	push	r15
    3d90:	0f 93       	push	r16
    3d92:	1f 93       	push	r17
    3d94:	e8 2f       	mov	r30, r24
    3d96:	cb 01       	movw	r24, r22
    3d98:	9a 01       	movw	r18, r20

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
    3d9a:	0f 2e       	mov	r0, r31
    3d9c:	f8 e8       	ldi	r31, 0x88	; 136
    3d9e:	cf 2e       	mov	r12, r31
    3da0:	fe e1       	ldi	r31, 0x1E	; 30
    3da2:	df 2e       	mov	r13, r31
    3da4:	f0 2d       	mov	r31, r0
    3da6:	0f 2e       	mov	r0, r31
    3da8:	fa e0       	ldi	r31, 0x0A	; 10
    3daa:	ef 2e       	mov	r14, r31
    3dac:	f1 2c       	mov	r15, r1
    3dae:	f0 2d       	mov	r31, r0
    3db0:	0a e0       	ldi	r16, 0x0A	; 10
    3db2:	10 e0       	ldi	r17, 0x00	; 0
    3db4:	4e 2f       	mov	r20, r30
    3db6:	60 e0       	ldi	r22, 0x00	; 0
    3db8:	70 e0       	ldi	r23, 0x00	; 0
    3dba:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <i2c_init>
    3dbe:	01 96       	adiw	r24, 0x01	; 1
    3dc0:	31 f4       	brne	.+12     	; 0x3dce <csp_i2c_init+0x46>
		return CSP_ERR_DRIVER;

	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);
    3dc2:	87 e0       	ldi	r24, 0x07	; 7
    3dc4:	90 e2       	ldi	r25, 0x20	; 32
    3dc6:	e9 da       	rcall	.-2606   	; 0x339a <csp_route_add_if>

	return CSP_ERR_NONE;
    3dc8:	80 e0       	ldi	r24, 0x00	; 0
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	02 c0       	rjmp	.+4      	; 0x3dd2 <csp_i2c_init+0x4a>

int csp_i2c_init(uint8_t addr, int handle, int speed) {

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    3dce:	85 ef       	ldi	r24, 0xF5	; 245
    3dd0:	9f ef       	ldi	r25, 0xFF	; 255
	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);

	return CSP_ERR_NONE;

}
    3dd2:	1f 91       	pop	r17
    3dd4:	0f 91       	pop	r16
    3dd6:	ff 90       	pop	r15
    3dd8:	ef 90       	pop	r14
    3dda:	df 90       	pop	r13
    3ddc:	cf 90       	pop	r12
    3dde:	08 95       	ret

00003de0 <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    3de0:	cb 01       	movw	r24, r22

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_new_packet(packet, &csp_if_lo, NULL);
    3de2:	40 e0       	ldi	r20, 0x00	; 0
    3de4:	50 e0       	ldi	r21, 0x00	; 0
    3de6:	6b e3       	ldi	r22, 0x3B	; 59
    3de8:	70 e2       	ldi	r23, 0x20	; 32
    3dea:	ae dc       	rcall	.-1700   	; 0x3748 <csp_new_packet>

	return CSP_ERR_NONE;

}
    3dec:	80 e0       	ldi	r24, 0x00	; 0
    3dee:	90 e0       	ldi	r25, 0x00	; 0
    3df0:	08 95       	ret

00003df2 <csp_udp_new_packet>:
#include <csp/csp.h>
#include <csp/arch/csp_queue.h>
#include "../csp_port.h"
#include "../csp_conn.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    3df2:	0f 93       	push	r16
    3df4:	1f 93       	push	r17
    3df6:	cf 93       	push	r28
    3df8:	df 93       	push	r29
    3dfa:	1f 92       	push	r1
    3dfc:	1f 92       	push	r1
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
    3e02:	89 83       	std	Y+1, r24	; 0x01
    3e04:	9a 83       	std	Y+2, r25	; 0x02
    3e06:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    3e08:	0e 94 1a 14 	call	0x2834	; 0x2834 <csp_conn_enqueue_packet>
    3e0c:	99 23       	and	r25, r25
    3e0e:	24 f4       	brge	.+8      	; 0x3e18 <csp_udp_new_packet+0x26>
		csp_log_error("Connection buffer queue full!\r\n");
		csp_buffer_free(packet);
    3e10:	c8 01       	movw	r24, r16
    3e12:	0e 94 dd 13 	call	0x27ba	; 0x27ba <csp_buffer_free>
		return;
    3e16:	19 c0       	rjmp	.+50     	; 0x3e4a <csp_udp_new_packet+0x58>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    3e18:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1c:	86 85       	ldd	r24, Z+14	; 0x0e
    3e1e:	97 85       	ldd	r25, Z+15	; 0x0f
    3e20:	00 97       	sbiw	r24, 0x00	; 0
    3e22:	99 f0       	breq	.+38     	; 0x3e4a <csp_udp_new_packet+0x58>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    3e24:	20 e0       	ldi	r18, 0x00	; 0
    3e26:	30 e0       	ldi	r19, 0x00	; 0
    3e28:	a9 01       	movw	r20, r18
    3e2a:	be 01       	movw	r22, r28
    3e2c:	6f 5f       	subi	r22, 0xFF	; 255
    3e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e30:	0e 94 ca 11 	call	0x2394	; 0x2394 <csp_queue_enqueue>
    3e34:	01 97       	sbiw	r24, 0x01	; 1
    3e36:	29 f0       	breq	.+10     	; 0x3e42 <csp_udp_new_packet+0x50>
			csp_log_warn("Warning socket connection queue full\r\n");
			csp_close(conn);
    3e38:	89 81       	ldd	r24, Y+1	; 0x01
    3e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3c:	0e 94 78 15 	call	0x2af0	; 0x2af0 <csp_close>
			return;
    3e40:	04 c0       	rjmp	.+8      	; 0x3e4a <csp_udp_new_packet+0x58>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    3e42:	e9 81       	ldd	r30, Y+1	; 0x01
    3e44:	fa 81       	ldd	r31, Y+2	; 0x02
    3e46:	16 86       	std	Z+14, r1	; 0x0e
    3e48:	17 86       	std	Z+15, r1	; 0x0f
	}

}
    3e4a:	0f 90       	pop	r0
    3e4c:	0f 90       	pop	r0
    3e4e:	df 91       	pop	r29
    3e50:	cf 91       	pop	r28
    3e52:	1f 91       	pop	r17
    3e54:	0f 91       	pop	r16
    3e56:	08 95       	ret

00003e58 <blink>:

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
    3e58:	c0 e0       	ldi	r28, 0x00	; 0
    3e5a:	d6 e0       	ldi	r29, 0x06	; 6
    3e5c:	12 e0       	ldi	r17, 0x02	; 2
    3e5e:	1f 83       	std	Y+7, r17	; 0x07
	
	while (1) {
				
		led_yellow_toggle();
		
        vTaskDelay(1000);
    3e60:	88 ee       	ldi	r24, 0xE8	; 232
    3e62:	93 e0       	ldi	r25, 0x03	; 3
    3e64:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <vTaskDelay>
    3e68:	fa cf       	rjmp	.-12     	; 0x3e5e <blink+0x6>

00003e6a <main>:
	}
}

int main(void) {
    3e6a:	af 92       	push	r10
    3e6c:	bf 92       	push	r11
    3e6e:	cf 92       	push	r12
    3e70:	df 92       	push	r13
    3e72:	ef 92       	push	r14
    3e74:	ff 92       	push	r15
    3e76:	0f 93       	push	r16
	
	// initialize the xMega peripherals
	boardInit();
    3e78:	21 d7       	rcall	.+3650   	; 0x4cbc <boardInit>
	
	// Initialize the CSP buffers
	csp_buffer_init(CSP_BUFFER_COUNT, CSP_BUFFER_SIZE);
    3e7a:	66 e5       	ldi	r22, 0x56	; 86
    3e7c:	70 e0       	ldi	r23, 0x00	; 0
    3e7e:	81 e0       	ldi	r24, 0x01	; 1
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <csp_buffer_init>
			
	// Initialize the CSP
	csp_init(CSP_MY_ADDRESS);
    3e86:	83 e0       	ldi	r24, 0x03	; 3
    3e88:	0e 94 da 16 	call	0x2db4	; 0x2db4 <csp_init>
	
	// Initialize the CSP I2C interface
	csp_i2c_init(CSP_I2C_SLAVE_ADDRESS, 0, CSP_I2C_BAUDSETTING);
    3e8c:	43 e2       	ldi	r20, 0x23	; 35
    3e8e:	50 e0       	ldi	r21, 0x00	; 0
    3e90:	60 e0       	ldi	r22, 0x00	; 0
    3e92:	70 e0       	ldi	r23, 0x00	; 0
    3e94:	83 e0       	ldi	r24, 0x03	; 3
    3e96:	78 df       	rcall	.-272    	; 0x3d88 <csp_i2c_init>
					
	// Add route to OBC via i2c
	csp_route_set(CSP_OBC_ADDRESS, &csp_if_i2c, CSP_I2C_OBC_ADDRESS);
    3e98:	41 e0       	ldi	r20, 0x01	; 1
    3e9a:	67 e0       	ldi	r22, 0x07	; 7
    3e9c:	70 e2       	ldi	r23, 0x20	; 32
    3e9e:	81 e0       	ldi	r24, 0x01	; 1
    3ea0:	a5 da       	rcall	.-2742   	; 0x33ec <csp_route_set>
					
	// Start router task
	csp_route_start_task(CSP_ROUTER_STACK, CSP_ROUTER_PRIORITY);
    3ea2:	60 e0       	ldi	r22, 0x00	; 0
    3ea4:	70 e0       	ldi	r23, 0x00	; 0
    3ea6:	84 ef       	ldi	r24, 0xF4	; 244
    3ea8:	91 e0       	ldi	r25, 0x01	; 1
    3eaa:	36 da       	rcall	.-2964   	; 0x3318 <csp_route_start_task>
				
	/* -------------------------------------------------------------------- */
	/*	Starts blinking task - only for debug								*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(blink, (signed char*) "blink", 64, NULL, configNORMAL_PRIORITY, NULL);
    3eac:	a1 2c       	mov	r10, r1
    3eae:	b1 2c       	mov	r11, r1
    3eb0:	c1 2c       	mov	r12, r1
    3eb2:	d1 2c       	mov	r13, r1
    3eb4:	e1 2c       	mov	r14, r1
    3eb6:	f1 2c       	mov	r15, r1
    3eb8:	00 e0       	ldi	r16, 0x00	; 0
    3eba:	20 e0       	ldi	r18, 0x00	; 0
    3ebc:	30 e0       	ldi	r19, 0x00	; 0
    3ebe:	40 e4       	ldi	r20, 0x40	; 64
    3ec0:	50 e0       	ldi	r21, 0x00	; 0
    3ec2:	68 eb       	ldi	r22, 0xB8	; 184
    3ec4:	70 e2       	ldi	r23, 0x20	; 32
    3ec6:	8c e2       	ldi	r24, 0x2C	; 44
    3ec8:	9f e1       	ldi	r25, 0x1F	; 31
    3eca:	0e 94 c5 0a 	call	0x158a	; 0x158a <xTaskGenericCreate>
		
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles incoming communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(cspTask, (signed char*) "cspTask", 256, NULL, configNORMAL_PRIORITY, NULL);
    3ece:	20 e0       	ldi	r18, 0x00	; 0
    3ed0:	30 e0       	ldi	r19, 0x00	; 0
    3ed2:	40 e0       	ldi	r20, 0x00	; 0
    3ed4:	51 e0       	ldi	r21, 0x01	; 1
    3ed6:	6e eb       	ldi	r22, 0xBE	; 190
    3ed8:	70 e2       	ldi	r23, 0x20	; 32
    3eda:	88 ea       	ldi	r24, 0xA8	; 168
    3edc:	93 e0       	ldi	r25, 0x03	; 3
    3ede:	0e 94 c5 0a 	call	0x158a	; 0x158a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles outgoing communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(mainTask, (signed char*) "mainTask", 512, NULL, configNORMAL_PRIORITY, NULL);
    3ee2:	20 e0       	ldi	r18, 0x00	; 0
    3ee4:	30 e0       	ldi	r19, 0x00	; 0
    3ee6:	40 e0       	ldi	r20, 0x00	; 0
    3ee8:	52 e0       	ldi	r21, 0x02	; 2
    3eea:	66 ec       	ldi	r22, 0xC6	; 198
    3eec:	70 e2       	ldi	r23, 0x20	; 32
    3eee:	8d e6       	ldi	r24, 0x6D	; 109
    3ef0:	91 e2       	ldi	r25, 0x21	; 33
    3ef2:	0e 94 c5 0a 	call	0x158a	; 0x158a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts the scheduler and all previously created tasks				*/
	/* -------------------------------------------------------------------- */
	vTaskStartScheduler();
    3ef6:	0e 94 ac 0b 	call	0x1758	; 0x1758 <vTaskStartScheduler>
	
	return 0;
    3efa:	80 e0       	ldi	r24, 0x00	; 0
    3efc:	90 e0       	ldi	r25, 0x00	; 0
    3efe:	0f 91       	pop	r16
    3f00:	ff 90       	pop	r15
    3f02:	ef 90       	pop	r14
    3f04:	df 90       	pop	r13
    3f06:	cf 90       	pop	r12
    3f08:	bf 90       	pop	r11
    3f0a:	af 90       	pop	r10
    3f0c:	08 95       	ret

00003f0e <sendFreeHeapSpace>:
csp_packet_t * outcomingPacket;

/* -------------------------------------------------------------------- */
/*	Reply the free heap space in human readable form					*/
/* -------------------------------------------------------------------- */
int sendFreeHeapSpace(csp_packet_t * inPacket) {
    3f0e:	8f 92       	push	r8
    3f10:	9f 92       	push	r9
    3f12:	af 92       	push	r10
    3f14:	bf 92       	push	r11
    3f16:	cf 92       	push	r12
    3f18:	df 92       	push	r13
    3f1a:	ef 92       	push	r14
    3f1c:	ff 92       	push	r15
    3f1e:	0f 93       	push	r16
    3f20:	1f 93       	push	r17
    3f22:	cf 93       	push	r28
    3f24:	df 93       	push	r29
    3f26:	cd b7       	in	r28, 0x3d	; 61
    3f28:	de b7       	in	r29, 0x3e	; 62
    3f2a:	64 97       	sbiw	r28, 0x14	; 20
    3f2c:	cd bf       	out	0x3d, r28	; 61
    3f2e:	de bf       	out	0x3e, r29	; 62
    3f30:	7c 01       	movw	r14, r24
	
	char msg[20];
	itoa(xPortGetFreeHeapSize(), msg, 10);
    3f32:	0e 94 1c 05 	call	0xa38	; 0xa38 <xPortGetFreeHeapSize>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3f36:	4a e0       	ldi	r20, 0x0A	; 10
    3f38:	8e 01       	movw	r16, r28
    3f3a:	0f 5f       	subi	r16, 0xFF	; 255
    3f3c:	1f 4f       	sbci	r17, 0xFF	; 255
    3f3e:	b8 01       	movw	r22, r16
    3f40:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <__itoa_ncheck>
	
	/* Copy message to packet */
	strcpy(outcomingPacket->data, msg);
    3f44:	80 91 80 3f 	lds	r24, 0x3F80
    3f48:	90 91 81 3f 	lds	r25, 0x3F81
    3f4c:	b8 01       	movw	r22, r16
    3f4e:	0e 96       	adiw	r24, 0x0e	; 14
    3f50:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <strcpy>
	outcomingPacket->length = strlen(msg);
    3f54:	c0 90 80 3f 	lds	r12, 0x3F80
    3f58:	d0 90 81 3f 	lds	r13, 0x3F81
    3f5c:	f8 01       	movw	r30, r16
    3f5e:	01 90       	ld	r0, Z+
    3f60:	00 20       	and	r0, r0
    3f62:	e9 f7       	brne	.-6      	; 0x3f5e <sendFreeHeapSpace+0x50>
    3f64:	31 97       	sbiw	r30, 0x01	; 1
    3f66:	e0 1b       	sub	r30, r16
    3f68:	f1 0b       	sbc	r31, r17
    3f6a:	d6 01       	movw	r26, r12
    3f6c:	18 96       	adiw	r26, 0x08	; 8
    3f6e:	ed 93       	st	X+, r30
    3f70:	fc 93       	st	X, r31
    3f72:	19 97       	sbiw	r26, 0x09	; 9

	/* Send packet */
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 1000) == CSP_ERR_NONE) {
    3f74:	f7 01       	movw	r30, r14
    3f76:	43 85       	ldd	r20, Z+11	; 0x0b
    3f78:	84 2f       	mov	r24, r20
    3f7a:	82 95       	swap	r24
    3f7c:	86 95       	lsr	r24
    3f7e:	86 95       	lsr	r24
    3f80:	83 70       	andi	r24, 0x03	; 3
    3f82:	24 85       	ldd	r18, Z+12	; 0x0c
    3f84:	2f 70       	andi	r18, 0x0F	; 15
    3f86:	22 0f       	add	r18, r18
    3f88:	22 0f       	add	r18, r18
    3f8a:	28 2b       	or	r18, r24
    3f8c:	4f 73       	andi	r20, 0x3F	; 63
    3f8e:	65 85       	ldd	r22, Z+13	; 0x0d
    3f90:	66 95       	lsr	r22
    3f92:	6f 71       	andi	r22, 0x1F	; 31
    3f94:	0f 2e       	mov	r0, r31
    3f96:	f8 ee       	ldi	r31, 0xE8	; 232
    3f98:	8f 2e       	mov	r8, r31
    3f9a:	f3 e0       	ldi	r31, 0x03	; 3
    3f9c:	9f 2e       	mov	r9, r31
    3f9e:	a1 2c       	mov	r10, r1
    3fa0:	b1 2c       	mov	r11, r1
    3fa2:	f0 2d       	mov	r31, r0
    3fa4:	e1 2c       	mov	r14, r1
    3fa6:	f1 2c       	mov	r15, r1
    3fa8:	87 01       	movw	r16, r14
    3faa:	82 e0       	ldi	r24, 0x02	; 2
    3fac:	7a d8       	rcall	.-3852   	; 0x30a2 <csp_sendto>
    3fae:	89 2b       	or	r24, r25
    3fb0:	21 f4       	brne	.+8      	; 0x3fba <sendFreeHeapSpace+0xac>
    3fb2:	80 e1       	ldi	r24, 0x10	; 16
    3fb4:	e0 e0       	ldi	r30, 0x00	; 0
    3fb6:	f6 e0       	ldi	r31, 0x06	; 6
    3fb8:	87 83       	std	Z+7, r24	; 0x07
	} else {
		/* Send failed */
	}

	return 0;
}
    3fba:	80 e0       	ldi	r24, 0x00	; 0
    3fbc:	90 e0       	ldi	r25, 0x00	; 0
    3fbe:	64 96       	adiw	r28, 0x14	; 20
    3fc0:	cd bf       	out	0x3d, r28	; 61
    3fc2:	de bf       	out	0x3e, r29	; 62
    3fc4:	df 91       	pop	r29
    3fc6:	cf 91       	pop	r28
    3fc8:	1f 91       	pop	r17
    3fca:	0f 91       	pop	r16
    3fcc:	ff 90       	pop	r15
    3fce:	ef 90       	pop	r14
    3fd0:	df 90       	pop	r13
    3fd2:	cf 90       	pop	r12
    3fd4:	bf 90       	pop	r11
    3fd6:	af 90       	pop	r10
    3fd8:	9f 90       	pop	r9
    3fda:	8f 90       	pop	r8
    3fdc:	08 95       	ret

00003fde <houseKeeping>:

/* -------------------------------------------------------------------- */
/*	Reply with some status info message									*/
/* -------------------------------------------------------------------- */
int houseKeeping(csp_packet_t * inPacket) {
    3fde:	4f 92       	push	r4
    3fe0:	5f 92       	push	r5
    3fe2:	6f 92       	push	r6
    3fe4:	7f 92       	push	r7
    3fe6:	8f 92       	push	r8
    3fe8:	9f 92       	push	r9
    3fea:	af 92       	push	r10
    3fec:	bf 92       	push	r11
    3fee:	cf 92       	push	r12
    3ff0:	df 92       	push	r13
    3ff2:	ef 92       	push	r14
    3ff4:	ff 92       	push	r15
    3ff6:	0f 93       	push	r16
    3ff8:	1f 93       	push	r17
    3ffa:	cf 93       	push	r28
    3ffc:	df 93       	push	r29
    3ffe:	cd b7       	in	r28, 0x3d	; 61
    4000:	de b7       	in	r29, 0x3e	; 62
    4002:	c0 54       	subi	r28, 0x40	; 64
    4004:	d1 09       	sbc	r29, r1
    4006:	cd bf       	out	0x3d, r28	; 61
    4008:	de bf       	out	0x3e, r29	; 62
    400a:	7c 01       	movw	r14, r24
	
	// put the info message into the packet
	char msg[64];
	sprintf(msg, "*** Board\n\rSoftware v1.0\n\rUptime: %id %ih %im %ds\n\r", (int16_t) hoursTimer/24, (int16_t) hoursTimer%24, (int16_t) secondsTimer/60, (int16_t) secondsTimer%60);
    400c:	80 91 92 3f 	lds	r24, 0x3F92
    4010:	90 91 93 3f 	lds	r25, 0x3F93
    4014:	a0 91 94 3f 	lds	r26, 0x3F94
    4018:	b0 91 95 3f 	lds	r27, 0x3F95
    401c:	40 90 92 3f 	lds	r4, 0x3F92
    4020:	50 90 93 3f 	lds	r5, 0x3F93
    4024:	60 90 94 3f 	lds	r6, 0x3F94
    4028:	70 90 95 3f 	lds	r7, 0x3F95
    402c:	80 90 8a 3f 	lds	r8, 0x3F8A
    4030:	90 90 8b 3f 	lds	r9, 0x3F8B
    4034:	a0 90 8c 3f 	lds	r10, 0x3F8C
    4038:	b0 90 8d 3f 	lds	r11, 0x3F8D
    403c:	00 91 8a 3f 	lds	r16, 0x3F8A
    4040:	10 91 8b 3f 	lds	r17, 0x3F8B
    4044:	20 91 8c 3f 	lds	r18, 0x3F8C
    4048:	30 91 8d 3f 	lds	r19, 0x3F8D
    404c:	ec e3       	ldi	r30, 0x3C	; 60
    404e:	f0 e0       	ldi	r31, 0x00	; 0
    4050:	bf 01       	movw	r22, r30
    4052:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    4056:	9f 93       	push	r25
    4058:	8f 93       	push	r24
    405a:	c2 01       	movw	r24, r4
    405c:	bf 01       	movw	r22, r30
    405e:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    4062:	7f 93       	push	r23
    4064:	6f 93       	push	r22
    4066:	e8 e1       	ldi	r30, 0x18	; 24
    4068:	f0 e0       	ldi	r31, 0x00	; 0
    406a:	c4 01       	movw	r24, r8
    406c:	bf 01       	movw	r22, r30
    406e:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    4072:	9f 93       	push	r25
    4074:	8f 93       	push	r24
    4076:	c8 01       	movw	r24, r16
    4078:	bf 01       	movw	r22, r30
    407a:	0e 94 d3 2b 	call	0x57a6	; 0x57a6 <__divmodhi4>
    407e:	7f 93       	push	r23
    4080:	6f 93       	push	r22
    4082:	8f ec       	ldi	r24, 0xCF	; 207
    4084:	90 e2       	ldi	r25, 0x20	; 32
    4086:	9f 93       	push	r25
    4088:	8f 93       	push	r24
    408a:	8e 01       	movw	r16, r28
    408c:	0f 5f       	subi	r16, 0xFF	; 255
    408e:	1f 4f       	sbci	r17, 0xFF	; 255
    4090:	1f 93       	push	r17
    4092:	0f 93       	push	r16
    4094:	0e 94 f5 2d 	call	0x5bea	; 0x5bea <sprintf>

	strcpy(outcomingPacket->data, msg);
    4098:	80 91 80 3f 	lds	r24, 0x3F80
    409c:	90 91 81 3f 	lds	r25, 0x3F81
    40a0:	b8 01       	movw	r22, r16
    40a2:	0e 96       	adiw	r24, 0x0e	; 14
    40a4:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <strcpy>
	outcomingPacket->length = strlen(msg);
    40a8:	c0 90 80 3f 	lds	r12, 0x3F80
    40ac:	d0 90 81 3f 	lds	r13, 0x3F81
    40b0:	f8 01       	movw	r30, r16
    40b2:	01 90       	ld	r0, Z+
    40b4:	00 20       	and	r0, r0
    40b6:	e9 f7       	brne	.-6      	; 0x40b2 <__stack+0xb3>
    40b8:	31 97       	sbiw	r30, 0x01	; 1
    40ba:	e0 1b       	sub	r30, r16
    40bc:	f1 0b       	sbc	r31, r17
    40be:	d6 01       	movw	r26, r12
    40c0:	18 96       	adiw	r26, 0x08	; 8
    40c2:	ed 93       	st	X+, r30
    40c4:	fc 93       	st	X, r31
    40c6:	19 97       	sbiw	r26, 0x09	; 9

	/* Send packet */
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 1000) == CSP_ERR_NONE) {
    40c8:	f7 01       	movw	r30, r14
    40ca:	43 85       	ldd	r20, Z+11	; 0x0b
    40cc:	84 2f       	mov	r24, r20
    40ce:	82 95       	swap	r24
    40d0:	86 95       	lsr	r24
    40d2:	86 95       	lsr	r24
    40d4:	83 70       	andi	r24, 0x03	; 3
    40d6:	24 85       	ldd	r18, Z+12	; 0x0c
    40d8:	2f 70       	andi	r18, 0x0F	; 15
    40da:	22 0f       	add	r18, r18
    40dc:	22 0f       	add	r18, r18
    40de:	28 2b       	or	r18, r24
    40e0:	4f 73       	andi	r20, 0x3F	; 63
    40e2:	65 85       	ldd	r22, Z+13	; 0x0d
    40e4:	66 95       	lsr	r22
    40e6:	6f 71       	andi	r22, 0x1F	; 31
    40e8:	0f 2e       	mov	r0, r31
    40ea:	f8 ee       	ldi	r31, 0xE8	; 232
    40ec:	8f 2e       	mov	r8, r31
    40ee:	f3 e0       	ldi	r31, 0x03	; 3
    40f0:	9f 2e       	mov	r9, r31
    40f2:	a1 2c       	mov	r10, r1
    40f4:	b1 2c       	mov	r11, r1
    40f6:	f0 2d       	mov	r31, r0
    40f8:	e1 2c       	mov	r14, r1
    40fa:	f1 2c       	mov	r15, r1
    40fc:	87 01       	movw	r16, r14
    40fe:	82 e0       	ldi	r24, 0x02	; 2
    4100:	0e 94 51 18 	call	0x30a2	; 0x30a2 <csp_sendto>
    4104:	cd bf       	out	0x3d, r28	; 61
    4106:	de bf       	out	0x3e, r29	; 62
    4108:	89 2b       	or	r24, r25
    410a:	21 f4       	brne	.+8      	; 0x4114 <__stack+0x115>
    410c:	80 e1       	ldi	r24, 0x10	; 16
    410e:	e0 e0       	ldi	r30, 0x00	; 0
    4110:	f6 e0       	ldi	r31, 0x06	; 6
    4112:	87 83       	std	Z+7, r24	; 0x07
	} else {
		/* Send failed */
	}

	return 0;
}
    4114:	80 e0       	ldi	r24, 0x00	; 0
    4116:	90 e0       	ldi	r25, 0x00	; 0
    4118:	c0 5c       	subi	r28, 0xC0	; 192
    411a:	df 4f       	sbci	r29, 0xFF	; 255
    411c:	cd bf       	out	0x3d, r28	; 61
    411e:	de bf       	out	0x3e, r29	; 62
    4120:	df 91       	pop	r29
    4122:	cf 91       	pop	r28
    4124:	1f 91       	pop	r17
    4126:	0f 91       	pop	r16
    4128:	ff 90       	pop	r15
    412a:	ef 90       	pop	r14
    412c:	df 90       	pop	r13
    412e:	cf 90       	pop	r12
    4130:	bf 90       	pop	r11
    4132:	af 90       	pop	r10
    4134:	9f 90       	pop	r9
    4136:	8f 90       	pop	r8
    4138:	7f 90       	pop	r7
    413a:	6f 90       	pop	r6
    413c:	5f 90       	pop	r5
    413e:	4f 90       	pop	r4
    4140:	08 95       	ret

00004142 <echoBack>:

/* -------------------------------------------------------------------- */
/*	Sends back the incoming packet										*/
/* -------------------------------------------------------------------- */
int echoBack(csp_packet_t * inPacket) {
    4142:	8f 92       	push	r8
    4144:	9f 92       	push	r9
    4146:	af 92       	push	r10
    4148:	bf 92       	push	r11
    414a:	cf 92       	push	r12
    414c:	df 92       	push	r13
    414e:	ef 92       	push	r14
    4150:	ff 92       	push	r15
    4152:	0f 93       	push	r16
    4154:	1f 93       	push	r17
    4156:	fc 01       	movw	r30, r24

	/* Send packet */
	// reuses the incoming packet for the response
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, inPacket, 1000) == CSP_ERR_NONE) {
    4158:	43 85       	ldd	r20, Z+11	; 0x0b
    415a:	84 2f       	mov	r24, r20
    415c:	82 95       	swap	r24
    415e:	86 95       	lsr	r24
    4160:	86 95       	lsr	r24
    4162:	83 70       	andi	r24, 0x03	; 3
    4164:	24 85       	ldd	r18, Z+12	; 0x0c
    4166:	2f 70       	andi	r18, 0x0F	; 15
    4168:	22 0f       	add	r18, r18
    416a:	22 0f       	add	r18, r18
    416c:	28 2b       	or	r18, r24
    416e:	4f 73       	andi	r20, 0x3F	; 63
    4170:	65 85       	ldd	r22, Z+13	; 0x0d
    4172:	66 95       	lsr	r22
    4174:	6f 71       	andi	r22, 0x1F	; 31
    4176:	0f 2e       	mov	r0, r31
    4178:	f8 ee       	ldi	r31, 0xE8	; 232
    417a:	8f 2e       	mov	r8, r31
    417c:	f3 e0       	ldi	r31, 0x03	; 3
    417e:	9f 2e       	mov	r9, r31
    4180:	a1 2c       	mov	r10, r1
    4182:	b1 2c       	mov	r11, r1
    4184:	f0 2d       	mov	r31, r0
    4186:	6f 01       	movw	r12, r30
    4188:	e1 2c       	mov	r14, r1
    418a:	f1 2c       	mov	r15, r1
    418c:	87 01       	movw	r16, r14
    418e:	82 e0       	ldi	r24, 0x02	; 2
    4190:	0e 94 51 18 	call	0x30a2	; 0x30a2 <csp_sendto>
    4194:	89 2b       	or	r24, r25
    4196:	21 f4       	brne	.+8      	; 0x41a0 <echoBack+0x5e>
    4198:	80 e1       	ldi	r24, 0x10	; 16
    419a:	e0 e0       	ldi	r30, 0x00	; 0
    419c:	f6 e0       	ldi	r31, 0x06	; 6
    419e:	87 83       	std	Z+7, r24	; 0x07
	} else {
		/* Send failed */
	}

	return 0;
}
    41a0:	80 e0       	ldi	r24, 0x00	; 0
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	1f 91       	pop	r17
    41a6:	0f 91       	pop	r16
    41a8:	ff 90       	pop	r15
    41aa:	ef 90       	pop	r14
    41ac:	df 90       	pop	r13
    41ae:	cf 90       	pop	r12
    41b0:	bf 90       	pop	r11
    41b2:	af 90       	pop	r10
    41b4:	9f 90       	pop	r9
    41b6:	8f 90       	pop	r8
    41b8:	08 95       	ret

000041ba <AdcConvert>:

/* -------------------------------------------------------------------- */
/*	Send back value of ADC on Pin PA1 and Vref on Pin0					*/
/* -------------------------------------------------------------------- */
int AdcConvert(csp_packet_t * inPacket) {
    41ba:	8f 92       	push	r8
    41bc:	9f 92       	push	r9
    41be:	af 92       	push	r10
    41c0:	bf 92       	push	r11
    41c2:	cf 92       	push	r12
    41c4:	df 92       	push	r13
    41c6:	ef 92       	push	r14
    41c8:	ff 92       	push	r15
    41ca:	0f 93       	push	r16
    41cc:	1f 93       	push	r17
    41ce:	cf 93       	push	r28
    41d0:	df 93       	push	r29
    41d2:	cd b7       	in	r28, 0x3d	; 61
    41d4:	de b7       	in	r29, 0x3e	; 62
    41d6:	c0 54       	subi	r28, 0x40	; 64
    41d8:	d1 09       	sbc	r29, r1
    41da:	cd bf       	out	0x3d, r28	; 61
    41dc:	de bf       	out	0x3e, r29	; 62
    41de:	8c 01       	movw	r16, r24
	
	
	ADCA.CH0.CTRL|=ADC_CH_START_bm;
    41e0:	e0 e0       	ldi	r30, 0x00	; 0
    41e2:	f2 e0       	ldi	r31, 0x02	; 2
    41e4:	80 a1       	ldd	r24, Z+32	; 0x20
    41e6:	80 68       	ori	r24, 0x80	; 128
    41e8:	80 a3       	std	Z+32, r24	; 0x20
	while (!(ADCA.CH0.INTFLAGS&ADC_CH_CHIF_bm));
    41ea:	83 a1       	ldd	r24, Z+35	; 0x23
    41ec:	80 ff       	sbrs	r24, 0
    41ee:	fd cf       	rjmp	.-6      	; 0x41ea <AdcConvert+0x30>
	ADCA.CH0.INTFLAGS|=ADC_CH_CHIF_bm;
    41f0:	e0 e0       	ldi	r30, 0x00	; 0
    41f2:	f2 e0       	ldi	r31, 0x02	; 2
    41f4:	83 a1       	ldd	r24, Z+35	; 0x23
    41f6:	81 60       	ori	r24, 0x01	; 1
    41f8:	83 a3       	std	Z+35, r24	; 0x23
	
	
	// put the info message into the packet
	char msg[64];
	sprintf(msg, "*** ADC value is: %.2f V\n\r", ((ADCA.CH0.RES*3.3)/4096));
    41fa:	64 a1       	ldd	r22, Z+36	; 0x24
    41fc:	75 a1       	ldd	r23, Z+37	; 0x25
    41fe:	80 e0       	ldi	r24, 0x00	; 0
    4200:	90 e0       	ldi	r25, 0x00	; 0
    4202:	5f d6       	rcall	.+3262   	; 0x4ec2 <__floatunsisf>
    4204:	23 e3       	ldi	r18, 0x33	; 51
    4206:	33 e3       	ldi	r19, 0x33	; 51
    4208:	43 e5       	ldi	r20, 0x53	; 83
    420a:	50 e4       	ldi	r21, 0x40	; 64
    420c:	97 d6       	rcall	.+3374   	; 0x4f3c <__mulsf3>
    420e:	20 e0       	ldi	r18, 0x00	; 0
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	40 e8       	ldi	r20, 0x80	; 128
    4214:	59 e3       	ldi	r21, 0x39	; 57
    4216:	92 d6       	rcall	.+3364   	; 0x4f3c <__mulsf3>
    4218:	9f 93       	push	r25
    421a:	8f 93       	push	r24
    421c:	7f 93       	push	r23
    421e:	6f 93       	push	r22
    4220:	83 e0       	ldi	r24, 0x03	; 3
    4222:	91 e2       	ldi	r25, 0x21	; 33
    4224:	9f 93       	push	r25
    4226:	8f 93       	push	r24
    4228:	9e 01       	movw	r18, r28
    422a:	2f 5f       	subi	r18, 0xFF	; 255
    422c:	3f 4f       	sbci	r19, 0xFF	; 255
    422e:	79 01       	movw	r14, r18
    4230:	ff 92       	push	r15
    4232:	2f 93       	push	r18
    4234:	0e 94 f5 2d 	call	0x5bea	; 0x5bea <sprintf>

	strcpy(outcomingPacket->data, msg);
    4238:	80 91 80 3f 	lds	r24, 0x3F80
    423c:	90 91 81 3f 	lds	r25, 0x3F81
    4240:	b7 01       	movw	r22, r14
    4242:	0e 96       	adiw	r24, 0x0e	; 14
    4244:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <strcpy>
	outcomingPacket->length = strlen(msg);
    4248:	c0 90 80 3f 	lds	r12, 0x3F80
    424c:	d0 90 81 3f 	lds	r13, 0x3F81
    4250:	f7 01       	movw	r30, r14
    4252:	01 90       	ld	r0, Z+
    4254:	00 20       	and	r0, r0
    4256:	e9 f7       	brne	.-6      	; 0x4252 <AdcConvert+0x98>
    4258:	31 97       	sbiw	r30, 0x01	; 1
    425a:	ee 19       	sub	r30, r14
    425c:	ff 09       	sbc	r31, r15
    425e:	d6 01       	movw	r26, r12
    4260:	18 96       	adiw	r26, 0x08	; 8
    4262:	ed 93       	st	X+, r30
    4264:	fc 93       	st	X, r31
    4266:	19 97       	sbiw	r26, 0x09	; 9

	/* Send packet */
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 1000) == CSP_ERR_NONE) {
    4268:	f8 01       	movw	r30, r16
    426a:	43 85       	ldd	r20, Z+11	; 0x0b
    426c:	84 2f       	mov	r24, r20
    426e:	82 95       	swap	r24
    4270:	86 95       	lsr	r24
    4272:	86 95       	lsr	r24
    4274:	83 70       	andi	r24, 0x03	; 3
    4276:	24 85       	ldd	r18, Z+12	; 0x0c
    4278:	2f 70       	andi	r18, 0x0F	; 15
    427a:	22 0f       	add	r18, r18
    427c:	22 0f       	add	r18, r18
    427e:	28 2b       	or	r18, r24
    4280:	4f 73       	andi	r20, 0x3F	; 63
    4282:	65 85       	ldd	r22, Z+13	; 0x0d
    4284:	66 95       	lsr	r22
    4286:	6f 71       	andi	r22, 0x1F	; 31
    4288:	0f 2e       	mov	r0, r31
    428a:	f8 ee       	ldi	r31, 0xE8	; 232
    428c:	8f 2e       	mov	r8, r31
    428e:	f3 e0       	ldi	r31, 0x03	; 3
    4290:	9f 2e       	mov	r9, r31
    4292:	a1 2c       	mov	r10, r1
    4294:	b1 2c       	mov	r11, r1
    4296:	f0 2d       	mov	r31, r0
    4298:	e1 2c       	mov	r14, r1
    429a:	f1 2c       	mov	r15, r1
    429c:	87 01       	movw	r16, r14
    429e:	82 e0       	ldi	r24, 0x02	; 2
    42a0:	0e 94 51 18 	call	0x30a2	; 0x30a2 <csp_sendto>
    42a4:	cd bf       	out	0x3d, r28	; 61
    42a6:	de bf       	out	0x3e, r29	; 62
    42a8:	89 2b       	or	r24, r25
    42aa:	21 f4       	brne	.+8      	; 0x42b4 <AdcConvert+0xfa>
    42ac:	80 e1       	ldi	r24, 0x10	; 16
    42ae:	e0 e0       	ldi	r30, 0x00	; 0
    42b0:	f6 e0       	ldi	r31, 0x06	; 6
    42b2:	87 83       	std	Z+7, r24	; 0x07
		} else {
		/* Send failed */
	}

	return 0;
}
    42b4:	80 e0       	ldi	r24, 0x00	; 0
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	c0 5c       	subi	r28, 0xC0	; 192
    42ba:	df 4f       	sbci	r29, 0xFF	; 255
    42bc:	cd bf       	out	0x3d, r28	; 61
    42be:	de bf       	out	0x3e, r29	; 62
    42c0:	df 91       	pop	r29
    42c2:	cf 91       	pop	r28
    42c4:	1f 91       	pop	r17
    42c6:	0f 91       	pop	r16
    42c8:	ff 90       	pop	r15
    42ca:	ef 90       	pop	r14
    42cc:	df 90       	pop	r13
    42ce:	cf 90       	pop	r12
    42d0:	bf 90       	pop	r11
    42d2:	af 90       	pop	r10
    42d4:	9f 90       	pop	r9
    42d6:	8f 90       	pop	r8
    42d8:	08 95       	ret

000042da <mainTask>:

/* -------------------------------------------------------------------- */
/*	The main task														*/
/* -------------------------------------------------------------------- */
void mainTask(void *p) {
    42da:	cf 93       	push	r28
    42dc:	df 93       	push	r29
    42de:	00 d0       	rcall	.+0      	; 0x42e0 <mainTask+0x6>
    42e0:	cd b7       	in	r28, 0x3d	; 61
    42e2:	de b7       	in	r29, 0x3e	; 62
	
	/* The variable used to receive from the queue. */
	xCSPStackEvent_t xReceivedEvent;
	
	outcomingPacket = csp_buffer_get(CSP_PACKET_SIZE);
    42e4:	88 e4       	ldi	r24, 0x48	; 72
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <csp_buffer_get>
    42ec:	80 93 80 3f 	sts	0x3F80, r24
    42f0:	90 93 81 3f 	sts	0x3F81, r25
	// infinite while loop of the program 
	while (1) {
		
		// the queue between cspTask and the main task
		// this is unblocking way how to read from the queue, the last parameter is "ticks to wait"
		if (xQueueReceive(xCSPEventQueue, &xReceivedEvent, 1)) {
    42f4:	20 e0       	ldi	r18, 0x00	; 0
    42f6:	41 e0       	ldi	r20, 0x01	; 1
    42f8:	50 e0       	ldi	r21, 0x00	; 0
    42fa:	be 01       	movw	r22, r28
    42fc:	6f 5f       	subi	r22, 0xFF	; 255
    42fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4300:	80 91 d7 3e 	lds	r24, 0x3ED7
    4304:	90 91 d8 3e 	lds	r25, 0x3ED8
    4308:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <xQueueGenericReceive>
    430c:	88 23       	and	r24, r24
    430e:	91 f3       	breq	.-28     	; 0x42f4 <mainTask+0x1a>
		
			switch( xReceivedEvent.eEventType )
    4310:	89 81       	ldd	r24, Y+1	; 0x01
    4312:	81 30       	cpi	r24, 0x01	; 1
    4314:	31 f0       	breq	.+12     	; 0x4322 <mainTask+0x48>
    4316:	48 f0       	brcs	.+18     	; 0x432a <mainTask+0x50>
    4318:	82 30       	cpi	r24, 0x02	; 2
    431a:	59 f0       	breq	.+22     	; 0x4332 <mainTask+0x58>
    431c:	83 30       	cpi	r24, 0x03	; 3
    431e:	69 f0       	breq	.+26     	; 0x433a <mainTask+0x60>
    4320:	e9 cf       	rjmp	.-46     	; 0x42f4 <mainTask+0x1a>
			{
				// Reply with RTOS free heap space
				// replies in Human Readable form
				case freeHeapEvent :
			
					sendFreeHeapSpace(xReceivedEvent.pvData);
    4322:	8a 81       	ldd	r24, Y+2	; 0x02
    4324:	9b 81       	ldd	r25, Y+3	; 0x03
    4326:	f3 dd       	rcall	.-1050   	; 0x3f0e <sendFreeHeapSpace>
			
				break;
    4328:	e5 cf       	rjmp	.-54     	; 0x42f4 <mainTask+0x1a>
			
				// Echo back the whole packet
				// incoming port => outcoming
				case echoBackEvent :
			
					echoBack(xReceivedEvent.pvData);
    432a:	8a 81       	ldd	r24, Y+2	; 0x02
    432c:	9b 81       	ldd	r25, Y+3	; 0x03
    432e:	09 df       	rcall	.-494    	; 0x4142 <echoBack>
			
				break;
    4330:	e1 cf       	rjmp	.-62     	; 0x42f4 <mainTask+0x1a>
			
				// sends the info about the system
				case housKeepingEvent :
			
					houseKeeping(xReceivedEvent.pvData);
    4332:	8a 81       	ldd	r24, Y+2	; 0x02
    4334:	9b 81       	ldd	r25, Y+3	; 0x03
    4336:	53 de       	rcall	.-858    	; 0x3fde <houseKeeping>
			
				break;
    4338:	dd cf       	rjmp	.-70     	; 0x42f4 <mainTask+0x1a>
				
				case AdcConvertEvent :
				
					AdcConvert(xReceivedEvent.pvData);
    433a:	8a 81       	ldd	r24, Y+2	; 0x02
    433c:	9b 81       	ldd	r25, Y+3	; 0x03
    433e:	3d df       	rcall	.-390    	; 0x41ba <AdcConvert>
				
				break;
    4340:	d9 cf       	rjmp	.-78     	; 0x42f4 <mainTask+0x1a>

00004342 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    4342:	fc 01       	movw	r30, r24
    4344:	20 81       	ld	r18, Z
    4346:	20 7f       	andi	r18, 0xF0	; 240
    4348:	62 2b       	or	r22, r18
    434a:	60 83       	st	Z, r22
    434c:	08 95       	ret

0000434e <TC1_ConfigClockSource>:
    434e:	fc 01       	movw	r30, r24
    4350:	20 81       	ld	r18, Z
    4352:	20 7f       	andi	r18, 0xF0	; 240
    4354:	62 2b       	or	r22, r18
    4356:	60 83       	st	Z, r22
    4358:	08 95       	ret

0000435a <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    435a:	fc 01       	movw	r30, r24
    435c:	26 81       	ldd	r18, Z+6	; 0x06
    435e:	2c 7f       	andi	r18, 0xFC	; 252
    4360:	62 2b       	or	r22, r18
    4362:	66 83       	std	Z+6, r22	; 0x06
    4364:	08 95       	ret

00004366 <TC1_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC1_SetOverflowIntLevel( volatile TC1_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_OVFINTLVL_gm ) | intLevel;
    4366:	fc 01       	movw	r30, r24
    4368:	26 81       	ldd	r18, Z+6	; 0x06
    436a:	2c 7f       	andi	r18, 0xFC	; 252
    436c:	62 2b       	or	r22, r18
    436e:	66 83       	std	Z+6, r22	; 0x06
    4370:	08 95       	ret

00004372 <TWI_MasterInit>:
                    uint8_t address,
                    uint8_t bytesToRead)
{
	bool twi_status = TWI_MasterWriteRead(twi, address, 0, 0, bytesToRead);
	return twi_status;
}
    4372:	fc 01       	movw	r30, r24
    4374:	60 83       	st	Z, r22
    4376:	71 83       	std	Z+1, r23	; 0x01
    4378:	48 63       	ori	r20, 0x38	; 56
    437a:	db 01       	movw	r26, r22
    437c:	11 96       	adiw	r26, 0x01	; 1
    437e:	4c 93       	st	X, r20
    4380:	a0 81       	ld	r26, Z
    4382:	b1 81       	ldd	r27, Z+1	; 0x01
    4384:	15 96       	adiw	r26, 0x05	; 5
    4386:	2c 93       	st	X, r18
    4388:	01 90       	ld	r0, Z+
    438a:	f0 81       	ld	r31, Z
    438c:	e0 2d       	mov	r30, r0
    438e:	81 e0       	ldi	r24, 0x01	; 1
    4390:	84 83       	std	Z+4, r24	; 0x04
    4392:	08 95       	ret

00004394 <TWI_MasterWriteRead>:
    4394:	0f 93       	push	r16
    4396:	cf 93       	push	r28
    4398:	df 93       	push	r29
    439a:	29 34       	cpi	r18, 0x49	; 73
    439c:	08 f0       	brcs	.+2      	; 0x43a0 <TWI_MasterWriteRead+0xc>
    439e:	4f c0       	rjmp	.+158    	; 0x443e <TWI_MasterWriteRead+0xaa>
    43a0:	02 30       	cpi	r16, 0x02	; 2
    43a2:	08 f0       	brcs	.+2      	; 0x43a6 <TWI_MasterWriteRead+0x12>
    43a4:	4e c0       	rjmp	.+156    	; 0x4442 <TWI_MasterWriteRead+0xae>
    43a6:	fc 01       	movw	r30, r24
    43a8:	e0 5b       	subi	r30, 0xB0	; 176
    43aa:	ff 4f       	sbci	r31, 0xFF	; 255
    43ac:	30 81       	ld	r19, Z
    43ae:	31 11       	cpse	r19, r1
    43b0:	4a c0       	rjmp	.+148    	; 0x4446 <TWI_MasterWriteRead+0xb2>
    43b2:	31 e0       	ldi	r19, 0x01	; 1
    43b4:	30 83       	st	Z, r19
    43b6:	31 96       	adiw	r30, 0x01	; 1
    43b8:	10 82       	st	Z, r1
    43ba:	66 0f       	add	r22, r22
    43bc:	dc 01       	movw	r26, r24
    43be:	12 96       	adiw	r26, 0x02	; 2
    43c0:	6c 93       	st	X, r22
    43c2:	22 23       	and	r18, r18
    43c4:	a1 f0       	breq	.+40     	; 0x43ee <TWI_MasterWriteRead+0x5a>
    43c6:	ea 01       	movw	r28, r20
    43c8:	ba 01       	movw	r22, r20
    43ca:	6f 5f       	subi	r22, 0xFF	; 255
    43cc:	7f 4f       	sbci	r23, 0xFF	; 255
    43ce:	3f ef       	ldi	r19, 0xFF	; 255
    43d0:	32 0f       	add	r19, r18
    43d2:	63 0f       	add	r22, r19
    43d4:	71 1d       	adc	r23, r1
    43d6:	fa 01       	movw	r30, r20
    43d8:	df 01       	movw	r26, r30
    43da:	ac 1b       	sub	r26, r28
    43dc:	bd 0b       	sbc	r27, r29
    43de:	31 91       	ld	r19, Z+
    43e0:	a8 0f       	add	r26, r24
    43e2:	b9 1f       	adc	r27, r25
    43e4:	13 96       	adiw	r26, 0x03	; 3
    43e6:	3c 93       	st	X, r19
    43e8:	e6 17       	cp	r30, r22
    43ea:	f7 07       	cpc	r31, r23
    43ec:	a9 f7       	brne	.-22     	; 0x43d8 <TWI_MasterWriteRead+0x44>
    43ee:	fc 01       	movw	r30, r24
    43f0:	e4 5b       	subi	r30, 0xB4	; 180
    43f2:	ff 4f       	sbci	r31, 0xFF	; 255
    43f4:	20 83       	st	Z, r18
    43f6:	dc 01       	movw	r26, r24
    43f8:	a3 5b       	subi	r26, 0xB3	; 179
    43fa:	bf 4f       	sbci	r27, 0xFF	; 255
    43fc:	0c 93       	st	X, r16
    43fe:	11 96       	adiw	r26, 0x01	; 1
    4400:	1c 92       	st	X, r1
    4402:	11 96       	adiw	r26, 0x01	; 1
    4404:	1c 92       	st	X, r1
    4406:	20 81       	ld	r18, Z
    4408:	22 23       	and	r18, r18
    440a:	49 f0       	breq	.+18     	; 0x441e <TWI_MasterWriteRead+0x8a>
    440c:	fc 01       	movw	r30, r24
    440e:	22 81       	ldd	r18, Z+2	; 0x02
    4410:	2e 7f       	andi	r18, 0xFE	; 254
    4412:	01 90       	ld	r0, Z+
    4414:	f0 81       	ld	r31, Z
    4416:	e0 2d       	mov	r30, r0
    4418:	26 83       	std	Z+6, r18	; 0x06
    441a:	81 e0       	ldi	r24, 0x01	; 1
    441c:	17 c0       	rjmp	.+46     	; 0x444c <TWI_MasterWriteRead+0xb8>
    441e:	fc 01       	movw	r30, r24
    4420:	e3 5b       	subi	r30, 0xB3	; 179
    4422:	ff 4f       	sbci	r31, 0xFF	; 255
    4424:	20 81       	ld	r18, Z
    4426:	22 23       	and	r18, r18
    4428:	81 f0       	breq	.+32     	; 0x444a <TWI_MasterWriteRead+0xb6>
    442a:	dc 01       	movw	r26, r24
    442c:	12 96       	adiw	r26, 0x02	; 2
    442e:	2c 91       	ld	r18, X
    4430:	12 97       	sbiw	r26, 0x02	; 2
    4432:	21 60       	ori	r18, 0x01	; 1
    4434:	ed 91       	ld	r30, X+
    4436:	fc 91       	ld	r31, X
    4438:	26 83       	std	Z+6, r18	; 0x06
    443a:	81 e0       	ldi	r24, 0x01	; 1
    443c:	07 c0       	rjmp	.+14     	; 0x444c <TWI_MasterWriteRead+0xb8>
    443e:	80 e0       	ldi	r24, 0x00	; 0
    4440:	05 c0       	rjmp	.+10     	; 0x444c <TWI_MasterWriteRead+0xb8>
    4442:	80 e0       	ldi	r24, 0x00	; 0
    4444:	03 c0       	rjmp	.+6      	; 0x444c <TWI_MasterWriteRead+0xb8>
    4446:	80 e0       	ldi	r24, 0x00	; 0
    4448:	01 c0       	rjmp	.+2      	; 0x444c <TWI_MasterWriteRead+0xb8>
    444a:	81 e0       	ldi	r24, 0x01	; 1
    444c:	df 91       	pop	r29
    444e:	cf 91       	pop	r28
    4450:	0f 91       	pop	r16
    4452:	08 95       	ret

00004454 <TWI_MasterWrite>:
    4454:	0f 93       	push	r16
    4456:	00 e0       	ldi	r16, 0x00	; 0
    4458:	9d df       	rcall	.-198    	; 0x4394 <TWI_MasterWriteRead>
    445a:	0f 91       	pop	r16
    445c:	08 95       	ret

0000445e <TWI_MasterArbitrationLostBusErrorHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    445e:	dc 01       	movw	r26, r24
    4460:	ed 91       	ld	r30, X+
    4462:	fc 91       	ld	r31, X
    4464:	11 97       	sbiw	r26, 0x01	; 1
    4466:	24 81       	ldd	r18, Z+4	; 0x04

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    4468:	22 ff       	sbrs	r18, 2
    446a:	05 c0       	rjmp	.+10     	; 0x4476 <TWI_MasterArbitrationLostBusErrorHandler+0x18>
		twi->result = TWIM_RESULT_BUS_ERROR;
    446c:	34 e0       	ldi	r19, 0x04	; 4
    446e:	af 5a       	subi	r26, 0xAF	; 175
    4470:	bf 4f       	sbci	r27, 0xFF	; 255
    4472:	3c 93       	st	X, r19
    4474:	05 c0       	rjmp	.+10     	; 0x4480 <TWI_MasterArbitrationLostBusErrorHandler+0x22>
	}
	/* If arbitration lost. */
	else {
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
    4476:	33 e0       	ldi	r19, 0x03	; 3
    4478:	dc 01       	movw	r26, r24
    447a:	af 5a       	subi	r26, 0xAF	; 175
    447c:	bf 4f       	sbci	r27, 0xFF	; 255
    447e:	3c 93       	st	X, r19
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    4480:	28 60       	ori	r18, 0x08	; 8
    4482:	24 83       	std	Z+4, r18	; 0x04

	twi->status = TWIM_STATUS_READY;
    4484:	fc 01       	movw	r30, r24
    4486:	e0 5b       	subi	r30, 0xB0	; 176
    4488:	ff 4f       	sbci	r31, 0xFF	; 255
    448a:	10 82       	st	Z, r1
    448c:	08 95       	ret

0000448e <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
    448e:	cf 93       	push	r28
    4490:	df 93       	push	r29
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
    4492:	fc 01       	movw	r30, r24
    4494:	e4 5b       	subi	r30, 0xB4	; 180
    4496:	ff 4f       	sbci	r31, 0xFF	; 255
    4498:	30 81       	ld	r19, Z
	uint8_t bytesToRead   = twi->bytesToRead;
    449a:	31 96       	adiw	r30, 0x01	; 1
    449c:	40 81       	ld	r20, Z

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
    449e:	dc 01       	movw	r26, r24
    44a0:	ed 91       	ld	r30, X+
    44a2:	fc 91       	ld	r31, X
    44a4:	24 81       	ldd	r18, Z+4	; 0x04
    44a6:	24 ff       	sbrs	r18, 4
    44a8:	0a c0       	rjmp	.+20     	; 0x44be <TWI_MasterWriteHandler+0x30>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    44aa:	23 e0       	ldi	r18, 0x03	; 3
    44ac:	23 83       	std	Z+3, r18	; 0x03
		twi->result = TWIM_RESULT_NACK_RECEIVED;
    44ae:	fc 01       	movw	r30, r24
    44b0:	ef 5a       	subi	r30, 0xAF	; 175
    44b2:	ff 4f       	sbci	r31, 0xFF	; 255
    44b4:	25 e0       	ldi	r18, 0x05	; 5
    44b6:	20 83       	st	Z, r18
		twi->status = TWIM_STATUS_READY;
    44b8:	31 97       	sbiw	r30, 0x01	; 1
    44ba:	10 82       	st	Z, r1
    44bc:	25 c0       	rjmp	.+74     	; 0x4508 <TWI_MasterWriteHandler+0x7a>
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
    44be:	dc 01       	movw	r26, r24
    44c0:	a2 5b       	subi	r26, 0xB2	; 178
    44c2:	bf 4f       	sbci	r27, 0xFF	; 255
    44c4:	2c 91       	ld	r18, X
    44c6:	23 17       	cp	r18, r19
    44c8:	50 f4       	brcc	.+20     	; 0x44de <TWI_MasterWriteHandler+0x50>
		uint8_t data = twi->writeData[twi->bytesWritten];
    44ca:	2c 91       	ld	r18, X
    44cc:	ec 01       	movw	r28, r24
    44ce:	c2 0f       	add	r28, r18
    44d0:	d1 1d       	adc	r29, r1
    44d2:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
    44d4:	87 83       	std	Z+7, r24	; 0x07
		++twi->bytesWritten;
    44d6:	8c 91       	ld	r24, X
    44d8:	8f 5f       	subi	r24, 0xFF	; 255
    44da:	8c 93       	st	X, r24
    44dc:	15 c0       	rjmp	.+42     	; 0x4508 <TWI_MasterWriteHandler+0x7a>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
    44de:	dc 01       	movw	r26, r24
    44e0:	a1 5b       	subi	r26, 0xB1	; 177
    44e2:	bf 4f       	sbci	r27, 0xFF	; 255
    44e4:	2c 91       	ld	r18, X
    44e6:	24 17       	cp	r18, r20
    44e8:	30 f4       	brcc	.+12     	; 0x44f6 <TWI_MasterWriteHandler+0x68>
		uint8_t readAddress = twi->address | 0x01;
    44ea:	dc 01       	movw	r26, r24
    44ec:	12 96       	adiw	r26, 0x02	; 2
    44ee:	8c 91       	ld	r24, X
    44f0:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
    44f2:	86 83       	std	Z+6, r24	; 0x06
    44f4:	09 c0       	rjmp	.+18     	; 0x4508 <TWI_MasterWriteHandler+0x7a>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    44f6:	23 e0       	ldi	r18, 0x03	; 3
    44f8:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    44fa:	fc 01       	movw	r30, r24
    44fc:	ef 5a       	subi	r30, 0xAF	; 175
    44fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4500:	21 e0       	ldi	r18, 0x01	; 1
    4502:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    4504:	31 97       	sbiw	r30, 0x01	; 1
    4506:	10 82       	st	Z, r1
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
    4508:	df 91       	pop	r29
    450a:	cf 91       	pop	r28
    450c:	08 95       	ret

0000450e <TWI_MasterReadHandler>:
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) {
    450e:	fc 01       	movw	r30, r24
    4510:	e1 5b       	subi	r30, 0xB1	; 177
    4512:	ff 4f       	sbci	r31, 0xFF	; 255
    4514:	20 81       	ld	r18, Z
    4516:	21 11       	cpse	r18, r1
    4518:	12 c0       	rjmp	.+36     	; 0x453e <TWI_MasterReadHandler+0x30>
		uint8_t data = twi->interface->MASTER.DATA;
    451a:	dc 01       	movw	r26, r24
    451c:	ed 91       	ld	r30, X+
    451e:	fc 91       	ld	r31, X
    4520:	11 97       	sbiw	r26, 0x01	; 1
    4522:	27 81       	ldd	r18, Z+7	; 0x07
		twi->readData[twi->bytesRead] = data;
    4524:	fc 01       	movw	r30, r24
    4526:	e1 5b       	subi	r30, 0xB1	; 177
    4528:	ff 4f       	sbci	r31, 0xFF	; 255
    452a:	30 81       	ld	r19, Z
    452c:	a3 0f       	add	r26, r19
    452e:	b1 1d       	adc	r27, r1
    4530:	a5 5b       	subi	r26, 0xB5	; 181
    4532:	bf 4f       	sbci	r27, 0xFF	; 255
    4534:	2c 93       	st	X, r18
		twi->bytesRead++;
    4536:	20 81       	ld	r18, Z
    4538:	2f 5f       	subi	r18, 0xFF	; 255
    453a:	20 83       	st	Z, r18
    453c:	0c c0       	rjmp	.+24     	; 0x4556 <TWI_MasterReadHandler+0x48>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    453e:	dc 01       	movw	r26, r24
    4540:	ed 91       	ld	r30, X+
    4542:	fc 91       	ld	r31, X
    4544:	23 e0       	ldi	r18, 0x03	; 3
    4546:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    4548:	22 e0       	ldi	r18, 0x02	; 2
    454a:	fc 01       	movw	r30, r24
    454c:	ef 5a       	subi	r30, 0xAF	; 175
    454e:	ff 4f       	sbci	r31, 0xFF	; 255
    4550:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    4552:	31 97       	sbiw	r30, 0x01	; 1
    4554:	10 82       	st	Z, r1
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
    4556:	fc 01       	movw	r30, r24
    4558:	e3 5b       	subi	r30, 0xB3	; 179
    455a:	ff 4f       	sbci	r31, 0xFF	; 255
    455c:	30 81       	ld	r19, Z

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) {
    455e:	32 96       	adiw	r30, 0x02	; 2
    4560:	20 81       	ld	r18, Z
    4562:	23 17       	cp	r18, r19
    4564:	30 f4       	brcc	.+12     	; 0x4572 <TWI_MasterReadHandler+0x64>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    4566:	dc 01       	movw	r26, r24
    4568:	ed 91       	ld	r30, X+
    456a:	fc 91       	ld	r31, X
    456c:	82 e0       	ldi	r24, 0x02	; 2
    456e:	83 83       	std	Z+3, r24	; 0x03
    4570:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
    4572:	dc 01       	movw	r26, r24
    4574:	ed 91       	ld	r30, X+
    4576:	fc 91       	ld	r31, X
    4578:	27 e0       	ldi	r18, 0x07	; 7
    457a:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    457c:	fc 01       	movw	r30, r24
    457e:	ef 5a       	subi	r30, 0xAF	; 175
    4580:	ff 4f       	sbci	r31, 0xFF	; 255
    4582:	21 e0       	ldi	r18, 0x01	; 1
    4584:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    4586:	31 97       	sbiw	r30, 0x01	; 1
    4588:	10 82       	st	Z, r1
    458a:	08 95       	ret

0000458c <TWI_MasterInterruptHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    458c:	dc 01       	movw	r26, r24
    458e:	ed 91       	ld	r30, X+
    4590:	fc 91       	ld	r31, X
    4592:	24 81       	ldd	r18, Z+4	; 0x04
    4594:	32 2f       	mov	r19, r18
    4596:	3c 70       	andi	r19, 0x0C	; 12

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    4598:	11 f0       	breq	.+4      	; 0x459e <TWI_MasterInterruptHandler+0x12>
	    (currentStatus & TWI_MASTER_BUSERR_bm)) {

		TWI_MasterArbitrationLostBusErrorHandler(twi);
    459a:	61 cf       	rjmp	.-318    	; 0x445e <TWI_MasterArbitrationLostBusErrorHandler>
    459c:	08 95       	ret
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    459e:	26 ff       	sbrs	r18, 6
    45a0:	02 c0       	rjmp	.+4      	; 0x45a6 <TWI_MasterInterruptHandler+0x1a>
		TWI_MasterWriteHandler(twi);
    45a2:	75 cf       	rjmp	.-278    	; 0x448e <TWI_MasterWriteHandler>
    45a4:	08 95       	ret
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    45a6:	22 23       	and	r18, r18
    45a8:	14 f4       	brge	.+4      	; 0x45ae <TWI_MasterInterruptHandler+0x22>
		TWI_MasterReadHandler(twi);
    45aa:	b1 cf       	rjmp	.-158    	; 0x450e <TWI_MasterReadHandler>
    45ac:	08 95       	ret
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    45ae:	fc 01       	movw	r30, r24
    45b0:	ef 5a       	subi	r30, 0xAF	; 175
    45b2:	ff 4f       	sbci	r31, 0xFF	; 255
    45b4:	26 e0       	ldi	r18, 0x06	; 6
    45b6:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    45b8:	31 97       	sbiw	r30, 0x01	; 1
    45ba:	10 82       	st	Z, r1
    45bc:	08 95       	ret

000045be <TWI_SlaveInitializeDriver>:
 */
void TWI_SlaveInitializeDriver(TWI_Slave_t *twi,
                               TWI_t *module,
                               void (*processDataFunction) (void))
{
	twi->interface = module;
    45be:	fc 01       	movw	r30, r24
    45c0:	60 83       	st	Z, r22
    45c2:	71 83       	std	Z+1, r23	; 0x01
	twi->Process_Data = processDataFunction;
    45c4:	42 83       	std	Z+2, r20	; 0x02
    45c6:	53 83       	std	Z+3, r21	; 0x03
	twi->bytesReceived = 0;
    45c8:	e3 5b       	subi	r30, 0xB3	; 179
    45ca:	ff 4f       	sbci	r31, 0xFF	; 255
    45cc:	10 82       	st	Z, r1
	twi->bytesSent = 0;
    45ce:	31 96       	adiw	r30, 0x01	; 1
    45d0:	10 82       	st	Z, r1
	twi->status = TWIS_STATUS_READY;
    45d2:	31 96       	adiw	r30, 0x01	; 1
    45d4:	10 82       	st	Z, r1
	twi->result = TWIS_RESULT_UNKNOWN;
    45d6:	31 96       	adiw	r30, 0x01	; 1
    45d8:	10 82       	st	Z, r1
	twi->abort = false;
    45da:	31 96       	adiw	r30, 0x01	; 1
    45dc:	10 82       	st	Z, r1
    45de:	08 95       	ret

000045e0 <TWI_SlaveInitializeModule>:
 */
void TWI_SlaveInitializeModule(TWI_Slave_t *twi,
                               uint8_t address,
                               TWI_SLAVE_INTLVL_t intLevel)
{
	twi->interface->SLAVE.CTRLA = intLevel |
    45e0:	dc 01       	movw	r26, r24
    45e2:	ed 91       	ld	r30, X+
    45e4:	fc 91       	ld	r31, X
    45e6:	11 97       	sbiw	r26, 0x01	; 1
    45e8:	48 63       	ori	r20, 0x38	; 56
    45ea:	40 87       	std	Z+8, r20	; 0x08
	                              TWI_SLAVE_DIEN_bm |
	                              TWI_SLAVE_APIEN_bm |
	                              TWI_SLAVE_ENABLE_bm;
	twi->interface->SLAVE.ADDR = (address<<1);
    45ec:	ed 91       	ld	r30, X+
    45ee:	fc 91       	ld	r31, X
    45f0:	66 0f       	add	r22, r22
    45f2:	63 87       	std	Z+11, r22	; 0x0b
    45f4:	08 95       	ret

000045f6 <TWI_SlaveTransactionFinished>:
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
    45f6:	fc 01       	movw	r30, r24
    45f8:	e0 5b       	subi	r30, 0xB0	; 176
    45fa:	ff 4f       	sbci	r31, 0xFF	; 255
    45fc:	60 83       	st	Z, r22
	twi->status = TWIS_STATUS_READY;
    45fe:	31 97       	sbiw	r30, 0x01	; 1
    4600:	10 82       	st	Z, r1
	

	/* Process data. */
	twi->Process_Data();
    4602:	dc 01       	movw	r26, r24
    4604:	12 96       	adiw	r26, 0x02	; 2
    4606:	ed 91       	ld	r30, X+
    4608:	fc 91       	ld	r31, X
    460a:	13 97       	sbiw	r26, 0x03	; 3
    460c:	19 95       	eicall
    460e:	08 95       	ret

00004610 <TWI_SlaveAddressMatchHandler>:
 *  Prepares TWI module for transaction when an address match occures.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveAddressMatchHandler(TWI_Slave_t *twi)
{
    4610:	cf 93       	push	r28
    4612:	df 93       	push	r29
    4614:	ec 01       	movw	r28, r24
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
    4616:	fc 01       	movw	r30, r24
    4618:	ef 5a       	subi	r30, 0xAF	; 175
    461a:	ff 4f       	sbci	r31, 0xFF	; 255
    461c:	80 81       	ld	r24, Z
    461e:	88 23       	and	r24, r24
    4620:	59 f0       	breq	.+22     	; 0x4638 <TWI_SlaveAddressMatchHandler+0x28>
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    4622:	e8 81       	ld	r30, Y
    4624:	f9 81       	ldd	r31, Y+1	; 0x01
    4626:	82 e0       	ldi	r24, 0x02	; 2
    4628:	81 87       	std	Z+9, r24	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    462a:	66 e0       	ldi	r22, 0x06	; 6
    462c:	ce 01       	movw	r24, r28
    462e:	e3 df       	rcall	.-58     	; 0x45f6 <TWI_SlaveTransactionFinished>
		twi->abort = false;
    4630:	cf 5a       	subi	r28, 0xAF	; 175
    4632:	df 4f       	sbci	r29, 0xFF	; 255
    4634:	18 82       	st	Y, r1
    4636:	16 c0       	rjmp	.+44     	; 0x4664 <TWI_SlaveAddressMatchHandler+0x54>
	} else {
		twi->status = TWIS_STATUS_BUSY;
    4638:	fe 01       	movw	r30, r28
    463a:	e1 5b       	subi	r30, 0xB1	; 177
    463c:	ff 4f       	sbci	r31, 0xFF	; 255
    463e:	81 e0       	ldi	r24, 0x01	; 1
    4640:	80 83       	st	Z, r24
		twi->result = TWIS_RESULT_UNKNOWN;
    4642:	31 96       	adiw	r30, 0x01	; 1
    4644:	10 82       	st	Z, r1

		/* Disable stop interrupt. */
		uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    4646:	e8 81       	ld	r30, Y
    4648:	f9 81       	ldd	r31, Y+1	; 0x01
    464a:	80 85       	ldd	r24, Z+8	; 0x08
		twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    464c:	8b 7f       	andi	r24, 0xFB	; 251
    464e:	80 87       	std	Z+8, r24	; 0x08

		twi->bytesReceived = 0;
    4650:	fe 01       	movw	r30, r28
    4652:	e3 5b       	subi	r30, 0xB3	; 179
    4654:	ff 4f       	sbci	r31, 0xFF	; 255
    4656:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    4658:	31 96       	adiw	r30, 0x01	; 1
    465a:	10 82       	st	Z, r1

		/* Send ACK, wait for data interrupt. */
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    465c:	e8 81       	ld	r30, Y
    465e:	f9 81       	ldd	r31, Y+1	; 0x01
    4660:	83 e0       	ldi	r24, 0x03	; 3
    4662:	81 87       	std	Z+9, r24	; 0x09
	}
}
    4664:	df 91       	pop	r29
    4666:	cf 91       	pop	r28
    4668:	08 95       	ret

0000466a <TWI_SlaveStopHandler>:
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveStopHandler(TWI_Slave_t *twi)
{
	/* Disable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    466a:	dc 01       	movw	r26, r24
    466c:	ed 91       	ld	r30, X+
    466e:	fc 91       	ld	r31, X
    4670:	11 97       	sbiw	r26, 0x01	; 1
    4672:	20 85       	ldd	r18, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    4674:	2b 7f       	andi	r18, 0xFB	; 251
    4676:	20 87       	std	Z+8, r18	; 0x08
	
	/* Clear APIF, according to flowchart don't ACK or NACK */
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    4678:	ed 91       	ld	r30, X+
    467a:	fc 91       	ld	r31, X
    467c:	22 85       	ldd	r18, Z+10	; 0x0a
	twi->interface->SLAVE.STATUS = currentStatus | TWI_SLAVE_APIF_bm;
    467e:	20 64       	ori	r18, 0x40	; 64
    4680:	22 87       	std	Z+10, r18	; 0x0a

	TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    4682:	61 e0       	ldi	r22, 0x01	; 1
    4684:	b8 cf       	rjmp	.-144    	; 0x45f6 <TWI_SlaveTransactionFinished>
    4686:	08 95       	ret

00004688 <TWI_SlaveReadHandler>:
 *  Handles TWI slave read transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveReadHandler(TWI_Slave_t *twi)
{
    4688:	cf 93       	push	r28
    468a:	df 93       	push	r29
    468c:	ec 01       	movw	r28, r24
	/* Enable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    468e:	e8 81       	ld	r30, Y
    4690:	f9 81       	ldd	r31, Y+1	; 0x01
    4692:	80 85       	ldd	r24, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
    4694:	84 60       	ori	r24, 0x04	; 4
    4696:	80 87       	std	Z+8, r24	; 0x08

	/* If free space in buffer. */
	if (twi->bytesReceived < TWIS_RECEIVE_BUFFER_SIZE) {
    4698:	fe 01       	movw	r30, r28
    469a:	e3 5b       	subi	r30, 0xB3	; 179
    469c:	ff 4f       	sbci	r31, 0xFF	; 255
    469e:	80 81       	ld	r24, Z
    46a0:	88 34       	cpi	r24, 0x48	; 72
    46a2:	10 f5       	brcc	.+68     	; 0x46e8 <TWI_SlaveReadHandler+0x60>
		/* Fetch data */
		uint8_t data = twi->interface->SLAVE.DATA;
    46a4:	68 81       	ld	r22, Y
    46a6:	79 81       	ldd	r23, Y+1	; 0x01
    46a8:	db 01       	movw	r26, r22
    46aa:	1c 96       	adiw	r26, 0x0c	; 12
    46ac:	2c 91       	ld	r18, X
		twi->receivedData[twi->bytesReceived] = data;
    46ae:	80 81       	ld	r24, Z
    46b0:	ae 01       	movw	r20, r28
    46b2:	48 0f       	add	r20, r24
    46b4:	51 1d       	adc	r21, r1
    46b6:	da 01       	movw	r26, r20
    46b8:	14 96       	adiw	r26, 0x04	; 4
    46ba:	2c 93       	st	X, r18

		twi->bytesReceived++;
    46bc:	80 81       	ld	r24, Z
    46be:	8f 5f       	subi	r24, 0xFF	; 255
    46c0:	80 83       	st	Z, r24

		/* If application signalling need to abort (error occured),
		 * complete transaction and wait for next START. Otherwise
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
    46c2:	34 96       	adiw	r30, 0x04	; 4
    46c4:	80 81       	ld	r24, Z
    46c6:	88 23       	and	r24, r24
    46c8:	51 f0       	breq	.+20     	; 0x46de <TWI_SlaveReadHandler+0x56>
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    46ca:	82 e0       	ldi	r24, 0x02	; 2
    46cc:	fb 01       	movw	r30, r22
    46ce:	81 87       	std	Z+9, r24	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    46d0:	66 e0       	ldi	r22, 0x06	; 6
    46d2:	ce 01       	movw	r24, r28
    46d4:	90 df       	rcall	.-224    	; 0x45f6 <TWI_SlaveTransactionFinished>
			twi->abort = false;
    46d6:	cf 5a       	subi	r28, 0xAF	; 175
    46d8:	df 4f       	sbci	r29, 0xFF	; 255
    46da:	18 82       	st	Y, r1
    46dc:	0c c0       	rjmp	.+24     	; 0x46f6 <TWI_SlaveReadHandler+0x6e>
		} else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    46de:	83 e0       	ldi	r24, 0x03	; 3
    46e0:	db 01       	movw	r26, r22
    46e2:	19 96       	adiw	r26, 0x09	; 9
    46e4:	8c 93       	st	X, r24
    46e6:	07 c0       	rjmp	.+14     	; 0x46f6 <TWI_SlaveReadHandler+0x6e>
	}
	/* If buffer overflow, send NACK and wait for next START. Set
	 * result buffer overflow.
	 */
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
    46e8:	e8 81       	ld	r30, Y
    46ea:	f9 81       	ldd	r31, Y+1	; 0x01
    46ec:	86 e0       	ldi	r24, 0x06	; 6
    46ee:	81 87       	std	Z+9, r24	; 0x09
		                              TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    46f0:	62 e0       	ldi	r22, 0x02	; 2
    46f2:	ce 01       	movw	r24, r28
    46f4:	80 df       	rcall	.-256    	; 0x45f6 <TWI_SlaveTransactionFinished>
	}
}
    46f6:	df 91       	pop	r29
    46f8:	cf 91       	pop	r28
    46fa:	08 95       	ret

000046fc <TWI_SlaveWriteHandler>:
 *  Handles TWI slave write transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
{
    46fc:	cf 93       	push	r28
    46fe:	df 93       	push	r29
	/* If NACK, slave write transaction finished. */
	if ((twi->bytesSent > 0) && (twi->interface->SLAVE.STATUS &
    4700:	fc 01       	movw	r30, r24
    4702:	e2 5b       	subi	r30, 0xB2	; 178
    4704:	ff 4f       	sbci	r31, 0xFF	; 255
    4706:	20 81       	ld	r18, Z
    4708:	22 23       	and	r18, r18
    470a:	59 f0       	breq	.+22     	; 0x4722 <TWI_SlaveWriteHandler+0x26>
    470c:	dc 01       	movw	r26, r24
    470e:	ed 91       	ld	r30, X+
    4710:	fc 91       	ld	r31, X
    4712:	22 85       	ldd	r18, Z+10	; 0x0a
    4714:	24 ff       	sbrs	r18, 4
    4716:	05 c0       	rjmp	.+10     	; 0x4722 <TWI_SlaveWriteHandler+0x26>
	                             TWI_SLAVE_RXACK_bm)) {

		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    4718:	22 e0       	ldi	r18, 0x02	; 2
    471a:	21 87       	std	Z+9, r18	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    471c:	61 e0       	ldi	r22, 0x01	; 1
    471e:	6b df       	rcall	.-298    	; 0x45f6 <TWI_SlaveTransactionFinished>
    4720:	21 c0       	rjmp	.+66     	; 0x4764 <TWI_SlaveWriteHandler+0x68>
	}
	/* If ACK, master expects more data. */
	else {
		if (twi->bytesSent < TWIS_SEND_BUFFER_SIZE) {
    4722:	fc 01       	movw	r30, r24
    4724:	e2 5b       	subi	r30, 0xB2	; 178
    4726:	ff 4f       	sbci	r31, 0xFF	; 255
    4728:	20 81       	ld	r18, Z
    472a:	21 11       	cpse	r18, r1
    472c:	14 c0       	rjmp	.+40     	; 0x4756 <TWI_SlaveWriteHandler+0x5a>
			uint8_t data = twi->sendData[twi->bytesSent];
    472e:	20 81       	ld	r18, Z
    4730:	dc 01       	movw	r26, r24
    4732:	a2 0f       	add	r26, r18
    4734:	b1 1d       	adc	r27, r1
    4736:	a4 5b       	subi	r26, 0xB4	; 180
    4738:	bf 4f       	sbci	r27, 0xFF	; 255
    473a:	2c 91       	ld	r18, X
			twi->interface->SLAVE.DATA = data;
    473c:	ec 01       	movw	r28, r24
    473e:	a8 81       	ld	r26, Y
    4740:	b9 81       	ldd	r27, Y+1	; 0x01
    4742:	1c 96       	adiw	r26, 0x0c	; 12
    4744:	2c 93       	st	X, r18
			twi->bytesSent++;
    4746:	20 81       	ld	r18, Z
    4748:	2f 5f       	subi	r18, 0xFF	; 255
    474a:	20 83       	st	Z, r18

			/* Send data, wait for data interrupt. */
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    474c:	e8 81       	ld	r30, Y
    474e:	f9 81       	ldd	r31, Y+1	; 0x01
    4750:	83 e0       	ldi	r24, 0x03	; 3
    4752:	81 87       	std	Z+9, r24	; 0x09
    4754:	07 c0       	rjmp	.+14     	; 0x4764 <TWI_SlaveWriteHandler+0x68>
		}
		/* If buffer overflow. */
		else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    4756:	dc 01       	movw	r26, r24
    4758:	ed 91       	ld	r30, X+
    475a:	fc 91       	ld	r31, X
    475c:	22 e0       	ldi	r18, 0x02	; 2
    475e:	21 87       	std	Z+9, r18	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    4760:	62 e0       	ldi	r22, 0x02	; 2
    4762:	49 df       	rcall	.-366    	; 0x45f6 <TWI_SlaveTransactionFinished>
		}
	}
}
    4764:	df 91       	pop	r29
    4766:	cf 91       	pop	r28
    4768:	08 95       	ret

0000476a <TWI_SlaveDataHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveDataHandler(TWI_Slave_t *twi)
{
	if (twi->interface->SLAVE.STATUS & TWI_SLAVE_DIR_bm) {
    476a:	dc 01       	movw	r26, r24
    476c:	ed 91       	ld	r30, X+
    476e:	fc 91       	ld	r31, X
    4770:	22 85       	ldd	r18, Z+10	; 0x0a
    4772:	21 ff       	sbrs	r18, 1
    4774:	02 c0       	rjmp	.+4      	; 0x477a <TWI_SlaveDataHandler+0x10>
		TWI_SlaveWriteHandler(twi);
    4776:	c2 cf       	rjmp	.-124    	; 0x46fc <TWI_SlaveWriteHandler>
    4778:	08 95       	ret
	} else {
		TWI_SlaveReadHandler(twi);
    477a:	86 cf       	rjmp	.-244    	; 0x4688 <TWI_SlaveReadHandler>
    477c:	08 95       	ret

0000477e <TWI_SlaveInterruptHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveInterruptHandler(TWI_Slave_t *twi)
{
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    477e:	dc 01       	movw	r26, r24
    4780:	ed 91       	ld	r30, X+
    4782:	fc 91       	ld	r31, X
    4784:	22 85       	ldd	r18, Z+10	; 0x0a

	/* If bus error. */
	if (currentStatus & TWI_SLAVE_BUSERR_bm) {
    4786:	22 ff       	sbrs	r18, 2
    4788:	0c c0       	rjmp	.+24     	; 0x47a2 <TWI_SlaveInterruptHandler+0x24>
		twi->bytesReceived = 0;
    478a:	fc 01       	movw	r30, r24
    478c:	e3 5b       	subi	r30, 0xB3	; 179
    478e:	ff 4f       	sbci	r31, 0xFF	; 255
    4790:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    4792:	31 96       	adiw	r30, 0x01	; 1
    4794:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_BUS_ERROR;
    4796:	32 96       	adiw	r30, 0x02	; 2
    4798:	24 e0       	ldi	r18, 0x04	; 4
    479a:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    479c:	31 97       	sbiw	r30, 0x01	; 1
    479e:	10 82       	st	Z, r1
    47a0:	08 95       	ret
	}

	/* If transmit collision. */
	else if (currentStatus & TWI_SLAVE_COLL_bm) {
    47a2:	23 ff       	sbrs	r18, 3
    47a4:	0c c0       	rjmp	.+24     	; 0x47be <TWI_SlaveInterruptHandler+0x40>
		twi->bytesReceived = 0;
    47a6:	fc 01       	movw	r30, r24
    47a8:	e3 5b       	subi	r30, 0xB3	; 179
    47aa:	ff 4f       	sbci	r31, 0xFF	; 255
    47ac:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    47ae:	31 96       	adiw	r30, 0x01	; 1
    47b0:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_TRANSMIT_COLLISION;
    47b2:	32 96       	adiw	r30, 0x02	; 2
    47b4:	23 e0       	ldi	r18, 0x03	; 3
    47b6:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    47b8:	31 97       	sbiw	r30, 0x01	; 1
    47ba:	10 82       	st	Z, r1
    47bc:	08 95       	ret
	}

	/* If address match. */
	else if ((currentStatus & TWI_SLAVE_APIF_bm) &&
    47be:	42 2f       	mov	r20, r18
    47c0:	40 74       	andi	r20, 0x40	; 64
    47c2:	32 2f       	mov	r19, r18
    47c4:	31 74       	andi	r19, 0x41	; 65
    47c6:	31 34       	cpi	r19, 0x41	; 65
    47c8:	11 f4       	brne	.+4      	; 0x47ce <TWI_SlaveInterruptHandler+0x50>
	        (currentStatus & TWI_SLAVE_AP_bm)) {

		TWI_SlaveAddressMatchHandler(twi);
    47ca:	22 cf       	rjmp	.-444    	; 0x4610 <TWI_SlaveAddressMatchHandler>
    47cc:	08 95       	ret
	}

	/* If stop (only enabled through slave read transaction). */
	else if (currentStatus & TWI_SLAVE_APIF_bm) {
    47ce:	44 23       	and	r20, r20
    47d0:	11 f0       	breq	.+4      	; 0x47d6 <TWI_SlaveInterruptHandler+0x58>
		TWI_SlaveStopHandler(twi);
    47d2:	4b cf       	rjmp	.-362    	; 0x466a <TWI_SlaveStopHandler>
    47d4:	08 95       	ret
	}

	/* If data interrupt. */
	else if (currentStatus & TWI_SLAVE_DIF_bm) {
    47d6:	22 23       	and	r18, r18
    47d8:	14 f4       	brge	.+4      	; 0x47de <TWI_SlaveInterruptHandler+0x60>
		TWI_SlaveDataHandler(twi);
    47da:	c7 cf       	rjmp	.-114    	; 0x476a <TWI_SlaveDataHandler>
    47dc:	08 95       	ret
	}

	/* If unexpected state. */
	else {
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_FAIL);
    47de:	65 e0       	ldi	r22, 0x05	; 5
    47e0:	0a cf       	rjmp	.-492    	; 0x45f6 <TWI_SlaveTransactionFinished>
    47e2:	08 95       	ret

000047e4 <__vector_25>:
 *
 *  Receive complete interrupt service routine.
 *  Calls the common receive complete handler with pointer to the correct USART
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
    47e4:	1f 92       	push	r1
    47e6:	0f 92       	push	r0
    47e8:	0f b6       	in	r0, 0x3f	; 63
    47ea:	0f 92       	push	r0
    47ec:	11 24       	eor	r1, r1
    47ee:	0b b6       	in	r0, 0x3b	; 59
    47f0:	0f 92       	push	r0
    47f2:	2f 93       	push	r18
    47f4:	3f 93       	push	r19
    47f6:	4f 93       	push	r20
    47f8:	5f 93       	push	r21
    47fa:	6f 93       	push	r22
    47fc:	7f 93       	push	r23
    47fe:	8f 93       	push	r24
    4800:	9f 93       	push	r25
    4802:	af 93       	push	r26
    4804:	bf 93       	push	r27
    4806:	ef 93       	push	r30
    4808:	ff 93       	push	r31
    480a:	cf 93       	push	r28
    480c:	df 93       	push	r29
    480e:	1f 92       	push	r1
    4810:	1f 92       	push	r1
    4812:	cd b7       	in	r28, 0x3d	; 61
    4814:	de b7       	in	r29, 0x3e	; 62
    4816:	e0 91 88 3f 	lds	r30, 0x3F88
    481a:	f0 91 89 3f 	lds	r31, 0x3F89
inline signed char USART_RXComplete(UsartBuffer * usartBuffer)
{
	/* We have to check is we have woke higher priority task, because we post to
	 * queue and high priority task might be blocked waiting for items appear on
	 * this queue */
	signed char xHigherPriorityTaskWoken = pdFALSE;
    481e:	1a 82       	std	Y+2, r1	; 0x02
	signed char cChar;
	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = usartBuffer->usart->DATA;
    4820:	a0 81       	ld	r26, Z
    4822:	b1 81       	ldd	r27, Z+1	; 0x01
    4824:	8c 91       	ld	r24, X
    4826:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBackFromISR( usartBuffer->xQueueRX, &cChar, &xHigherPriorityTaskWoken );
    4828:	20 e0       	ldi	r18, 0x00	; 0
    482a:	ae 01       	movw	r20, r28
    482c:	4e 5f       	subi	r20, 0xFE	; 254
    482e:	5f 4f       	sbci	r21, 0xFF	; 255
    4830:	be 01       	movw	r22, r28
    4832:	6f 5f       	subi	r22, 0xFF	; 255
    4834:	7f 4f       	sbci	r23, 0xFF	; 255
    4836:	83 81       	ldd	r24, Z+3	; 0x03
    4838:	94 81       	ldd	r25, Z+4	; 0x04
    483a:	0e 94 c6 08 	call	0x118c	; 0x118c <xQueueGenericSendFromISR>
	return xHigherPriorityTaskWoken;
    483e:	8a 81       	ldd	r24, Y+2	; 0x02
 *
 *  Receive complete interrupt service routine.
 *  Calls the common receive complete handler with pointer to the correct USART
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
    4840:	81 11       	cpse	r24, r1
    4842:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vPortYield>
    4846:	0f 90       	pop	r0
    4848:	0f 90       	pop	r0
    484a:	df 91       	pop	r29
    484c:	cf 91       	pop	r28
    484e:	ff 91       	pop	r31
    4850:	ef 91       	pop	r30
    4852:	bf 91       	pop	r27
    4854:	af 91       	pop	r26
    4856:	9f 91       	pop	r25
    4858:	8f 91       	pop	r24
    485a:	7f 91       	pop	r23
    485c:	6f 91       	pop	r22
    485e:	5f 91       	pop	r21
    4860:	4f 91       	pop	r20
    4862:	3f 91       	pop	r19
    4864:	2f 91       	pop	r18
    4866:	0f 90       	pop	r0
    4868:	0b be       	out	0x3b, r0	; 59
    486a:	0f 90       	pop	r0
    486c:	0f be       	out	0x3f, r0	; 63
    486e:	0f 90       	pop	r0
    4870:	1f 90       	pop	r1
    4872:	18 95       	reti

00004874 <__vector_88>:
ISR(USARTD0_RXC_vect){ if( USART_RXComplete(usartBufferD) ) taskYIELD(); }
    4874:	1f 92       	push	r1
    4876:	0f 92       	push	r0
    4878:	0f b6       	in	r0, 0x3f	; 63
    487a:	0f 92       	push	r0
    487c:	11 24       	eor	r1, r1
    487e:	0b b6       	in	r0, 0x3b	; 59
    4880:	0f 92       	push	r0
    4882:	2f 93       	push	r18
    4884:	3f 93       	push	r19
    4886:	4f 93       	push	r20
    4888:	5f 93       	push	r21
    488a:	6f 93       	push	r22
    488c:	7f 93       	push	r23
    488e:	8f 93       	push	r24
    4890:	9f 93       	push	r25
    4892:	af 93       	push	r26
    4894:	bf 93       	push	r27
    4896:	ef 93       	push	r30
    4898:	ff 93       	push	r31
    489a:	cf 93       	push	r28
    489c:	df 93       	push	r29
    489e:	1f 92       	push	r1
    48a0:	1f 92       	push	r1
    48a2:	cd b7       	in	r28, 0x3d	; 61
    48a4:	de b7       	in	r29, 0x3e	; 62
    48a6:	e0 91 86 3f 	lds	r30, 0x3F86
    48aa:	f0 91 87 3f 	lds	r31, 0x3F87
inline signed char USART_RXComplete(UsartBuffer * usartBuffer)
{
	/* We have to check is we have woke higher priority task, because we post to
	 * queue and high priority task might be blocked waiting for items appear on
	 * this queue */
	signed char xHigherPriorityTaskWoken = pdFALSE;
    48ae:	1a 82       	std	Y+2, r1	; 0x02
	signed char cChar;
	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = usartBuffer->usart->DATA;
    48b0:	a0 81       	ld	r26, Z
    48b2:	b1 81       	ldd	r27, Z+1	; 0x01
    48b4:	8c 91       	ld	r24, X
    48b6:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBackFromISR( usartBuffer->xQueueRX, &cChar, &xHigherPriorityTaskWoken );
    48b8:	20 e0       	ldi	r18, 0x00	; 0
    48ba:	ae 01       	movw	r20, r28
    48bc:	4e 5f       	subi	r20, 0xFE	; 254
    48be:	5f 4f       	sbci	r21, 0xFF	; 255
    48c0:	be 01       	movw	r22, r28
    48c2:	6f 5f       	subi	r22, 0xFF	; 255
    48c4:	7f 4f       	sbci	r23, 0xFF	; 255
    48c6:	83 81       	ldd	r24, Z+3	; 0x03
    48c8:	94 81       	ldd	r25, Z+4	; 0x04
    48ca:	0e 94 c6 08 	call	0x118c	; 0x118c <xQueueGenericSendFromISR>
	return xHigherPriorityTaskWoken;
    48ce:	8a 81       	ldd	r24, Y+2	; 0x02
 *  Receive complete interrupt service routine.
 *  Calls the common receive complete handler with pointer to the correct USART
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
ISR(USARTD0_RXC_vect){ if( USART_RXComplete(usartBufferD) ) taskYIELD(); }
    48d0:	81 11       	cpse	r24, r1
    48d2:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vPortYield>
    48d6:	0f 90       	pop	r0
    48d8:	0f 90       	pop	r0
    48da:	df 91       	pop	r29
    48dc:	cf 91       	pop	r28
    48de:	ff 91       	pop	r31
    48e0:	ef 91       	pop	r30
    48e2:	bf 91       	pop	r27
    48e4:	af 91       	pop	r26
    48e6:	9f 91       	pop	r25
    48e8:	8f 91       	pop	r24
    48ea:	7f 91       	pop	r23
    48ec:	6f 91       	pop	r22
    48ee:	5f 91       	pop	r21
    48f0:	4f 91       	pop	r20
    48f2:	3f 91       	pop	r19
    48f4:	2f 91       	pop	r18
    48f6:	0f 90       	pop	r0
    48f8:	0b be       	out	0x3b, r0	; 59
    48fa:	0f 90       	pop	r0
    48fc:	0f be       	out	0x3f, r0	; 63
    48fe:	0f 90       	pop	r0
    4900:	1f 90       	pop	r1
    4902:	18 95       	reti

00004904 <__vector_58>:
ISR(USARTE0_RXC_vect){ if( USART_RXComplete(usartBufferE) ) taskYIELD(); }
    4904:	1f 92       	push	r1
    4906:	0f 92       	push	r0
    4908:	0f b6       	in	r0, 0x3f	; 63
    490a:	0f 92       	push	r0
    490c:	11 24       	eor	r1, r1
    490e:	0b b6       	in	r0, 0x3b	; 59
    4910:	0f 92       	push	r0
    4912:	2f 93       	push	r18
    4914:	3f 93       	push	r19
    4916:	4f 93       	push	r20
    4918:	5f 93       	push	r21
    491a:	6f 93       	push	r22
    491c:	7f 93       	push	r23
    491e:	8f 93       	push	r24
    4920:	9f 93       	push	r25
    4922:	af 93       	push	r26
    4924:	bf 93       	push	r27
    4926:	ef 93       	push	r30
    4928:	ff 93       	push	r31
    492a:	cf 93       	push	r28
    492c:	df 93       	push	r29
    492e:	1f 92       	push	r1
    4930:	1f 92       	push	r1
    4932:	cd b7       	in	r28, 0x3d	; 61
    4934:	de b7       	in	r29, 0x3e	; 62
    4936:	e0 91 84 3f 	lds	r30, 0x3F84
    493a:	f0 91 85 3f 	lds	r31, 0x3F85
inline signed char USART_RXComplete(UsartBuffer * usartBuffer)
{
	/* We have to check is we have woke higher priority task, because we post to
	 * queue and high priority task might be blocked waiting for items appear on
	 * this queue */
	signed char xHigherPriorityTaskWoken = pdFALSE;
    493e:	1a 82       	std	Y+2, r1	; 0x02
	signed char cChar;
	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = usartBuffer->usart->DATA;
    4940:	a0 81       	ld	r26, Z
    4942:	b1 81       	ldd	r27, Z+1	; 0x01
    4944:	8c 91       	ld	r24, X
    4946:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBackFromISR( usartBuffer->xQueueRX, &cChar, &xHigherPriorityTaskWoken );
    4948:	20 e0       	ldi	r18, 0x00	; 0
    494a:	ae 01       	movw	r20, r28
    494c:	4e 5f       	subi	r20, 0xFE	; 254
    494e:	5f 4f       	sbci	r21, 0xFF	; 255
    4950:	be 01       	movw	r22, r28
    4952:	6f 5f       	subi	r22, 0xFF	; 255
    4954:	7f 4f       	sbci	r23, 0xFF	; 255
    4956:	83 81       	ldd	r24, Z+3	; 0x03
    4958:	94 81       	ldd	r25, Z+4	; 0x04
    495a:	0e 94 c6 08 	call	0x118c	; 0x118c <xQueueGenericSendFromISR>
	return xHigherPriorityTaskWoken;
    495e:	8a 81       	ldd	r24, Y+2	; 0x02
 *  Calls the common receive complete handler with pointer to the correct USART
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
ISR(USARTD0_RXC_vect){ if( USART_RXComplete(usartBufferD) ) taskYIELD(); }
ISR(USARTE0_RXC_vect){ if( USART_RXComplete(usartBufferE) ) taskYIELD(); }
    4960:	81 11       	cpse	r24, r1
    4962:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vPortYield>
    4966:	0f 90       	pop	r0
    4968:	0f 90       	pop	r0
    496a:	df 91       	pop	r29
    496c:	cf 91       	pop	r28
    496e:	ff 91       	pop	r31
    4970:	ef 91       	pop	r30
    4972:	bf 91       	pop	r27
    4974:	af 91       	pop	r26
    4976:	9f 91       	pop	r25
    4978:	8f 91       	pop	r24
    497a:	7f 91       	pop	r23
    497c:	6f 91       	pop	r22
    497e:	5f 91       	pop	r21
    4980:	4f 91       	pop	r20
    4982:	3f 91       	pop	r19
    4984:	2f 91       	pop	r18
    4986:	0f 90       	pop	r0
    4988:	0b be       	out	0x3b, r0	; 59
    498a:	0f 90       	pop	r0
    498c:	0f be       	out	0x3f, r0	; 63
    498e:	0f 90       	pop	r0
    4990:	1f 90       	pop	r1
    4992:	18 95       	reti

00004994 <__vector_119>:
ISR(USARTF0_RXC_vect){ if( USART_RXComplete(usartBufferF) ) taskYIELD(); }
    4994:	1f 92       	push	r1
    4996:	0f 92       	push	r0
    4998:	0f b6       	in	r0, 0x3f	; 63
    499a:	0f 92       	push	r0
    499c:	11 24       	eor	r1, r1
    499e:	0b b6       	in	r0, 0x3b	; 59
    49a0:	0f 92       	push	r0
    49a2:	2f 93       	push	r18
    49a4:	3f 93       	push	r19
    49a6:	4f 93       	push	r20
    49a8:	5f 93       	push	r21
    49aa:	6f 93       	push	r22
    49ac:	7f 93       	push	r23
    49ae:	8f 93       	push	r24
    49b0:	9f 93       	push	r25
    49b2:	af 93       	push	r26
    49b4:	bf 93       	push	r27
    49b6:	ef 93       	push	r30
    49b8:	ff 93       	push	r31
    49ba:	cf 93       	push	r28
    49bc:	df 93       	push	r29
    49be:	1f 92       	push	r1
    49c0:	1f 92       	push	r1
    49c2:	cd b7       	in	r28, 0x3d	; 61
    49c4:	de b7       	in	r29, 0x3e	; 62
    49c6:	e0 91 82 3f 	lds	r30, 0x3F82
    49ca:	f0 91 83 3f 	lds	r31, 0x3F83
inline signed char USART_RXComplete(UsartBuffer * usartBuffer)
{
	/* We have to check is we have woke higher priority task, because we post to
	 * queue and high priority task might be blocked waiting for items appear on
	 * this queue */
	signed char xHigherPriorityTaskWoken = pdFALSE;
    49ce:	1a 82       	std	Y+2, r1	; 0x02
	signed char cChar;
	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = usartBuffer->usart->DATA;
    49d0:	a0 81       	ld	r26, Z
    49d2:	b1 81       	ldd	r27, Z+1	; 0x01
    49d4:	8c 91       	ld	r24, X
    49d6:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBackFromISR( usartBuffer->xQueueRX, &cChar, &xHigherPriorityTaskWoken );
    49d8:	20 e0       	ldi	r18, 0x00	; 0
    49da:	ae 01       	movw	r20, r28
    49dc:	4e 5f       	subi	r20, 0xFE	; 254
    49de:	5f 4f       	sbci	r21, 0xFF	; 255
    49e0:	be 01       	movw	r22, r28
    49e2:	6f 5f       	subi	r22, 0xFF	; 255
    49e4:	7f 4f       	sbci	r23, 0xFF	; 255
    49e6:	83 81       	ldd	r24, Z+3	; 0x03
    49e8:	94 81       	ldd	r25, Z+4	; 0x04
    49ea:	0e 94 c6 08 	call	0x118c	; 0x118c <xQueueGenericSendFromISR>
	return xHigherPriorityTaskWoken;
    49ee:	8a 81       	ldd	r24, Y+2	; 0x02
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
ISR(USARTD0_RXC_vect){ if( USART_RXComplete(usartBufferD) ) taskYIELD(); }
ISR(USARTE0_RXC_vect){ if( USART_RXComplete(usartBufferE) ) taskYIELD(); }
ISR(USARTF0_RXC_vect){ if( USART_RXComplete(usartBufferF) ) taskYIELD(); }
    49f0:	81 11       	cpse	r24, r1
    49f2:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vPortYield>
    49f6:	0f 90       	pop	r0
    49f8:	0f 90       	pop	r0
    49fa:	df 91       	pop	r29
    49fc:	cf 91       	pop	r28
    49fe:	ff 91       	pop	r31
    4a00:	ef 91       	pop	r30
    4a02:	bf 91       	pop	r27
    4a04:	af 91       	pop	r26
    4a06:	9f 91       	pop	r25
    4a08:	8f 91       	pop	r24
    4a0a:	7f 91       	pop	r23
    4a0c:	6f 91       	pop	r22
    4a0e:	5f 91       	pop	r21
    4a10:	4f 91       	pop	r20
    4a12:	3f 91       	pop	r19
    4a14:	2f 91       	pop	r18
    4a16:	0f 90       	pop	r0
    4a18:	0b be       	out	0x3b, r0	; 59
    4a1a:	0f 90       	pop	r0
    4a1c:	0f be       	out	0x3f, r0	; 63
    4a1e:	0f 90       	pop	r0
    4a20:	1f 90       	pop	r1
    4a22:	18 95       	reti

00004a24 <__vector_26>:
 *
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
    4a24:	1f 92       	push	r1
    4a26:	0f 92       	push	r0
    4a28:	0f b6       	in	r0, 0x3f	; 63
    4a2a:	0f 92       	push	r0
    4a2c:	11 24       	eor	r1, r1
    4a2e:	0b b6       	in	r0, 0x3b	; 59
    4a30:	0f 92       	push	r0
    4a32:	0f 93       	push	r16
    4a34:	1f 93       	push	r17
    4a36:	2f 93       	push	r18
    4a38:	3f 93       	push	r19
    4a3a:	4f 93       	push	r20
    4a3c:	5f 93       	push	r21
    4a3e:	6f 93       	push	r22
    4a40:	7f 93       	push	r23
    4a42:	8f 93       	push	r24
    4a44:	9f 93       	push	r25
    4a46:	af 93       	push	r26
    4a48:	bf 93       	push	r27
    4a4a:	ef 93       	push	r30
    4a4c:	ff 93       	push	r31
    4a4e:	cf 93       	push	r28
    4a50:	df 93       	push	r29
    4a52:	1f 92       	push	r1
    4a54:	1f 92       	push	r1
    4a56:	cd b7       	in	r28, 0x3d	; 61
    4a58:	de b7       	in	r29, 0x3e	; 62
    4a5a:	00 91 88 3f 	lds	r16, 0x3F88
    4a5e:	10 91 89 3f 	lds	r17, 0x3F89
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    4a62:	ae 01       	movw	r20, r28
    4a64:	4f 5f       	subi	r20, 0xFF	; 255
    4a66:	5f 4f       	sbci	r21, 0xFF	; 255
    4a68:	be 01       	movw	r22, r28
    4a6a:	6e 5f       	subi	r22, 0xFE	; 254
    4a6c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a6e:	d8 01       	movw	r26, r16
    4a70:	15 96       	adiw	r26, 0x05	; 5
    4a72:	8d 91       	ld	r24, X+
    4a74:	9c 91       	ld	r25, X
    4a76:	16 97       	sbiw	r26, 0x06	; 6
    4a78:	0e 94 9e 09 	call	0x133c	; 0x133c <xQueueReceiveFromISR>
    4a7c:	81 30       	cpi	r24, 0x01	; 1
    4a7e:	31 f4       	brne	.+12     	; 0x4a8c <__vector_26+0x68>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    4a80:	d8 01       	movw	r26, r16
    4a82:	ed 91       	ld	r30, X+
    4a84:	fc 91       	ld	r31, X
    4a86:	8a 81       	ldd	r24, Y+2	; 0x02
    4a88:	80 83       	st	Z, r24
    4a8a:	06 c0       	rjmp	.+12     	; 0x4a98 <__vector_26+0x74>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    4a8c:	d8 01       	movw	r26, r16
    4a8e:	ed 91       	ld	r30, X+
    4a90:	fc 91       	ld	r31, X
    4a92:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    4a94:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    4a96:	83 83       	std	Z+3, r24	; 0x03
 *
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
    4a98:	0f 90       	pop	r0
    4a9a:	0f 90       	pop	r0
    4a9c:	df 91       	pop	r29
    4a9e:	cf 91       	pop	r28
    4aa0:	ff 91       	pop	r31
    4aa2:	ef 91       	pop	r30
    4aa4:	bf 91       	pop	r27
    4aa6:	af 91       	pop	r26
    4aa8:	9f 91       	pop	r25
    4aaa:	8f 91       	pop	r24
    4aac:	7f 91       	pop	r23
    4aae:	6f 91       	pop	r22
    4ab0:	5f 91       	pop	r21
    4ab2:	4f 91       	pop	r20
    4ab4:	3f 91       	pop	r19
    4ab6:	2f 91       	pop	r18
    4ab8:	1f 91       	pop	r17
    4aba:	0f 91       	pop	r16
    4abc:	0f 90       	pop	r0
    4abe:	0b be       	out	0x3b, r0	; 59
    4ac0:	0f 90       	pop	r0
    4ac2:	0f be       	out	0x3f, r0	; 63
    4ac4:	0f 90       	pop	r0
    4ac6:	1f 90       	pop	r1
    4ac8:	18 95       	reti

00004aca <__vector_89>:
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
    4aca:	1f 92       	push	r1
    4acc:	0f 92       	push	r0
    4ace:	0f b6       	in	r0, 0x3f	; 63
    4ad0:	0f 92       	push	r0
    4ad2:	11 24       	eor	r1, r1
    4ad4:	0b b6       	in	r0, 0x3b	; 59
    4ad6:	0f 92       	push	r0
    4ad8:	0f 93       	push	r16
    4ada:	1f 93       	push	r17
    4adc:	2f 93       	push	r18
    4ade:	3f 93       	push	r19
    4ae0:	4f 93       	push	r20
    4ae2:	5f 93       	push	r21
    4ae4:	6f 93       	push	r22
    4ae6:	7f 93       	push	r23
    4ae8:	8f 93       	push	r24
    4aea:	9f 93       	push	r25
    4aec:	af 93       	push	r26
    4aee:	bf 93       	push	r27
    4af0:	ef 93       	push	r30
    4af2:	ff 93       	push	r31
    4af4:	cf 93       	push	r28
    4af6:	df 93       	push	r29
    4af8:	1f 92       	push	r1
    4afa:	1f 92       	push	r1
    4afc:	cd b7       	in	r28, 0x3d	; 61
    4afe:	de b7       	in	r29, 0x3e	; 62
    4b00:	00 91 86 3f 	lds	r16, 0x3F86
    4b04:	10 91 87 3f 	lds	r17, 0x3F87
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    4b08:	ae 01       	movw	r20, r28
    4b0a:	4f 5f       	subi	r20, 0xFF	; 255
    4b0c:	5f 4f       	sbci	r21, 0xFF	; 255
    4b0e:	be 01       	movw	r22, r28
    4b10:	6e 5f       	subi	r22, 0xFE	; 254
    4b12:	7f 4f       	sbci	r23, 0xFF	; 255
    4b14:	d8 01       	movw	r26, r16
    4b16:	15 96       	adiw	r26, 0x05	; 5
    4b18:	8d 91       	ld	r24, X+
    4b1a:	9c 91       	ld	r25, X
    4b1c:	16 97       	sbiw	r26, 0x06	; 6
    4b1e:	0e 94 9e 09 	call	0x133c	; 0x133c <xQueueReceiveFromISR>
    4b22:	81 30       	cpi	r24, 0x01	; 1
    4b24:	31 f4       	brne	.+12     	; 0x4b32 <__vector_89+0x68>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    4b26:	d8 01       	movw	r26, r16
    4b28:	ed 91       	ld	r30, X+
    4b2a:	fc 91       	ld	r31, X
    4b2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b2e:	80 83       	st	Z, r24
    4b30:	06 c0       	rjmp	.+12     	; 0x4b3e <__vector_89+0x74>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    4b32:	d8 01       	movw	r26, r16
    4b34:	ed 91       	ld	r30, X+
    4b36:	fc 91       	ld	r31, X
    4b38:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    4b3a:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    4b3c:	83 83       	std	Z+3, r24	; 0x03
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
    4b3e:	0f 90       	pop	r0
    4b40:	0f 90       	pop	r0
    4b42:	df 91       	pop	r29
    4b44:	cf 91       	pop	r28
    4b46:	ff 91       	pop	r31
    4b48:	ef 91       	pop	r30
    4b4a:	bf 91       	pop	r27
    4b4c:	af 91       	pop	r26
    4b4e:	9f 91       	pop	r25
    4b50:	8f 91       	pop	r24
    4b52:	7f 91       	pop	r23
    4b54:	6f 91       	pop	r22
    4b56:	5f 91       	pop	r21
    4b58:	4f 91       	pop	r20
    4b5a:	3f 91       	pop	r19
    4b5c:	2f 91       	pop	r18
    4b5e:	1f 91       	pop	r17
    4b60:	0f 91       	pop	r16
    4b62:	0f 90       	pop	r0
    4b64:	0b be       	out	0x3b, r0	; 59
    4b66:	0f 90       	pop	r0
    4b68:	0f be       	out	0x3f, r0	; 63
    4b6a:	0f 90       	pop	r0
    4b6c:	1f 90       	pop	r1
    4b6e:	18 95       	reti

00004b70 <__vector_59>:
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
    4b70:	1f 92       	push	r1
    4b72:	0f 92       	push	r0
    4b74:	0f b6       	in	r0, 0x3f	; 63
    4b76:	0f 92       	push	r0
    4b78:	11 24       	eor	r1, r1
    4b7a:	0b b6       	in	r0, 0x3b	; 59
    4b7c:	0f 92       	push	r0
    4b7e:	0f 93       	push	r16
    4b80:	1f 93       	push	r17
    4b82:	2f 93       	push	r18
    4b84:	3f 93       	push	r19
    4b86:	4f 93       	push	r20
    4b88:	5f 93       	push	r21
    4b8a:	6f 93       	push	r22
    4b8c:	7f 93       	push	r23
    4b8e:	8f 93       	push	r24
    4b90:	9f 93       	push	r25
    4b92:	af 93       	push	r26
    4b94:	bf 93       	push	r27
    4b96:	ef 93       	push	r30
    4b98:	ff 93       	push	r31
    4b9a:	cf 93       	push	r28
    4b9c:	df 93       	push	r29
    4b9e:	1f 92       	push	r1
    4ba0:	1f 92       	push	r1
    4ba2:	cd b7       	in	r28, 0x3d	; 61
    4ba4:	de b7       	in	r29, 0x3e	; 62
    4ba6:	00 91 84 3f 	lds	r16, 0x3F84
    4baa:	10 91 85 3f 	lds	r17, 0x3F85
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    4bae:	ae 01       	movw	r20, r28
    4bb0:	4f 5f       	subi	r20, 0xFF	; 255
    4bb2:	5f 4f       	sbci	r21, 0xFF	; 255
    4bb4:	be 01       	movw	r22, r28
    4bb6:	6e 5f       	subi	r22, 0xFE	; 254
    4bb8:	7f 4f       	sbci	r23, 0xFF	; 255
    4bba:	d8 01       	movw	r26, r16
    4bbc:	15 96       	adiw	r26, 0x05	; 5
    4bbe:	8d 91       	ld	r24, X+
    4bc0:	9c 91       	ld	r25, X
    4bc2:	16 97       	sbiw	r26, 0x06	; 6
    4bc4:	0e 94 9e 09 	call	0x133c	; 0x133c <xQueueReceiveFromISR>
    4bc8:	81 30       	cpi	r24, 0x01	; 1
    4bca:	31 f4       	brne	.+12     	; 0x4bd8 <__vector_59+0x68>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    4bcc:	d8 01       	movw	r26, r16
    4bce:	ed 91       	ld	r30, X+
    4bd0:	fc 91       	ld	r31, X
    4bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd4:	80 83       	st	Z, r24
    4bd6:	06 c0       	rjmp	.+12     	; 0x4be4 <__vector_59+0x74>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    4bd8:	d8 01       	movw	r26, r16
    4bda:	ed 91       	ld	r30, X+
    4bdc:	fc 91       	ld	r31, X
    4bde:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    4be0:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    4be2:	83 83       	std	Z+3, r24	; 0x03
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
    4be4:	0f 90       	pop	r0
    4be6:	0f 90       	pop	r0
    4be8:	df 91       	pop	r29
    4bea:	cf 91       	pop	r28
    4bec:	ff 91       	pop	r31
    4bee:	ef 91       	pop	r30
    4bf0:	bf 91       	pop	r27
    4bf2:	af 91       	pop	r26
    4bf4:	9f 91       	pop	r25
    4bf6:	8f 91       	pop	r24
    4bf8:	7f 91       	pop	r23
    4bfa:	6f 91       	pop	r22
    4bfc:	5f 91       	pop	r21
    4bfe:	4f 91       	pop	r20
    4c00:	3f 91       	pop	r19
    4c02:	2f 91       	pop	r18
    4c04:	1f 91       	pop	r17
    4c06:	0f 91       	pop	r16
    4c08:	0f 90       	pop	r0
    4c0a:	0b be       	out	0x3b, r0	; 59
    4c0c:	0f 90       	pop	r0
    4c0e:	0f be       	out	0x3f, r0	; 63
    4c10:	0f 90       	pop	r0
    4c12:	1f 90       	pop	r1
    4c14:	18 95       	reti

00004c16 <__vector_120>:
ISR(USARTF0_DRE_vect){USART_DataRegEmpty(usartBufferF);}
    4c16:	1f 92       	push	r1
    4c18:	0f 92       	push	r0
    4c1a:	0f b6       	in	r0, 0x3f	; 63
    4c1c:	0f 92       	push	r0
    4c1e:	11 24       	eor	r1, r1
    4c20:	0b b6       	in	r0, 0x3b	; 59
    4c22:	0f 92       	push	r0
    4c24:	0f 93       	push	r16
    4c26:	1f 93       	push	r17
    4c28:	2f 93       	push	r18
    4c2a:	3f 93       	push	r19
    4c2c:	4f 93       	push	r20
    4c2e:	5f 93       	push	r21
    4c30:	6f 93       	push	r22
    4c32:	7f 93       	push	r23
    4c34:	8f 93       	push	r24
    4c36:	9f 93       	push	r25
    4c38:	af 93       	push	r26
    4c3a:	bf 93       	push	r27
    4c3c:	ef 93       	push	r30
    4c3e:	ff 93       	push	r31
    4c40:	cf 93       	push	r28
    4c42:	df 93       	push	r29
    4c44:	1f 92       	push	r1
    4c46:	1f 92       	push	r1
    4c48:	cd b7       	in	r28, 0x3d	; 61
    4c4a:	de b7       	in	r29, 0x3e	; 62
    4c4c:	00 91 82 3f 	lds	r16, 0x3F82
    4c50:	10 91 83 3f 	lds	r17, 0x3F83
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    4c54:	ae 01       	movw	r20, r28
    4c56:	4f 5f       	subi	r20, 0xFF	; 255
    4c58:	5f 4f       	sbci	r21, 0xFF	; 255
    4c5a:	be 01       	movw	r22, r28
    4c5c:	6e 5f       	subi	r22, 0xFE	; 254
    4c5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4c60:	d8 01       	movw	r26, r16
    4c62:	15 96       	adiw	r26, 0x05	; 5
    4c64:	8d 91       	ld	r24, X+
    4c66:	9c 91       	ld	r25, X
    4c68:	16 97       	sbiw	r26, 0x06	; 6
    4c6a:	0e 94 9e 09 	call	0x133c	; 0x133c <xQueueReceiveFromISR>
    4c6e:	81 30       	cpi	r24, 0x01	; 1
    4c70:	31 f4       	brne	.+12     	; 0x4c7e <__vector_120+0x68>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    4c72:	d8 01       	movw	r26, r16
    4c74:	ed 91       	ld	r30, X+
    4c76:	fc 91       	ld	r31, X
    4c78:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7a:	80 83       	st	Z, r24
    4c7c:	06 c0       	rjmp	.+12     	; 0x4c8a <__vector_120+0x74>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    4c7e:	d8 01       	movw	r26, r16
    4c80:	ed 91       	ld	r30, X+
    4c82:	fc 91       	ld	r31, X
    4c84:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    4c86:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    4c88:	83 83       	std	Z+3, r24	; 0x03
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
ISR(USARTF0_DRE_vect){USART_DataRegEmpty(usartBufferF);}
    4c8a:	0f 90       	pop	r0
    4c8c:	0f 90       	pop	r0
    4c8e:	df 91       	pop	r29
    4c90:	cf 91       	pop	r28
    4c92:	ff 91       	pop	r31
    4c94:	ef 91       	pop	r30
    4c96:	bf 91       	pop	r27
    4c98:	af 91       	pop	r26
    4c9a:	9f 91       	pop	r25
    4c9c:	8f 91       	pop	r24
    4c9e:	7f 91       	pop	r23
    4ca0:	6f 91       	pop	r22
    4ca2:	5f 91       	pop	r21
    4ca4:	4f 91       	pop	r20
    4ca6:	3f 91       	pop	r19
    4ca8:	2f 91       	pop	r18
    4caa:	1f 91       	pop	r17
    4cac:	0f 91       	pop	r16
    4cae:	0f 90       	pop	r0
    4cb0:	0b be       	out	0x3b, r0	; 59
    4cb2:	0f 90       	pop	r0
    4cb4:	0f be       	out	0x3f, r0	; 63
    4cb6:	0f 90       	pop	r0
    4cb8:	1f 90       	pop	r1
    4cba:	18 95       	reti

00004cbc <boardInit>:
	
	// prepare i/o
	ioport_init();
	
	// clock init & enable system clock to all peripheral modules
	sysclk_init();
    4cbc:	c9 d0       	rcall	.+402    	; 0x4e50 <sysclk_init>
	sysclk_enable_module(SYSCLK_PORT_GEN, 0xff);
    4cbe:	6f ef       	ldi	r22, 0xFF	; 255
    4cc0:	80 e0       	ldi	r24, 0x00	; 0
    4cc2:	ed d0       	rcall	.+474    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_A, 0xff);
    4cc4:	6f ef       	ldi	r22, 0xFF	; 255
    4cc6:	81 e0       	ldi	r24, 0x01	; 1
    4cc8:	ea d0       	rcall	.+468    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_B, 0xff);
    4cca:	6f ef       	ldi	r22, 0xFF	; 255
    4ccc:	82 e0       	ldi	r24, 0x02	; 2
    4cce:	e7 d0       	rcall	.+462    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_C, 0xff);
    4cd0:	6f ef       	ldi	r22, 0xFF	; 255
    4cd2:	83 e0       	ldi	r24, 0x03	; 3
    4cd4:	e4 d0       	rcall	.+456    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_D, 0xff);
    4cd6:	6f ef       	ldi	r22, 0xFF	; 255
    4cd8:	84 e0       	ldi	r24, 0x04	; 4
    4cda:	e1 d0       	rcall	.+450    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_E, 0xff);
    4cdc:	6f ef       	ldi	r22, 0xFF	; 255
    4cde:	85 e0       	ldi	r24, 0x05	; 5
    4ce0:	de d0       	rcall	.+444    	; 0x4e9e <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_F, 0xff);
    4ce2:	6f ef       	ldi	r22, 0xFF	; 255
    4ce4:	86 e0       	ldi	r24, 0x06	; 6
    4ce6:	db d0       	rcall	.+438    	; 0x4e9e <sysclk_enable_module>
	/* -------------------------------------------------------------------- */
	/*	Timer for RTC														*/
	/* -------------------------------------------------------------------- */
	
	// select the clock source and pre-scaler by 8
	TC1_ConfigClockSource(&TCC1, TC_CLKSEL_DIV64_gc);
    4ce8:	65 e0       	ldi	r22, 0x05	; 5
    4cea:	80 e4       	ldi	r24, 0x40	; 64
    4cec:	98 e0       	ldi	r25, 0x08	; 8
    4cee:	2f db       	rcall	.-2466   	; 0x434e <TC1_ConfigClockSource>
	
	TC1_SetOverflowIntLevel(&TCC1, TC_OVFINTLVL_LO_gc);
    4cf0:	61 e0       	ldi	r22, 0x01	; 1
    4cf2:	80 e4       	ldi	r24, 0x40	; 64
    4cf4:	98 e0       	ldi	r25, 0x08	; 8
    4cf6:	37 db       	rcall	.-2450   	; 0x4366 <TC1_SetOverflowIntLevel>
	
	TC_SetPeriod(&TCC1, 499);
    4cf8:	83 ef       	ldi	r24, 0xF3	; 243
    4cfa:	91 e0       	ldi	r25, 0x01	; 1
    4cfc:	e0 e4       	ldi	r30, 0x40	; 64
    4cfe:	f8 e0       	ldi	r31, 0x08	; 8
    4d00:	86 a3       	std	Z+38, r24	; 0x26
    4d02:	97 a3       	std	Z+39, r25	; 0x27
	
	milisecondsTimer = 0;
    4d04:	10 92 8e 3f 	sts	0x3F8E, r1
    4d08:	10 92 8f 3f 	sts	0x3F8F, r1
    4d0c:	10 92 90 3f 	sts	0x3F90, r1
    4d10:	10 92 91 3f 	sts	0x3F91, r1
	secondsTimer = 0;
    4d14:	10 92 92 3f 	sts	0x3F92, r1
    4d18:	10 92 93 3f 	sts	0x3F93, r1
    4d1c:	10 92 94 3f 	sts	0x3F94, r1
    4d20:	10 92 95 3f 	sts	0x3F95, r1
	hoursTimer = 0;
    4d24:	10 92 8a 3f 	sts	0x3F8A, r1
    4d28:	10 92 8b 3f 	sts	0x3F8B, r1
    4d2c:	10 92 8c 3f 	sts	0x3F8C, r1
    4d30:	10 92 8d 3f 	sts	0x3F8D, r1
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    4d34:	e0 e0       	ldi	r30, 0x00	; 0
    4d36:	f6 e0       	ldi	r31, 0x06	; 6
    4d38:	92 e0       	ldi	r25, 0x02	; 2
    4d3a:	91 83       	std	Z+1, r25	; 0x01
    4d3c:	80 e1       	ldi	r24, 0x10	; 16
    4d3e:	81 83       	std	Z+1, r24	; 0x01
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    4d40:	96 83       	std	Z+6, r25	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    4d42:	85 83       	std	Z+5, r24	; 0x05
	led_red_off();
	
	/* -------------------------------------------------------------------- */
	/*	Setup ADC Convertor													*/
	/* -------------------------------------------------------------------- */
	ADCA.CTRLA=ADC_ENABLE_bm;
    4d44:	e0 e0       	ldi	r30, 0x00	; 0
    4d46:	f2 e0       	ldi	r31, 0x02	; 2
    4d48:	81 e0       	ldi	r24, 0x01	; 1
    4d4a:	80 83       	st	Z, r24
	ADCA.CTRLB=ADC_RESOLUTION_12BIT_gc;
    4d4c:	11 82       	std	Z+1, r1	; 0x01
	ADCA.REFCTRL=ADC_REFSEL_INT1V_gc;
    4d4e:	12 82       	std	Z+2, r1	; 0x02
	ADCA.PRESCALER=ADC_PRESCALER_DIV4_gc;
    4d50:	14 82       	std	Z+4, r1	; 0x04
	
	ADCA.CH0.CTRL=ADC_CH_INPUTMODE_SINGLEENDED_gc;
    4d52:	80 a3       	std	Z+32, r24	; 0x20
	ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN9_gc;
    4d54:	88 e4       	ldi	r24, 0x48	; 72
    4d56:	81 a3       	std	Z+33, r24	; 0x21
	/* -------------------------------------------------------------------- */
	/*	Setup ADG switch													*/
	/* -------------------------------------------------------------------- */
	PORTF.DIR = 0x1F;
    4d58:	e0 ea       	ldi	r30, 0xA0	; 160
    4d5a:	f6 e0       	ldi	r31, 0x06	; 6
    4d5c:	8f e1       	ldi	r24, 0x1F	; 31
    4d5e:	80 83       	st	Z, r24
	PORTF.OUT = 0x19;
    4d60:	89 e1       	ldi	r24, 0x19	; 25
    4d62:	84 83       	std	Z+4, r24	; 0x04
    4d64:	08 95       	ret

00004d66 <__vector_20>:
}

/* -------------------------------------------------------------------- */
/*	Interrupt for timing the RTC										*/
/* -------------------------------------------------------------------- */
ISR(TCC1_OVF_vect) {
    4d66:	1f 92       	push	r1
    4d68:	0f 92       	push	r0
    4d6a:	0f b6       	in	r0, 0x3f	; 63
    4d6c:	0f 92       	push	r0
    4d6e:	11 24       	eor	r1, r1
    4d70:	2f 93       	push	r18
    4d72:	4f 93       	push	r20
    4d74:	5f 93       	push	r21
    4d76:	6f 93       	push	r22
    4d78:	7f 93       	push	r23
    4d7a:	8f 93       	push	r24
    4d7c:	9f 93       	push	r25
    4d7e:	af 93       	push	r26
    4d80:	bf 93       	push	r27
	
	// shut down the output PPM pulse

	if (milisecondsTimer++ == 1000) {
    4d82:	80 91 8e 3f 	lds	r24, 0x3F8E
    4d86:	90 91 8f 3f 	lds	r25, 0x3F8F
    4d8a:	a0 91 90 3f 	lds	r26, 0x3F90
    4d8e:	b0 91 91 3f 	lds	r27, 0x3F91
    4d92:	ac 01       	movw	r20, r24
    4d94:	bd 01       	movw	r22, r26
    4d96:	4f 5f       	subi	r20, 0xFF	; 255
    4d98:	5f 4f       	sbci	r21, 0xFF	; 255
    4d9a:	6f 4f       	sbci	r22, 0xFF	; 255
    4d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    4d9e:	40 93 8e 3f 	sts	0x3F8E, r20
    4da2:	50 93 8f 3f 	sts	0x3F8F, r21
    4da6:	60 93 90 3f 	sts	0x3F90, r22
    4daa:	70 93 91 3f 	sts	0x3F91, r23
    4dae:	88 3e       	cpi	r24, 0xE8	; 232
    4db0:	93 40       	sbci	r25, 0x03	; 3
    4db2:	a1 05       	cpc	r26, r1
    4db4:	b1 05       	cpc	r27, r1
    4db6:	f1 f5       	brne	.+124    	; 0x4e34 <__vector_20+0xce>
		
		milisecondsTimer = 0;
    4db8:	10 92 8e 3f 	sts	0x3F8E, r1
    4dbc:	10 92 8f 3f 	sts	0x3F8F, r1
    4dc0:	10 92 90 3f 	sts	0x3F90, r1
    4dc4:	10 92 91 3f 	sts	0x3F91, r1
		
		if (secondsTimer++ == 3600) {
    4dc8:	80 91 92 3f 	lds	r24, 0x3F92
    4dcc:	90 91 93 3f 	lds	r25, 0x3F93
    4dd0:	a0 91 94 3f 	lds	r26, 0x3F94
    4dd4:	b0 91 95 3f 	lds	r27, 0x3F95
    4dd8:	ac 01       	movw	r20, r24
    4dda:	bd 01       	movw	r22, r26
    4ddc:	4f 5f       	subi	r20, 0xFF	; 255
    4dde:	5f 4f       	sbci	r21, 0xFF	; 255
    4de0:	6f 4f       	sbci	r22, 0xFF	; 255
    4de2:	7f 4f       	sbci	r23, 0xFF	; 255
    4de4:	40 93 92 3f 	sts	0x3F92, r20
    4de8:	50 93 93 3f 	sts	0x3F93, r21
    4dec:	60 93 94 3f 	sts	0x3F94, r22
    4df0:	70 93 95 3f 	sts	0x3F95, r23
    4df4:	80 31       	cpi	r24, 0x10	; 16
    4df6:	9e 40       	sbci	r25, 0x0E	; 14
    4df8:	a1 05       	cpc	r26, r1
    4dfa:	b1 05       	cpc	r27, r1
    4dfc:	d9 f4       	brne	.+54     	; 0x4e34 <__vector_20+0xce>
			
			secondsTimer = 0;
    4dfe:	10 92 92 3f 	sts	0x3F92, r1
    4e02:	10 92 93 3f 	sts	0x3F93, r1
    4e06:	10 92 94 3f 	sts	0x3F94, r1
    4e0a:	10 92 95 3f 	sts	0x3F95, r1
			hoursTimer++;
    4e0e:	80 91 8a 3f 	lds	r24, 0x3F8A
    4e12:	90 91 8b 3f 	lds	r25, 0x3F8B
    4e16:	a0 91 8c 3f 	lds	r26, 0x3F8C
    4e1a:	b0 91 8d 3f 	lds	r27, 0x3F8D
    4e1e:	01 96       	adiw	r24, 0x01	; 1
    4e20:	a1 1d       	adc	r26, r1
    4e22:	b1 1d       	adc	r27, r1
    4e24:	80 93 8a 3f 	sts	0x3F8A, r24
    4e28:	90 93 8b 3f 	sts	0x3F8B, r25
    4e2c:	a0 93 8c 3f 	sts	0x3F8C, r26
    4e30:	b0 93 8d 3f 	sts	0x3F8D, r27
		}
	}
    4e34:	bf 91       	pop	r27
    4e36:	af 91       	pop	r26
    4e38:	9f 91       	pop	r25
    4e3a:	8f 91       	pop	r24
    4e3c:	7f 91       	pop	r23
    4e3e:	6f 91       	pop	r22
    4e40:	5f 91       	pop	r21
    4e42:	4f 91       	pop	r20
    4e44:	2f 91       	pop	r18
    4e46:	0f 90       	pop	r0
    4e48:	0f be       	out	0x3f, r0	; 63
    4e4a:	0f 90       	pop	r0
    4e4c:	1f 90       	pop	r1
    4e4e:	18 95       	reti

00004e50 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    4e50:	8f ef       	ldi	r24, 0xFF	; 255
    4e52:	80 93 70 00 	sts	0x0070, r24
    4e56:	80 93 71 00 	sts	0x0071, r24
    4e5a:	80 93 72 00 	sts	0x0072, r24
    4e5e:	80 93 73 00 	sts	0x0073, r24
    4e62:	80 93 74 00 	sts	0x0074, r24
    4e66:	80 93 75 00 	sts	0x0075, r24
    4e6a:	80 93 76 00 	sts	0x0076, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e6e:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    4e70:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
    4e72:	e0 e5       	ldi	r30, 0x50	; 80
    4e74:	f0 e0       	ldi	r31, 0x00	; 0
    4e76:	90 81       	ld	r25, Z
    4e78:	92 60       	ori	r25, 0x02	; 2
    4e7a:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4e7c:	8f bf       	out	0x3f, r24	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
    4e7e:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
    4e80:	81 ff       	sbrs	r24, 1
    4e82:	fd cf       	rjmp	.-6      	; 0x4e7e <sysclk_init+0x2e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
    4e84:	61 e0       	ldi	r22, 0x01	; 1
    4e86:	80 e4       	ldi	r24, 0x40	; 64
    4e88:	90 e0       	ldi	r25, 0x00	; 0
    4e8a:	15 d0       	rcall	.+42     	; 0x4eb6 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e8c:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    4e8e:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
    4e90:	e0 e5       	ldi	r30, 0x50	; 80
    4e92:	f0 e0       	ldi	r31, 0x00	; 0
    4e94:	90 81       	ld	r25, Z
    4e96:	9e 7f       	andi	r25, 0xFE	; 254
    4e98:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4e9a:	8f bf       	out	0x3f, r24	; 63
    4e9c:	08 95       	ret

00004e9e <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    4e9e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    4ea0:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    4ea2:	e8 2f       	mov	r30, r24
    4ea4:	f0 e0       	ldi	r31, 0x00	; 0
    4ea6:	e0 59       	subi	r30, 0x90	; 144
    4ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    4eaa:	60 95       	com	r22
    4eac:	80 81       	ld	r24, Z
    4eae:	68 23       	and	r22, r24
    4eb0:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    4eb2:	9f bf       	out	0x3f, r25	; 63
    4eb4:	08 95       	ret

00004eb6 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    4eb6:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    4eb8:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    4eba:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    4ebc:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    4ebe:	60 83       	st	Z, r22
	ret                             // Return to caller
    4ec0:	08 95       	ret

00004ec2 <__floatunsisf>:
    4ec2:	e8 94       	clt
    4ec4:	09 c0       	rjmp	.+18     	; 0x4ed8 <__floatsisf+0x12>

00004ec6 <__floatsisf>:
    4ec6:	97 fb       	bst	r25, 7
    4ec8:	3e f4       	brtc	.+14     	; 0x4ed8 <__floatsisf+0x12>
    4eca:	90 95       	com	r25
    4ecc:	80 95       	com	r24
    4ece:	70 95       	com	r23
    4ed0:	61 95       	neg	r22
    4ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ed4:	8f 4f       	sbci	r24, 0xFF	; 255
    4ed6:	9f 4f       	sbci	r25, 0xFF	; 255
    4ed8:	99 23       	and	r25, r25
    4eda:	a9 f0       	breq	.+42     	; 0x4f06 <__floatsisf+0x40>
    4edc:	f9 2f       	mov	r31, r25
    4ede:	96 e9       	ldi	r25, 0x96	; 150
    4ee0:	bb 27       	eor	r27, r27
    4ee2:	93 95       	inc	r25
    4ee4:	f6 95       	lsr	r31
    4ee6:	87 95       	ror	r24
    4ee8:	77 95       	ror	r23
    4eea:	67 95       	ror	r22
    4eec:	b7 95       	ror	r27
    4eee:	f1 11       	cpse	r31, r1
    4ef0:	f8 cf       	rjmp	.-16     	; 0x4ee2 <__floatsisf+0x1c>
    4ef2:	fa f4       	brpl	.+62     	; 0x4f32 <__floatsisf+0x6c>
    4ef4:	bb 0f       	add	r27, r27
    4ef6:	11 f4       	brne	.+4      	; 0x4efc <__floatsisf+0x36>
    4ef8:	60 ff       	sbrs	r22, 0
    4efa:	1b c0       	rjmp	.+54     	; 0x4f32 <__floatsisf+0x6c>
    4efc:	6f 5f       	subi	r22, 0xFF	; 255
    4efe:	7f 4f       	sbci	r23, 0xFF	; 255
    4f00:	8f 4f       	sbci	r24, 0xFF	; 255
    4f02:	9f 4f       	sbci	r25, 0xFF	; 255
    4f04:	16 c0       	rjmp	.+44     	; 0x4f32 <__floatsisf+0x6c>
    4f06:	88 23       	and	r24, r24
    4f08:	11 f0       	breq	.+4      	; 0x4f0e <__floatsisf+0x48>
    4f0a:	96 e9       	ldi	r25, 0x96	; 150
    4f0c:	11 c0       	rjmp	.+34     	; 0x4f30 <__floatsisf+0x6a>
    4f0e:	77 23       	and	r23, r23
    4f10:	21 f0       	breq	.+8      	; 0x4f1a <__floatsisf+0x54>
    4f12:	9e e8       	ldi	r25, 0x8E	; 142
    4f14:	87 2f       	mov	r24, r23
    4f16:	76 2f       	mov	r23, r22
    4f18:	05 c0       	rjmp	.+10     	; 0x4f24 <__floatsisf+0x5e>
    4f1a:	66 23       	and	r22, r22
    4f1c:	71 f0       	breq	.+28     	; 0x4f3a <__floatsisf+0x74>
    4f1e:	96 e8       	ldi	r25, 0x86	; 134
    4f20:	86 2f       	mov	r24, r22
    4f22:	70 e0       	ldi	r23, 0x00	; 0
    4f24:	60 e0       	ldi	r22, 0x00	; 0
    4f26:	2a f0       	brmi	.+10     	; 0x4f32 <__floatsisf+0x6c>
    4f28:	9a 95       	dec	r25
    4f2a:	66 0f       	add	r22, r22
    4f2c:	77 1f       	adc	r23, r23
    4f2e:	88 1f       	adc	r24, r24
    4f30:	da f7       	brpl	.-10     	; 0x4f28 <__floatsisf+0x62>
    4f32:	88 0f       	add	r24, r24
    4f34:	96 95       	lsr	r25
    4f36:	87 95       	ror	r24
    4f38:	97 f9       	bld	r25, 7
    4f3a:	08 95       	ret

00004f3c <__mulsf3>:
    4f3c:	0b d0       	rcall	.+22     	; 0x4f54 <__mulsf3x>
    4f3e:	78 c0       	rjmp	.+240    	; 0x5030 <__fp_round>
    4f40:	69 d0       	rcall	.+210    	; 0x5014 <__fp_pscA>
    4f42:	28 f0       	brcs	.+10     	; 0x4f4e <__mulsf3+0x12>
    4f44:	6e d0       	rcall	.+220    	; 0x5022 <__fp_pscB>
    4f46:	18 f0       	brcs	.+6      	; 0x4f4e <__mulsf3+0x12>
    4f48:	95 23       	and	r25, r21
    4f4a:	09 f0       	breq	.+2      	; 0x4f4e <__mulsf3+0x12>
    4f4c:	5a c0       	rjmp	.+180    	; 0x5002 <__fp_inf>
    4f4e:	5f c0       	rjmp	.+190    	; 0x500e <__fp_nan>
    4f50:	11 24       	eor	r1, r1
    4f52:	a2 c0       	rjmp	.+324    	; 0x5098 <__fp_szero>

00004f54 <__mulsf3x>:
    4f54:	7e d0       	rcall	.+252    	; 0x5052 <__fp_split3>
    4f56:	a0 f3       	brcs	.-24     	; 0x4f40 <__mulsf3+0x4>

00004f58 <__mulsf3_pse>:
    4f58:	95 9f       	mul	r25, r21
    4f5a:	d1 f3       	breq	.-12     	; 0x4f50 <__mulsf3+0x14>
    4f5c:	95 0f       	add	r25, r21
    4f5e:	50 e0       	ldi	r21, 0x00	; 0
    4f60:	55 1f       	adc	r21, r21
    4f62:	62 9f       	mul	r22, r18
    4f64:	f0 01       	movw	r30, r0
    4f66:	72 9f       	mul	r23, r18
    4f68:	bb 27       	eor	r27, r27
    4f6a:	f0 0d       	add	r31, r0
    4f6c:	b1 1d       	adc	r27, r1
    4f6e:	63 9f       	mul	r22, r19
    4f70:	aa 27       	eor	r26, r26
    4f72:	f0 0d       	add	r31, r0
    4f74:	b1 1d       	adc	r27, r1
    4f76:	aa 1f       	adc	r26, r26
    4f78:	64 9f       	mul	r22, r20
    4f7a:	66 27       	eor	r22, r22
    4f7c:	b0 0d       	add	r27, r0
    4f7e:	a1 1d       	adc	r26, r1
    4f80:	66 1f       	adc	r22, r22
    4f82:	82 9f       	mul	r24, r18
    4f84:	22 27       	eor	r18, r18
    4f86:	b0 0d       	add	r27, r0
    4f88:	a1 1d       	adc	r26, r1
    4f8a:	62 1f       	adc	r22, r18
    4f8c:	73 9f       	mul	r23, r19
    4f8e:	b0 0d       	add	r27, r0
    4f90:	a1 1d       	adc	r26, r1
    4f92:	62 1f       	adc	r22, r18
    4f94:	83 9f       	mul	r24, r19
    4f96:	a0 0d       	add	r26, r0
    4f98:	61 1d       	adc	r22, r1
    4f9a:	22 1f       	adc	r18, r18
    4f9c:	74 9f       	mul	r23, r20
    4f9e:	33 27       	eor	r19, r19
    4fa0:	a0 0d       	add	r26, r0
    4fa2:	61 1d       	adc	r22, r1
    4fa4:	23 1f       	adc	r18, r19
    4fa6:	84 9f       	mul	r24, r20
    4fa8:	60 0d       	add	r22, r0
    4faa:	21 1d       	adc	r18, r1
    4fac:	82 2f       	mov	r24, r18
    4fae:	76 2f       	mov	r23, r22
    4fb0:	6a 2f       	mov	r22, r26
    4fb2:	11 24       	eor	r1, r1
    4fb4:	9f 57       	subi	r25, 0x7F	; 127
    4fb6:	50 40       	sbci	r21, 0x00	; 0
    4fb8:	8a f0       	brmi	.+34     	; 0x4fdc <__mulsf3_pse+0x84>
    4fba:	e1 f0       	breq	.+56     	; 0x4ff4 <__mulsf3_pse+0x9c>
    4fbc:	88 23       	and	r24, r24
    4fbe:	4a f0       	brmi	.+18     	; 0x4fd2 <__mulsf3_pse+0x7a>
    4fc0:	ee 0f       	add	r30, r30
    4fc2:	ff 1f       	adc	r31, r31
    4fc4:	bb 1f       	adc	r27, r27
    4fc6:	66 1f       	adc	r22, r22
    4fc8:	77 1f       	adc	r23, r23
    4fca:	88 1f       	adc	r24, r24
    4fcc:	91 50       	subi	r25, 0x01	; 1
    4fce:	50 40       	sbci	r21, 0x00	; 0
    4fd0:	a9 f7       	brne	.-22     	; 0x4fbc <__mulsf3_pse+0x64>
    4fd2:	9e 3f       	cpi	r25, 0xFE	; 254
    4fd4:	51 05       	cpc	r21, r1
    4fd6:	70 f0       	brcs	.+28     	; 0x4ff4 <__mulsf3_pse+0x9c>
    4fd8:	14 c0       	rjmp	.+40     	; 0x5002 <__fp_inf>
    4fda:	5e c0       	rjmp	.+188    	; 0x5098 <__fp_szero>
    4fdc:	5f 3f       	cpi	r21, 0xFF	; 255
    4fde:	ec f3       	brlt	.-6      	; 0x4fda <__mulsf3_pse+0x82>
    4fe0:	98 3e       	cpi	r25, 0xE8	; 232
    4fe2:	dc f3       	brlt	.-10     	; 0x4fda <__mulsf3_pse+0x82>
    4fe4:	86 95       	lsr	r24
    4fe6:	77 95       	ror	r23
    4fe8:	67 95       	ror	r22
    4fea:	b7 95       	ror	r27
    4fec:	f7 95       	ror	r31
    4fee:	e7 95       	ror	r30
    4ff0:	9f 5f       	subi	r25, 0xFF	; 255
    4ff2:	c1 f7       	brne	.-16     	; 0x4fe4 <__mulsf3_pse+0x8c>
    4ff4:	fe 2b       	or	r31, r30
    4ff6:	88 0f       	add	r24, r24
    4ff8:	91 1d       	adc	r25, r1
    4ffa:	96 95       	lsr	r25
    4ffc:	87 95       	ror	r24
    4ffe:	97 f9       	bld	r25, 7
    5000:	08 95       	ret

00005002 <__fp_inf>:
    5002:	97 f9       	bld	r25, 7
    5004:	9f 67       	ori	r25, 0x7F	; 127
    5006:	80 e8       	ldi	r24, 0x80	; 128
    5008:	70 e0       	ldi	r23, 0x00	; 0
    500a:	60 e0       	ldi	r22, 0x00	; 0
    500c:	08 95       	ret

0000500e <__fp_nan>:
    500e:	9f ef       	ldi	r25, 0xFF	; 255
    5010:	80 ec       	ldi	r24, 0xC0	; 192
    5012:	08 95       	ret

00005014 <__fp_pscA>:
    5014:	00 24       	eor	r0, r0
    5016:	0a 94       	dec	r0
    5018:	16 16       	cp	r1, r22
    501a:	17 06       	cpc	r1, r23
    501c:	18 06       	cpc	r1, r24
    501e:	09 06       	cpc	r0, r25
    5020:	08 95       	ret

00005022 <__fp_pscB>:
    5022:	00 24       	eor	r0, r0
    5024:	0a 94       	dec	r0
    5026:	12 16       	cp	r1, r18
    5028:	13 06       	cpc	r1, r19
    502a:	14 06       	cpc	r1, r20
    502c:	05 06       	cpc	r0, r21
    502e:	08 95       	ret

00005030 <__fp_round>:
    5030:	09 2e       	mov	r0, r25
    5032:	03 94       	inc	r0
    5034:	00 0c       	add	r0, r0
    5036:	11 f4       	brne	.+4      	; 0x503c <__fp_round+0xc>
    5038:	88 23       	and	r24, r24
    503a:	52 f0       	brmi	.+20     	; 0x5050 <__fp_round+0x20>
    503c:	bb 0f       	add	r27, r27
    503e:	40 f4       	brcc	.+16     	; 0x5050 <__fp_round+0x20>
    5040:	bf 2b       	or	r27, r31
    5042:	11 f4       	brne	.+4      	; 0x5048 <__fp_round+0x18>
    5044:	60 ff       	sbrs	r22, 0
    5046:	04 c0       	rjmp	.+8      	; 0x5050 <__fp_round+0x20>
    5048:	6f 5f       	subi	r22, 0xFF	; 255
    504a:	7f 4f       	sbci	r23, 0xFF	; 255
    504c:	8f 4f       	sbci	r24, 0xFF	; 255
    504e:	9f 4f       	sbci	r25, 0xFF	; 255
    5050:	08 95       	ret

00005052 <__fp_split3>:
    5052:	57 fd       	sbrc	r21, 7
    5054:	90 58       	subi	r25, 0x80	; 128
    5056:	44 0f       	add	r20, r20
    5058:	55 1f       	adc	r21, r21
    505a:	59 f0       	breq	.+22     	; 0x5072 <__fp_splitA+0x10>
    505c:	5f 3f       	cpi	r21, 0xFF	; 255
    505e:	71 f0       	breq	.+28     	; 0x507c <__fp_splitA+0x1a>
    5060:	47 95       	ror	r20

00005062 <__fp_splitA>:
    5062:	88 0f       	add	r24, r24
    5064:	97 fb       	bst	r25, 7
    5066:	99 1f       	adc	r25, r25
    5068:	61 f0       	breq	.+24     	; 0x5082 <__fp_splitA+0x20>
    506a:	9f 3f       	cpi	r25, 0xFF	; 255
    506c:	79 f0       	breq	.+30     	; 0x508c <__fp_splitA+0x2a>
    506e:	87 95       	ror	r24
    5070:	08 95       	ret
    5072:	12 16       	cp	r1, r18
    5074:	13 06       	cpc	r1, r19
    5076:	14 06       	cpc	r1, r20
    5078:	55 1f       	adc	r21, r21
    507a:	f2 cf       	rjmp	.-28     	; 0x5060 <__fp_split3+0xe>
    507c:	46 95       	lsr	r20
    507e:	f1 df       	rcall	.-30     	; 0x5062 <__fp_splitA>
    5080:	08 c0       	rjmp	.+16     	; 0x5092 <__fp_splitA+0x30>
    5082:	16 16       	cp	r1, r22
    5084:	17 06       	cpc	r1, r23
    5086:	18 06       	cpc	r1, r24
    5088:	99 1f       	adc	r25, r25
    508a:	f1 cf       	rjmp	.-30     	; 0x506e <__fp_splitA+0xc>
    508c:	86 95       	lsr	r24
    508e:	71 05       	cpc	r23, r1
    5090:	61 05       	cpc	r22, r1
    5092:	08 94       	sec
    5094:	08 95       	ret

00005096 <__fp_zero>:
    5096:	e8 94       	clt

00005098 <__fp_szero>:
    5098:	bb 27       	eor	r27, r27
    509a:	66 27       	eor	r22, r22
    509c:	77 27       	eor	r23, r23
    509e:	cb 01       	movw	r24, r22
    50a0:	97 f9       	bld	r25, 7
    50a2:	08 95       	ret

000050a4 <vfprintf>:
    50a4:	2f 92       	push	r2
    50a6:	3f 92       	push	r3
    50a8:	4f 92       	push	r4
    50aa:	5f 92       	push	r5
    50ac:	6f 92       	push	r6
    50ae:	7f 92       	push	r7
    50b0:	8f 92       	push	r8
    50b2:	9f 92       	push	r9
    50b4:	af 92       	push	r10
    50b6:	bf 92       	push	r11
    50b8:	cf 92       	push	r12
    50ba:	df 92       	push	r13
    50bc:	ef 92       	push	r14
    50be:	ff 92       	push	r15
    50c0:	0f 93       	push	r16
    50c2:	1f 93       	push	r17
    50c4:	cf 93       	push	r28
    50c6:	df 93       	push	r29
    50c8:	cd b7       	in	r28, 0x3d	; 61
    50ca:	de b7       	in	r29, 0x3e	; 62
    50cc:	63 97       	sbiw	r28, 0x13	; 19
    50ce:	cd bf       	out	0x3d, r28	; 61
    50d0:	de bf       	out	0x3e, r29	; 62
    50d2:	7c 01       	movw	r14, r24
    50d4:	1b 01       	movw	r2, r22
    50d6:	6a 01       	movw	r12, r20
    50d8:	fc 01       	movw	r30, r24
    50da:	16 82       	std	Z+6, r1	; 0x06
    50dc:	17 82       	std	Z+7, r1	; 0x07
    50de:	83 81       	ldd	r24, Z+3	; 0x03
    50e0:	81 ff       	sbrs	r24, 1
    50e2:	49 c3       	rjmp	.+1682   	; 0x5776 <vfprintf+0x6d2>
    50e4:	be 01       	movw	r22, r28
    50e6:	6f 5f       	subi	r22, 0xFF	; 255
    50e8:	7f 4f       	sbci	r23, 0xFF	; 255
    50ea:	4b 01       	movw	r8, r22
    50ec:	f7 01       	movw	r30, r14
    50ee:	93 81       	ldd	r25, Z+3	; 0x03
    50f0:	f1 01       	movw	r30, r2
    50f2:	93 fd       	sbrc	r25, 3
    50f4:	85 91       	lpm	r24, Z+
    50f6:	93 ff       	sbrs	r25, 3
    50f8:	81 91       	ld	r24, Z+
    50fa:	1f 01       	movw	r2, r30
    50fc:	88 23       	and	r24, r24
    50fe:	09 f4       	brne	.+2      	; 0x5102 <vfprintf+0x5e>
    5100:	36 c3       	rjmp	.+1644   	; 0x576e <vfprintf+0x6ca>
    5102:	85 32       	cpi	r24, 0x25	; 37
    5104:	39 f4       	brne	.+14     	; 0x5114 <vfprintf+0x70>
    5106:	93 fd       	sbrc	r25, 3
    5108:	85 91       	lpm	r24, Z+
    510a:	93 ff       	sbrs	r25, 3
    510c:	81 91       	ld	r24, Z+
    510e:	1f 01       	movw	r2, r30
    5110:	85 32       	cpi	r24, 0x25	; 37
    5112:	31 f4       	brne	.+12     	; 0x5120 <vfprintf+0x7c>
    5114:	b7 01       	movw	r22, r14
    5116:	90 e0       	ldi	r25, 0x00	; 0
    5118:	36 d5       	rcall	.+2668   	; 0x5b86 <fputc>
    511a:	56 01       	movw	r10, r12
    511c:	65 01       	movw	r12, r10
    511e:	e6 cf       	rjmp	.-52     	; 0x50ec <vfprintf+0x48>
    5120:	10 e0       	ldi	r17, 0x00	; 0
    5122:	51 2c       	mov	r5, r1
    5124:	20 e0       	ldi	r18, 0x00	; 0
    5126:	20 32       	cpi	r18, 0x20	; 32
    5128:	a0 f4       	brcc	.+40     	; 0x5152 <vfprintf+0xae>
    512a:	8b 32       	cpi	r24, 0x2B	; 43
    512c:	69 f0       	breq	.+26     	; 0x5148 <vfprintf+0xa4>
    512e:	30 f4       	brcc	.+12     	; 0x513c <vfprintf+0x98>
    5130:	80 32       	cpi	r24, 0x20	; 32
    5132:	59 f0       	breq	.+22     	; 0x514a <vfprintf+0xa6>
    5134:	83 32       	cpi	r24, 0x23	; 35
    5136:	69 f4       	brne	.+26     	; 0x5152 <vfprintf+0xae>
    5138:	20 61       	ori	r18, 0x10	; 16
    513a:	2c c0       	rjmp	.+88     	; 0x5194 <vfprintf+0xf0>
    513c:	8d 32       	cpi	r24, 0x2D	; 45
    513e:	39 f0       	breq	.+14     	; 0x514e <vfprintf+0xaa>
    5140:	80 33       	cpi	r24, 0x30	; 48
    5142:	39 f4       	brne	.+14     	; 0x5152 <vfprintf+0xae>
    5144:	21 60       	ori	r18, 0x01	; 1
    5146:	26 c0       	rjmp	.+76     	; 0x5194 <vfprintf+0xf0>
    5148:	22 60       	ori	r18, 0x02	; 2
    514a:	24 60       	ori	r18, 0x04	; 4
    514c:	23 c0       	rjmp	.+70     	; 0x5194 <vfprintf+0xf0>
    514e:	28 60       	ori	r18, 0x08	; 8
    5150:	21 c0       	rjmp	.+66     	; 0x5194 <vfprintf+0xf0>
    5152:	27 fd       	sbrc	r18, 7
    5154:	27 c0       	rjmp	.+78     	; 0x51a4 <vfprintf+0x100>
    5156:	30 ed       	ldi	r19, 0xD0	; 208
    5158:	38 0f       	add	r19, r24
    515a:	3a 30       	cpi	r19, 0x0A	; 10
    515c:	78 f4       	brcc	.+30     	; 0x517c <vfprintf+0xd8>
    515e:	26 ff       	sbrs	r18, 6
    5160:	06 c0       	rjmp	.+12     	; 0x516e <vfprintf+0xca>
    5162:	fa e0       	ldi	r31, 0x0A	; 10
    5164:	1f 9f       	mul	r17, r31
    5166:	30 0d       	add	r19, r0
    5168:	11 24       	eor	r1, r1
    516a:	13 2f       	mov	r17, r19
    516c:	13 c0       	rjmp	.+38     	; 0x5194 <vfprintf+0xf0>
    516e:	6a e0       	ldi	r22, 0x0A	; 10
    5170:	56 9e       	mul	r5, r22
    5172:	30 0d       	add	r19, r0
    5174:	11 24       	eor	r1, r1
    5176:	53 2e       	mov	r5, r19
    5178:	20 62       	ori	r18, 0x20	; 32
    517a:	0c c0       	rjmp	.+24     	; 0x5194 <vfprintf+0xf0>
    517c:	8e 32       	cpi	r24, 0x2E	; 46
    517e:	21 f4       	brne	.+8      	; 0x5188 <vfprintf+0xe4>
    5180:	26 fd       	sbrc	r18, 6
    5182:	f5 c2       	rjmp	.+1514   	; 0x576e <vfprintf+0x6ca>
    5184:	20 64       	ori	r18, 0x40	; 64
    5186:	06 c0       	rjmp	.+12     	; 0x5194 <vfprintf+0xf0>
    5188:	8c 36       	cpi	r24, 0x6C	; 108
    518a:	11 f4       	brne	.+4      	; 0x5190 <vfprintf+0xec>
    518c:	20 68       	ori	r18, 0x80	; 128
    518e:	02 c0       	rjmp	.+4      	; 0x5194 <vfprintf+0xf0>
    5190:	88 36       	cpi	r24, 0x68	; 104
    5192:	41 f4       	brne	.+16     	; 0x51a4 <vfprintf+0x100>
    5194:	f1 01       	movw	r30, r2
    5196:	93 fd       	sbrc	r25, 3
    5198:	85 91       	lpm	r24, Z+
    519a:	93 ff       	sbrs	r25, 3
    519c:	81 91       	ld	r24, Z+
    519e:	1f 01       	movw	r2, r30
    51a0:	81 11       	cpse	r24, r1
    51a2:	c1 cf       	rjmp	.-126    	; 0x5126 <vfprintf+0x82>
    51a4:	9b eb       	ldi	r25, 0xBB	; 187
    51a6:	98 0f       	add	r25, r24
    51a8:	93 30       	cpi	r25, 0x03	; 3
    51aa:	18 f4       	brcc	.+6      	; 0x51b2 <vfprintf+0x10e>
    51ac:	20 61       	ori	r18, 0x10	; 16
    51ae:	80 5e       	subi	r24, 0xE0	; 224
    51b0:	06 c0       	rjmp	.+12     	; 0x51be <vfprintf+0x11a>
    51b2:	9b e9       	ldi	r25, 0x9B	; 155
    51b4:	98 0f       	add	r25, r24
    51b6:	93 30       	cpi	r25, 0x03	; 3
    51b8:	08 f0       	brcs	.+2      	; 0x51bc <vfprintf+0x118>
    51ba:	9a c1       	rjmp	.+820    	; 0x54f0 <vfprintf+0x44c>
    51bc:	2f 7e       	andi	r18, 0xEF	; 239
    51be:	26 ff       	sbrs	r18, 6
    51c0:	16 e0       	ldi	r17, 0x06	; 6
    51c2:	2f 73       	andi	r18, 0x3F	; 63
    51c4:	72 2e       	mov	r7, r18
    51c6:	85 36       	cpi	r24, 0x65	; 101
    51c8:	21 f4       	brne	.+8      	; 0x51d2 <vfprintf+0x12e>
    51ca:	f2 2f       	mov	r31, r18
    51cc:	f0 64       	ori	r31, 0x40	; 64
    51ce:	7f 2e       	mov	r7, r31
    51d0:	08 c0       	rjmp	.+16     	; 0x51e2 <vfprintf+0x13e>
    51d2:	86 36       	cpi	r24, 0x66	; 102
    51d4:	21 f4       	brne	.+8      	; 0x51de <vfprintf+0x13a>
    51d6:	62 2f       	mov	r22, r18
    51d8:	60 68       	ori	r22, 0x80	; 128
    51da:	76 2e       	mov	r7, r22
    51dc:	02 c0       	rjmp	.+4      	; 0x51e2 <vfprintf+0x13e>
    51de:	11 11       	cpse	r17, r1
    51e0:	11 50       	subi	r17, 0x01	; 1
    51e2:	77 fe       	sbrs	r7, 7
    51e4:	07 c0       	rjmp	.+14     	; 0x51f4 <vfprintf+0x150>
    51e6:	1c 33       	cpi	r17, 0x3C	; 60
    51e8:	48 f4       	brcc	.+18     	; 0x51fc <vfprintf+0x158>
    51ea:	44 24       	eor	r4, r4
    51ec:	43 94       	inc	r4
    51ee:	41 0e       	add	r4, r17
    51f0:	27 e0       	ldi	r18, 0x07	; 7
    51f2:	0b c0       	rjmp	.+22     	; 0x520a <vfprintf+0x166>
    51f4:	18 30       	cpi	r17, 0x08	; 8
    51f6:	30 f4       	brcc	.+12     	; 0x5204 <vfprintf+0x160>
    51f8:	21 2f       	mov	r18, r17
    51fa:	06 c0       	rjmp	.+12     	; 0x5208 <vfprintf+0x164>
    51fc:	27 e0       	ldi	r18, 0x07	; 7
    51fe:	4c e3       	ldi	r20, 0x3C	; 60
    5200:	44 2e       	mov	r4, r20
    5202:	03 c0       	rjmp	.+6      	; 0x520a <vfprintf+0x166>
    5204:	27 e0       	ldi	r18, 0x07	; 7
    5206:	17 e0       	ldi	r17, 0x07	; 7
    5208:	41 2c       	mov	r4, r1
    520a:	56 01       	movw	r10, r12
    520c:	74 e0       	ldi	r23, 0x04	; 4
    520e:	a7 0e       	add	r10, r23
    5210:	b1 1c       	adc	r11, r1
    5212:	f6 01       	movw	r30, r12
    5214:	60 81       	ld	r22, Z
    5216:	71 81       	ldd	r23, Z+1	; 0x01
    5218:	82 81       	ldd	r24, Z+2	; 0x02
    521a:	93 81       	ldd	r25, Z+3	; 0x03
    521c:	04 2d       	mov	r16, r4
    521e:	a4 01       	movw	r20, r8
    5220:	55 d3       	rcall	.+1706   	; 0x58cc <__ftoa_engine>
    5222:	6c 01       	movw	r12, r24
    5224:	09 81       	ldd	r16, Y+1	; 0x01
    5226:	00 ff       	sbrs	r16, 0
    5228:	02 c0       	rjmp	.+4      	; 0x522e <vfprintf+0x18a>
    522a:	03 ff       	sbrs	r16, 3
    522c:	06 c0       	rjmp	.+12     	; 0x523a <vfprintf+0x196>
    522e:	71 fc       	sbrc	r7, 1
    5230:	07 c0       	rjmp	.+14     	; 0x5240 <vfprintf+0x19c>
    5232:	72 fc       	sbrc	r7, 2
    5234:	08 c0       	rjmp	.+16     	; 0x5246 <vfprintf+0x1a2>
    5236:	61 2c       	mov	r6, r1
    5238:	08 c0       	rjmp	.+16     	; 0x524a <vfprintf+0x1a6>
    523a:	3d e2       	ldi	r19, 0x2D	; 45
    523c:	63 2e       	mov	r6, r19
    523e:	05 c0       	rjmp	.+10     	; 0x524a <vfprintf+0x1a6>
    5240:	2b e2       	ldi	r18, 0x2B	; 43
    5242:	62 2e       	mov	r6, r18
    5244:	02 c0       	rjmp	.+4      	; 0x524a <vfprintf+0x1a6>
    5246:	90 e2       	ldi	r25, 0x20	; 32
    5248:	69 2e       	mov	r6, r25
    524a:	80 2f       	mov	r24, r16
    524c:	8c 70       	andi	r24, 0x0C	; 12
    524e:	81 f1       	breq	.+96     	; 0x52b0 <vfprintf+0x20c>
    5250:	66 20       	and	r6, r6
    5252:	11 f0       	breq	.+4      	; 0x5258 <vfprintf+0x1b4>
    5254:	84 e0       	ldi	r24, 0x04	; 4
    5256:	01 c0       	rjmp	.+2      	; 0x525a <vfprintf+0x1b6>
    5258:	83 e0       	ldi	r24, 0x03	; 3
    525a:	85 15       	cp	r24, r5
    525c:	10 f0       	brcs	.+4      	; 0x5262 <vfprintf+0x1be>
    525e:	51 2c       	mov	r5, r1
    5260:	0a c0       	rjmp	.+20     	; 0x5276 <vfprintf+0x1d2>
    5262:	58 1a       	sub	r5, r24
    5264:	73 fc       	sbrc	r7, 3
    5266:	07 c0       	rjmp	.+14     	; 0x5276 <vfprintf+0x1d2>
    5268:	b7 01       	movw	r22, r14
    526a:	80 e2       	ldi	r24, 0x20	; 32
    526c:	90 e0       	ldi	r25, 0x00	; 0
    526e:	8b d4       	rcall	.+2326   	; 0x5b86 <fputc>
    5270:	5a 94       	dec	r5
    5272:	d1 f7       	brne	.-12     	; 0x5268 <vfprintf+0x1c4>
    5274:	f4 cf       	rjmp	.-24     	; 0x525e <vfprintf+0x1ba>
    5276:	66 20       	and	r6, r6
    5278:	21 f0       	breq	.+8      	; 0x5282 <vfprintf+0x1de>
    527a:	b7 01       	movw	r22, r14
    527c:	86 2d       	mov	r24, r6
    527e:	90 e0       	ldi	r25, 0x00	; 0
    5280:	82 d4       	rcall	.+2308   	; 0x5b86 <fputc>
    5282:	03 fd       	sbrc	r16, 3
    5284:	03 c0       	rjmp	.+6      	; 0x528c <vfprintf+0x1e8>
    5286:	0e e0       	ldi	r16, 0x0E	; 14
    5288:	16 e0       	ldi	r17, 0x06	; 6
    528a:	02 c0       	rjmp	.+4      	; 0x5290 <vfprintf+0x1ec>
    528c:	0a e0       	ldi	r16, 0x0A	; 10
    528e:	16 e0       	ldi	r17, 0x06	; 6
    5290:	f7 2d       	mov	r31, r7
    5292:	f0 71       	andi	r31, 0x10	; 16
    5294:	7f 2e       	mov	r7, r31
    5296:	f8 01       	movw	r30, r16
    5298:	84 91       	lpm	r24, Z
    529a:	88 23       	and	r24, r24
    529c:	09 f4       	brne	.+2      	; 0x52a0 <vfprintf+0x1fc>
    529e:	5e c2       	rjmp	.+1212   	; 0x575c <vfprintf+0x6b8>
    52a0:	71 10       	cpse	r7, r1
    52a2:	80 52       	subi	r24, 0x20	; 32
    52a4:	b7 01       	movw	r22, r14
    52a6:	90 e0       	ldi	r25, 0x00	; 0
    52a8:	6e d4       	rcall	.+2268   	; 0x5b86 <fputc>
    52aa:	0f 5f       	subi	r16, 0xFF	; 255
    52ac:	1f 4f       	sbci	r17, 0xFF	; 255
    52ae:	f3 cf       	rjmp	.-26     	; 0x5296 <vfprintf+0x1f2>
    52b0:	77 fe       	sbrs	r7, 7
    52b2:	0f c0       	rjmp	.+30     	; 0x52d2 <vfprintf+0x22e>
    52b4:	4c 0c       	add	r4, r12
    52b6:	04 ff       	sbrs	r16, 4
    52b8:	04 c0       	rjmp	.+8      	; 0x52c2 <vfprintf+0x21e>
    52ba:	8a 81       	ldd	r24, Y+2	; 0x02
    52bc:	81 33       	cpi	r24, 0x31	; 49
    52be:	09 f4       	brne	.+2      	; 0x52c2 <vfprintf+0x21e>
    52c0:	4a 94       	dec	r4
    52c2:	14 14       	cp	r1, r4
    52c4:	74 f5       	brge	.+92     	; 0x5322 <vfprintf+0x27e>
    52c6:	f8 e0       	ldi	r31, 0x08	; 8
    52c8:	f4 15       	cp	r31, r4
    52ca:	78 f5       	brcc	.+94     	; 0x532a <vfprintf+0x286>
    52cc:	88 e0       	ldi	r24, 0x08	; 8
    52ce:	48 2e       	mov	r4, r24
    52d0:	2c c0       	rjmp	.+88     	; 0x532a <vfprintf+0x286>
    52d2:	76 fc       	sbrc	r7, 6
    52d4:	2a c0       	rjmp	.+84     	; 0x532a <vfprintf+0x286>
    52d6:	81 2f       	mov	r24, r17
    52d8:	90 e0       	ldi	r25, 0x00	; 0
    52da:	8c 15       	cp	r24, r12
    52dc:	9d 05       	cpc	r25, r13
    52de:	9c f0       	brlt	.+38     	; 0x5306 <vfprintf+0x262>
    52e0:	6c ef       	ldi	r22, 0xFC	; 252
    52e2:	c6 16       	cp	r12, r22
    52e4:	6f ef       	ldi	r22, 0xFF	; 255
    52e6:	d6 06       	cpc	r13, r22
    52e8:	74 f0       	brlt	.+28     	; 0x5306 <vfprintf+0x262>
    52ea:	77 2d       	mov	r23, r7
    52ec:	70 68       	ori	r23, 0x80	; 128
    52ee:	77 2e       	mov	r7, r23
    52f0:	0a c0       	rjmp	.+20     	; 0x5306 <vfprintf+0x262>
    52f2:	e2 e0       	ldi	r30, 0x02	; 2
    52f4:	f0 e0       	ldi	r31, 0x00	; 0
    52f6:	ec 0f       	add	r30, r28
    52f8:	fd 1f       	adc	r31, r29
    52fa:	e1 0f       	add	r30, r17
    52fc:	f1 1d       	adc	r31, r1
    52fe:	80 81       	ld	r24, Z
    5300:	80 33       	cpi	r24, 0x30	; 48
    5302:	19 f4       	brne	.+6      	; 0x530a <vfprintf+0x266>
    5304:	11 50       	subi	r17, 0x01	; 1
    5306:	11 11       	cpse	r17, r1
    5308:	f4 cf       	rjmp	.-24     	; 0x52f2 <vfprintf+0x24e>
    530a:	77 fe       	sbrs	r7, 7
    530c:	0e c0       	rjmp	.+28     	; 0x532a <vfprintf+0x286>
    530e:	44 24       	eor	r4, r4
    5310:	43 94       	inc	r4
    5312:	41 0e       	add	r4, r17
    5314:	81 2f       	mov	r24, r17
    5316:	90 e0       	ldi	r25, 0x00	; 0
    5318:	c8 16       	cp	r12, r24
    531a:	d9 06       	cpc	r13, r25
    531c:	2c f4       	brge	.+10     	; 0x5328 <vfprintf+0x284>
    531e:	1c 19       	sub	r17, r12
    5320:	04 c0       	rjmp	.+8      	; 0x532a <vfprintf+0x286>
    5322:	44 24       	eor	r4, r4
    5324:	43 94       	inc	r4
    5326:	01 c0       	rjmp	.+2      	; 0x532a <vfprintf+0x286>
    5328:	10 e0       	ldi	r17, 0x00	; 0
    532a:	77 fe       	sbrs	r7, 7
    532c:	07 c0       	rjmp	.+14     	; 0x533c <vfprintf+0x298>
    532e:	1c 14       	cp	r1, r12
    5330:	1d 04       	cpc	r1, r13
    5332:	3c f4       	brge	.+14     	; 0x5342 <vfprintf+0x29e>
    5334:	96 01       	movw	r18, r12
    5336:	2f 5f       	subi	r18, 0xFF	; 255
    5338:	3f 4f       	sbci	r19, 0xFF	; 255
    533a:	05 c0       	rjmp	.+10     	; 0x5346 <vfprintf+0x2a2>
    533c:	25 e0       	ldi	r18, 0x05	; 5
    533e:	30 e0       	ldi	r19, 0x00	; 0
    5340:	02 c0       	rjmp	.+4      	; 0x5346 <vfprintf+0x2a2>
    5342:	21 e0       	ldi	r18, 0x01	; 1
    5344:	30 e0       	ldi	r19, 0x00	; 0
    5346:	66 20       	and	r6, r6
    5348:	11 f0       	breq	.+4      	; 0x534e <vfprintf+0x2aa>
    534a:	2f 5f       	subi	r18, 0xFF	; 255
    534c:	3f 4f       	sbci	r19, 0xFF	; 255
    534e:	11 23       	and	r17, r17
    5350:	31 f0       	breq	.+12     	; 0x535e <vfprintf+0x2ba>
    5352:	41 2f       	mov	r20, r17
    5354:	50 e0       	ldi	r21, 0x00	; 0
    5356:	4f 5f       	subi	r20, 0xFF	; 255
    5358:	5f 4f       	sbci	r21, 0xFF	; 255
    535a:	24 0f       	add	r18, r20
    535c:	35 1f       	adc	r19, r21
    535e:	45 2d       	mov	r20, r5
    5360:	50 e0       	ldi	r21, 0x00	; 0
    5362:	24 17       	cp	r18, r20
    5364:	35 07       	cpc	r19, r21
    5366:	14 f4       	brge	.+4      	; 0x536c <vfprintf+0x2c8>
    5368:	52 1a       	sub	r5, r18
    536a:	01 c0       	rjmp	.+2      	; 0x536e <vfprintf+0x2ca>
    536c:	51 2c       	mov	r5, r1
    536e:	87 2d       	mov	r24, r7
    5370:	89 70       	andi	r24, 0x09	; 9
    5372:	41 f4       	brne	.+16     	; 0x5384 <vfprintf+0x2e0>
    5374:	55 20       	and	r5, r5
    5376:	31 f0       	breq	.+12     	; 0x5384 <vfprintf+0x2e0>
    5378:	b7 01       	movw	r22, r14
    537a:	80 e2       	ldi	r24, 0x20	; 32
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	03 d4       	rcall	.+2054   	; 0x5b86 <fputc>
    5380:	5a 94       	dec	r5
    5382:	f8 cf       	rjmp	.-16     	; 0x5374 <vfprintf+0x2d0>
    5384:	66 20       	and	r6, r6
    5386:	21 f0       	breq	.+8      	; 0x5390 <vfprintf+0x2ec>
    5388:	b7 01       	movw	r22, r14
    538a:	86 2d       	mov	r24, r6
    538c:	90 e0       	ldi	r25, 0x00	; 0
    538e:	fb d3       	rcall	.+2038   	; 0x5b86 <fputc>
    5390:	73 fc       	sbrc	r7, 3
    5392:	08 c0       	rjmp	.+16     	; 0x53a4 <vfprintf+0x300>
    5394:	55 20       	and	r5, r5
    5396:	31 f0       	breq	.+12     	; 0x53a4 <vfprintf+0x300>
    5398:	b7 01       	movw	r22, r14
    539a:	80 e3       	ldi	r24, 0x30	; 48
    539c:	90 e0       	ldi	r25, 0x00	; 0
    539e:	f3 d3       	rcall	.+2022   	; 0x5b86 <fputc>
    53a0:	5a 94       	dec	r5
    53a2:	f8 cf       	rjmp	.-16     	; 0x5394 <vfprintf+0x2f0>
    53a4:	77 fe       	sbrs	r7, 7
    53a6:	5d c0       	rjmp	.+186    	; 0x5462 <vfprintf+0x3be>
    53a8:	9c 2d       	mov	r25, r12
    53aa:	8d 2d       	mov	r24, r13
    53ac:	d7 fe       	sbrs	r13, 7
    53ae:	02 c0       	rjmp	.+4      	; 0x53b4 <vfprintf+0x310>
    53b0:	90 e0       	ldi	r25, 0x00	; 0
    53b2:	80 e0       	ldi	r24, 0x00	; 0
    53b4:	69 2e       	mov	r6, r25
    53b6:	78 2e       	mov	r7, r24
    53b8:	40 e0       	ldi	r20, 0x00	; 0
    53ba:	50 e0       	ldi	r21, 0x00	; 0
    53bc:	c6 01       	movw	r24, r12
    53be:	84 19       	sub	r24, r4
    53c0:	91 09       	sbc	r25, r1
    53c2:	8c 87       	std	Y+12, r24	; 0x0c
    53c4:	9d 87       	std	Y+13, r25	; 0x0d
    53c6:	96 01       	movw	r18, r12
    53c8:	26 19       	sub	r18, r6
    53ca:	37 09       	sbc	r19, r7
    53cc:	28 0d       	add	r18, r8
    53ce:	39 1d       	adc	r19, r9
    53d0:	81 2f       	mov	r24, r17
    53d2:	90 e0       	ldi	r25, 0x00	; 0
    53d4:	ee 27       	eor	r30, r30
    53d6:	ff 27       	eor	r31, r31
    53d8:	e8 1b       	sub	r30, r24
    53da:	f9 0b       	sbc	r31, r25
    53dc:	ee 87       	std	Y+14, r30	; 0x0e
    53de:	ff 87       	std	Y+15, r31	; 0x0f
    53e0:	ff ef       	ldi	r31, 0xFF	; 255
    53e2:	6f 16       	cp	r6, r31
    53e4:	7f 06       	cpc	r7, r31
    53e6:	61 f4       	brne	.+24     	; 0x5400 <vfprintf+0x35c>
    53e8:	b7 01       	movw	r22, r14
    53ea:	8e e2       	ldi	r24, 0x2E	; 46
    53ec:	90 e0       	ldi	r25, 0x00	; 0
    53ee:	2b 8b       	std	Y+19, r18	; 0x13
    53f0:	3a 8b       	std	Y+18, r19	; 0x12
    53f2:	48 8b       	std	Y+16, r20	; 0x10
    53f4:	59 8b       	std	Y+17, r21	; 0x11
    53f6:	c7 d3       	rcall	.+1934   	; 0x5b86 <fputc>
    53f8:	59 89       	ldd	r21, Y+17	; 0x11
    53fa:	48 89       	ldd	r20, Y+16	; 0x10
    53fc:	3a 89       	ldd	r19, Y+18	; 0x12
    53fe:	2b 89       	ldd	r18, Y+19	; 0x13
    5400:	c6 14       	cp	r12, r6
    5402:	d7 04       	cpc	r13, r7
    5404:	54 f0       	brlt	.+20     	; 0x541a <vfprintf+0x376>
    5406:	6c 85       	ldd	r22, Y+12	; 0x0c
    5408:	7d 85       	ldd	r23, Y+13	; 0x0d
    540a:	66 15       	cp	r22, r6
    540c:	77 05       	cpc	r23, r7
    540e:	2c f4       	brge	.+10     	; 0x541a <vfprintf+0x376>
    5410:	f9 01       	movw	r30, r18
    5412:	e4 0f       	add	r30, r20
    5414:	f5 1f       	adc	r31, r21
    5416:	81 81       	ldd	r24, Z+1	; 0x01
    5418:	01 c0       	rjmp	.+2      	; 0x541c <vfprintf+0x378>
    541a:	80 e3       	ldi	r24, 0x30	; 48
    541c:	71 e0       	ldi	r23, 0x01	; 1
    541e:	67 1a       	sub	r6, r23
    5420:	71 08       	sbc	r7, r1
    5422:	4f 5f       	subi	r20, 0xFF	; 255
    5424:	5f 4f       	sbci	r21, 0xFF	; 255
    5426:	ee 85       	ldd	r30, Y+14	; 0x0e
    5428:	ff 85       	ldd	r31, Y+15	; 0x0f
    542a:	6e 16       	cp	r6, r30
    542c:	7f 06       	cpc	r7, r31
    542e:	64 f0       	brlt	.+24     	; 0x5448 <vfprintf+0x3a4>
    5430:	b7 01       	movw	r22, r14
    5432:	90 e0       	ldi	r25, 0x00	; 0
    5434:	2b 8b       	std	Y+19, r18	; 0x13
    5436:	3a 8b       	std	Y+18, r19	; 0x12
    5438:	48 8b       	std	Y+16, r20	; 0x10
    543a:	59 8b       	std	Y+17, r21	; 0x11
    543c:	a4 d3       	rcall	.+1864   	; 0x5b86 <fputc>
    543e:	2b 89       	ldd	r18, Y+19	; 0x13
    5440:	3a 89       	ldd	r19, Y+18	; 0x12
    5442:	48 89       	ldd	r20, Y+16	; 0x10
    5444:	59 89       	ldd	r21, Y+17	; 0x11
    5446:	cc cf       	rjmp	.-104    	; 0x53e0 <vfprintf+0x33c>
    5448:	6c 14       	cp	r6, r12
    544a:	7d 04       	cpc	r7, r13
    544c:	39 f4       	brne	.+14     	; 0x545c <vfprintf+0x3b8>
    544e:	9a 81       	ldd	r25, Y+2	; 0x02
    5450:	96 33       	cpi	r25, 0x36	; 54
    5452:	18 f4       	brcc	.+6      	; 0x545a <vfprintf+0x3b6>
    5454:	95 33       	cpi	r25, 0x35	; 53
    5456:	11 f4       	brne	.+4      	; 0x545c <vfprintf+0x3b8>
    5458:	04 ff       	sbrs	r16, 4
    545a:	81 e3       	ldi	r24, 0x31	; 49
    545c:	b7 01       	movw	r22, r14
    545e:	90 e0       	ldi	r25, 0x00	; 0
    5460:	45 c0       	rjmp	.+138    	; 0x54ec <vfprintf+0x448>
    5462:	8a 81       	ldd	r24, Y+2	; 0x02
    5464:	81 33       	cpi	r24, 0x31	; 49
    5466:	09 f0       	breq	.+2      	; 0x546a <vfprintf+0x3c6>
    5468:	0f 7e       	andi	r16, 0xEF	; 239
    546a:	b7 01       	movw	r22, r14
    546c:	90 e0       	ldi	r25, 0x00	; 0
    546e:	8b d3       	rcall	.+1814   	; 0x5b86 <fputc>
    5470:	11 11       	cpse	r17, r1
    5472:	05 c0       	rjmp	.+10     	; 0x547e <vfprintf+0x3da>
    5474:	74 fe       	sbrs	r7, 4
    5476:	16 c0       	rjmp	.+44     	; 0x54a4 <vfprintf+0x400>
    5478:	85 e4       	ldi	r24, 0x45	; 69
    547a:	90 e0       	ldi	r25, 0x00	; 0
    547c:	15 c0       	rjmp	.+42     	; 0x54a8 <vfprintf+0x404>
    547e:	b7 01       	movw	r22, r14
    5480:	8e e2       	ldi	r24, 0x2E	; 46
    5482:	90 e0       	ldi	r25, 0x00	; 0
    5484:	80 d3       	rcall	.+1792   	; 0x5b86 <fputc>
    5486:	82 e0       	ldi	r24, 0x02	; 2
    5488:	66 24       	eor	r6, r6
    548a:	63 94       	inc	r6
    548c:	68 0e       	add	r6, r24
    548e:	f4 01       	movw	r30, r8
    5490:	e8 0f       	add	r30, r24
    5492:	f1 1d       	adc	r31, r1
    5494:	80 81       	ld	r24, Z
    5496:	b7 01       	movw	r22, r14
    5498:	90 e0       	ldi	r25, 0x00	; 0
    549a:	75 d3       	rcall	.+1770   	; 0x5b86 <fputc>
    549c:	11 50       	subi	r17, 0x01	; 1
    549e:	51 f3       	breq	.-44     	; 0x5474 <vfprintf+0x3d0>
    54a0:	86 2d       	mov	r24, r6
    54a2:	f2 cf       	rjmp	.-28     	; 0x5488 <vfprintf+0x3e4>
    54a4:	85 e6       	ldi	r24, 0x65	; 101
    54a6:	90 e0       	ldi	r25, 0x00	; 0
    54a8:	b7 01       	movw	r22, r14
    54aa:	6d d3       	rcall	.+1754   	; 0x5b86 <fputc>
    54ac:	d7 fc       	sbrc	r13, 7
    54ae:	05 c0       	rjmp	.+10     	; 0x54ba <vfprintf+0x416>
    54b0:	c1 14       	cp	r12, r1
    54b2:	d1 04       	cpc	r13, r1
    54b4:	39 f4       	brne	.+14     	; 0x54c4 <vfprintf+0x420>
    54b6:	04 ff       	sbrs	r16, 4
    54b8:	05 c0       	rjmp	.+10     	; 0x54c4 <vfprintf+0x420>
    54ba:	d1 94       	neg	r13
    54bc:	c1 94       	neg	r12
    54be:	d1 08       	sbc	r13, r1
    54c0:	8d e2       	ldi	r24, 0x2D	; 45
    54c2:	01 c0       	rjmp	.+2      	; 0x54c6 <vfprintf+0x422>
    54c4:	8b e2       	ldi	r24, 0x2B	; 43
    54c6:	b7 01       	movw	r22, r14
    54c8:	90 e0       	ldi	r25, 0x00	; 0
    54ca:	5d d3       	rcall	.+1722   	; 0x5b86 <fputc>
    54cc:	80 e3       	ldi	r24, 0x30	; 48
    54ce:	6a e0       	ldi	r22, 0x0A	; 10
    54d0:	c6 16       	cp	r12, r22
    54d2:	d1 04       	cpc	r13, r1
    54d4:	2c f0       	brlt	.+10     	; 0x54e0 <vfprintf+0x43c>
    54d6:	8f 5f       	subi	r24, 0xFF	; 255
    54d8:	fa e0       	ldi	r31, 0x0A	; 10
    54da:	cf 1a       	sub	r12, r31
    54dc:	d1 08       	sbc	r13, r1
    54de:	f7 cf       	rjmp	.-18     	; 0x54ce <vfprintf+0x42a>
    54e0:	b7 01       	movw	r22, r14
    54e2:	90 e0       	ldi	r25, 0x00	; 0
    54e4:	50 d3       	rcall	.+1696   	; 0x5b86 <fputc>
    54e6:	b7 01       	movw	r22, r14
    54e8:	c6 01       	movw	r24, r12
    54ea:	c0 96       	adiw	r24, 0x30	; 48
    54ec:	4c d3       	rcall	.+1688   	; 0x5b86 <fputc>
    54ee:	36 c1       	rjmp	.+620    	; 0x575c <vfprintf+0x6b8>
    54f0:	83 36       	cpi	r24, 0x63	; 99
    54f2:	31 f0       	breq	.+12     	; 0x5500 <vfprintf+0x45c>
    54f4:	83 37       	cpi	r24, 0x73	; 115
    54f6:	79 f0       	breq	.+30     	; 0x5516 <vfprintf+0x472>
    54f8:	83 35       	cpi	r24, 0x53	; 83
    54fa:	09 f0       	breq	.+2      	; 0x54fe <vfprintf+0x45a>
    54fc:	54 c0       	rjmp	.+168    	; 0x55a6 <vfprintf+0x502>
    54fe:	20 c0       	rjmp	.+64     	; 0x5540 <vfprintf+0x49c>
    5500:	56 01       	movw	r10, r12
    5502:	72 e0       	ldi	r23, 0x02	; 2
    5504:	a7 0e       	add	r10, r23
    5506:	b1 1c       	adc	r11, r1
    5508:	f6 01       	movw	r30, r12
    550a:	80 81       	ld	r24, Z
    550c:	89 83       	std	Y+1, r24	; 0x01
    550e:	01 e0       	ldi	r16, 0x01	; 1
    5510:	10 e0       	ldi	r17, 0x00	; 0
    5512:	64 01       	movw	r12, r8
    5514:	13 c0       	rjmp	.+38     	; 0x553c <vfprintf+0x498>
    5516:	56 01       	movw	r10, r12
    5518:	f2 e0       	ldi	r31, 0x02	; 2
    551a:	af 0e       	add	r10, r31
    551c:	b1 1c       	adc	r11, r1
    551e:	f6 01       	movw	r30, r12
    5520:	c0 80       	ld	r12, Z
    5522:	d1 80       	ldd	r13, Z+1	; 0x01
    5524:	26 ff       	sbrs	r18, 6
    5526:	03 c0       	rjmp	.+6      	; 0x552e <vfprintf+0x48a>
    5528:	61 2f       	mov	r22, r17
    552a:	70 e0       	ldi	r23, 0x00	; 0
    552c:	02 c0       	rjmp	.+4      	; 0x5532 <vfprintf+0x48e>
    552e:	6f ef       	ldi	r22, 0xFF	; 255
    5530:	7f ef       	ldi	r23, 0xFF	; 255
    5532:	c6 01       	movw	r24, r12
    5534:	2b 8b       	std	Y+19, r18	; 0x13
    5536:	f9 d2       	rcall	.+1522   	; 0x5b2a <strnlen>
    5538:	8c 01       	movw	r16, r24
    553a:	2b 89       	ldd	r18, Y+19	; 0x13
    553c:	2f 77       	andi	r18, 0x7F	; 127
    553e:	14 c0       	rjmp	.+40     	; 0x5568 <vfprintf+0x4c4>
    5540:	56 01       	movw	r10, r12
    5542:	f2 e0       	ldi	r31, 0x02	; 2
    5544:	af 0e       	add	r10, r31
    5546:	b1 1c       	adc	r11, r1
    5548:	f6 01       	movw	r30, r12
    554a:	c0 80       	ld	r12, Z
    554c:	d1 80       	ldd	r13, Z+1	; 0x01
    554e:	26 ff       	sbrs	r18, 6
    5550:	03 c0       	rjmp	.+6      	; 0x5558 <vfprintf+0x4b4>
    5552:	61 2f       	mov	r22, r17
    5554:	70 e0       	ldi	r23, 0x00	; 0
    5556:	02 c0       	rjmp	.+4      	; 0x555c <vfprintf+0x4b8>
    5558:	6f ef       	ldi	r22, 0xFF	; 255
    555a:	7f ef       	ldi	r23, 0xFF	; 255
    555c:	c6 01       	movw	r24, r12
    555e:	2b 8b       	std	Y+19, r18	; 0x13
    5560:	8d d2       	rcall	.+1306   	; 0x5a7c <strnlen_P>
    5562:	8c 01       	movw	r16, r24
    5564:	2b 89       	ldd	r18, Y+19	; 0x13
    5566:	20 68       	ori	r18, 0x80	; 128
    5568:	72 2e       	mov	r7, r18
    556a:	23 fd       	sbrc	r18, 3
    556c:	18 c0       	rjmp	.+48     	; 0x559e <vfprintf+0x4fa>
    556e:	85 2d       	mov	r24, r5
    5570:	90 e0       	ldi	r25, 0x00	; 0
    5572:	08 17       	cp	r16, r24
    5574:	19 07       	cpc	r17, r25
    5576:	98 f4       	brcc	.+38     	; 0x559e <vfprintf+0x4fa>
    5578:	b7 01       	movw	r22, r14
    557a:	80 e2       	ldi	r24, 0x20	; 32
    557c:	90 e0       	ldi	r25, 0x00	; 0
    557e:	03 d3       	rcall	.+1542   	; 0x5b86 <fputc>
    5580:	5a 94       	dec	r5
    5582:	f5 cf       	rjmp	.-22     	; 0x556e <vfprintf+0x4ca>
    5584:	f6 01       	movw	r30, r12
    5586:	77 fc       	sbrc	r7, 7
    5588:	85 91       	lpm	r24, Z+
    558a:	77 fe       	sbrs	r7, 7
    558c:	81 91       	ld	r24, Z+
    558e:	6f 01       	movw	r12, r30
    5590:	b7 01       	movw	r22, r14
    5592:	90 e0       	ldi	r25, 0x00	; 0
    5594:	f8 d2       	rcall	.+1520   	; 0x5b86 <fputc>
    5596:	51 10       	cpse	r5, r1
    5598:	5a 94       	dec	r5
    559a:	01 50       	subi	r16, 0x01	; 1
    559c:	11 09       	sbc	r17, r1
    559e:	01 15       	cp	r16, r1
    55a0:	11 05       	cpc	r17, r1
    55a2:	81 f7       	brne	.-32     	; 0x5584 <vfprintf+0x4e0>
    55a4:	db c0       	rjmp	.+438    	; 0x575c <vfprintf+0x6b8>
    55a6:	84 36       	cpi	r24, 0x64	; 100
    55a8:	11 f0       	breq	.+4      	; 0x55ae <vfprintf+0x50a>
    55aa:	89 36       	cpi	r24, 0x69	; 105
    55ac:	49 f5       	brne	.+82     	; 0x5600 <vfprintf+0x55c>
    55ae:	56 01       	movw	r10, r12
    55b0:	27 ff       	sbrs	r18, 7
    55b2:	09 c0       	rjmp	.+18     	; 0x55c6 <vfprintf+0x522>
    55b4:	f4 e0       	ldi	r31, 0x04	; 4
    55b6:	af 0e       	add	r10, r31
    55b8:	b1 1c       	adc	r11, r1
    55ba:	f6 01       	movw	r30, r12
    55bc:	60 81       	ld	r22, Z
    55be:	71 81       	ldd	r23, Z+1	; 0x01
    55c0:	82 81       	ldd	r24, Z+2	; 0x02
    55c2:	93 81       	ldd	r25, Z+3	; 0x03
    55c4:	0a c0       	rjmp	.+20     	; 0x55da <vfprintf+0x536>
    55c6:	f2 e0       	ldi	r31, 0x02	; 2
    55c8:	af 0e       	add	r10, r31
    55ca:	b1 1c       	adc	r11, r1
    55cc:	f6 01       	movw	r30, r12
    55ce:	60 81       	ld	r22, Z
    55d0:	71 81       	ldd	r23, Z+1	; 0x01
    55d2:	88 27       	eor	r24, r24
    55d4:	77 fd       	sbrc	r23, 7
    55d6:	80 95       	com	r24
    55d8:	98 2f       	mov	r25, r24
    55da:	02 2f       	mov	r16, r18
    55dc:	0f 76       	andi	r16, 0x6F	; 111
    55de:	97 ff       	sbrs	r25, 7
    55e0:	08 c0       	rjmp	.+16     	; 0x55f2 <vfprintf+0x54e>
    55e2:	90 95       	com	r25
    55e4:	80 95       	com	r24
    55e6:	70 95       	com	r23
    55e8:	61 95       	neg	r22
    55ea:	7f 4f       	sbci	r23, 0xFF	; 255
    55ec:	8f 4f       	sbci	r24, 0xFF	; 255
    55ee:	9f 4f       	sbci	r25, 0xFF	; 255
    55f0:	00 68       	ori	r16, 0x80	; 128
    55f2:	2a e0       	ldi	r18, 0x0A	; 10
    55f4:	30 e0       	ldi	r19, 0x00	; 0
    55f6:	a4 01       	movw	r20, r8
    55f8:	20 d3       	rcall	.+1600   	; 0x5c3a <__ultoa_invert>
    55fa:	c8 2e       	mov	r12, r24
    55fc:	c8 18       	sub	r12, r8
    55fe:	3d c0       	rjmp	.+122    	; 0x567a <vfprintf+0x5d6>
    5600:	02 2f       	mov	r16, r18
    5602:	85 37       	cpi	r24, 0x75	; 117
    5604:	21 f4       	brne	.+8      	; 0x560e <vfprintf+0x56a>
    5606:	0f 7e       	andi	r16, 0xEF	; 239
    5608:	2a e0       	ldi	r18, 0x0A	; 10
    560a:	30 e0       	ldi	r19, 0x00	; 0
    560c:	1d c0       	rjmp	.+58     	; 0x5648 <vfprintf+0x5a4>
    560e:	09 7f       	andi	r16, 0xF9	; 249
    5610:	8f 36       	cpi	r24, 0x6F	; 111
    5612:	91 f0       	breq	.+36     	; 0x5638 <vfprintf+0x594>
    5614:	18 f4       	brcc	.+6      	; 0x561c <vfprintf+0x578>
    5616:	88 35       	cpi	r24, 0x58	; 88
    5618:	59 f0       	breq	.+22     	; 0x5630 <vfprintf+0x58c>
    561a:	a9 c0       	rjmp	.+338    	; 0x576e <vfprintf+0x6ca>
    561c:	80 37       	cpi	r24, 0x70	; 112
    561e:	19 f0       	breq	.+6      	; 0x5626 <vfprintf+0x582>
    5620:	88 37       	cpi	r24, 0x78	; 120
    5622:	11 f0       	breq	.+4      	; 0x5628 <vfprintf+0x584>
    5624:	a4 c0       	rjmp	.+328    	; 0x576e <vfprintf+0x6ca>
    5626:	00 61       	ori	r16, 0x10	; 16
    5628:	04 ff       	sbrs	r16, 4
    562a:	09 c0       	rjmp	.+18     	; 0x563e <vfprintf+0x59a>
    562c:	04 60       	ori	r16, 0x04	; 4
    562e:	07 c0       	rjmp	.+14     	; 0x563e <vfprintf+0x59a>
    5630:	24 ff       	sbrs	r18, 4
    5632:	08 c0       	rjmp	.+16     	; 0x5644 <vfprintf+0x5a0>
    5634:	06 60       	ori	r16, 0x06	; 6
    5636:	06 c0       	rjmp	.+12     	; 0x5644 <vfprintf+0x5a0>
    5638:	28 e0       	ldi	r18, 0x08	; 8
    563a:	30 e0       	ldi	r19, 0x00	; 0
    563c:	05 c0       	rjmp	.+10     	; 0x5648 <vfprintf+0x5a4>
    563e:	20 e1       	ldi	r18, 0x10	; 16
    5640:	30 e0       	ldi	r19, 0x00	; 0
    5642:	02 c0       	rjmp	.+4      	; 0x5648 <vfprintf+0x5a4>
    5644:	20 e1       	ldi	r18, 0x10	; 16
    5646:	32 e0       	ldi	r19, 0x02	; 2
    5648:	56 01       	movw	r10, r12
    564a:	07 ff       	sbrs	r16, 7
    564c:	09 c0       	rjmp	.+18     	; 0x5660 <vfprintf+0x5bc>
    564e:	f4 e0       	ldi	r31, 0x04	; 4
    5650:	af 0e       	add	r10, r31
    5652:	b1 1c       	adc	r11, r1
    5654:	f6 01       	movw	r30, r12
    5656:	60 81       	ld	r22, Z
    5658:	71 81       	ldd	r23, Z+1	; 0x01
    565a:	82 81       	ldd	r24, Z+2	; 0x02
    565c:	93 81       	ldd	r25, Z+3	; 0x03
    565e:	08 c0       	rjmp	.+16     	; 0x5670 <vfprintf+0x5cc>
    5660:	f2 e0       	ldi	r31, 0x02	; 2
    5662:	af 0e       	add	r10, r31
    5664:	b1 1c       	adc	r11, r1
    5666:	f6 01       	movw	r30, r12
    5668:	60 81       	ld	r22, Z
    566a:	71 81       	ldd	r23, Z+1	; 0x01
    566c:	80 e0       	ldi	r24, 0x00	; 0
    566e:	90 e0       	ldi	r25, 0x00	; 0
    5670:	a4 01       	movw	r20, r8
    5672:	e3 d2       	rcall	.+1478   	; 0x5c3a <__ultoa_invert>
    5674:	c8 2e       	mov	r12, r24
    5676:	c8 18       	sub	r12, r8
    5678:	0f 77       	andi	r16, 0x7F	; 127
    567a:	06 ff       	sbrs	r16, 6
    567c:	0b c0       	rjmp	.+22     	; 0x5694 <vfprintf+0x5f0>
    567e:	20 2f       	mov	r18, r16
    5680:	2e 7f       	andi	r18, 0xFE	; 254
    5682:	c1 16       	cp	r12, r17
    5684:	50 f4       	brcc	.+20     	; 0x569a <vfprintf+0x5f6>
    5686:	04 ff       	sbrs	r16, 4
    5688:	0a c0       	rjmp	.+20     	; 0x569e <vfprintf+0x5fa>
    568a:	02 fd       	sbrc	r16, 2
    568c:	08 c0       	rjmp	.+16     	; 0x569e <vfprintf+0x5fa>
    568e:	20 2f       	mov	r18, r16
    5690:	2e 7e       	andi	r18, 0xEE	; 238
    5692:	05 c0       	rjmp	.+10     	; 0x569e <vfprintf+0x5fa>
    5694:	dc 2c       	mov	r13, r12
    5696:	20 2f       	mov	r18, r16
    5698:	03 c0       	rjmp	.+6      	; 0x56a0 <vfprintf+0x5fc>
    569a:	dc 2c       	mov	r13, r12
    569c:	01 c0       	rjmp	.+2      	; 0x56a0 <vfprintf+0x5fc>
    569e:	d1 2e       	mov	r13, r17
    56a0:	24 ff       	sbrs	r18, 4
    56a2:	0d c0       	rjmp	.+26     	; 0x56be <vfprintf+0x61a>
    56a4:	fe 01       	movw	r30, r28
    56a6:	ec 0d       	add	r30, r12
    56a8:	f1 1d       	adc	r31, r1
    56aa:	80 81       	ld	r24, Z
    56ac:	80 33       	cpi	r24, 0x30	; 48
    56ae:	11 f4       	brne	.+4      	; 0x56b4 <vfprintf+0x610>
    56b0:	29 7e       	andi	r18, 0xE9	; 233
    56b2:	09 c0       	rjmp	.+18     	; 0x56c6 <vfprintf+0x622>
    56b4:	22 ff       	sbrs	r18, 2
    56b6:	06 c0       	rjmp	.+12     	; 0x56c4 <vfprintf+0x620>
    56b8:	d3 94       	inc	r13
    56ba:	d3 94       	inc	r13
    56bc:	04 c0       	rjmp	.+8      	; 0x56c6 <vfprintf+0x622>
    56be:	82 2f       	mov	r24, r18
    56c0:	86 78       	andi	r24, 0x86	; 134
    56c2:	09 f0       	breq	.+2      	; 0x56c6 <vfprintf+0x622>
    56c4:	d3 94       	inc	r13
    56c6:	23 fd       	sbrc	r18, 3
    56c8:	12 c0       	rjmp	.+36     	; 0x56ee <vfprintf+0x64a>
    56ca:	20 ff       	sbrs	r18, 0
    56cc:	06 c0       	rjmp	.+12     	; 0x56da <vfprintf+0x636>
    56ce:	1c 2d       	mov	r17, r12
    56d0:	d5 14       	cp	r13, r5
    56d2:	18 f4       	brcc	.+6      	; 0x56da <vfprintf+0x636>
    56d4:	15 0d       	add	r17, r5
    56d6:	1d 19       	sub	r17, r13
    56d8:	d5 2c       	mov	r13, r5
    56da:	d5 14       	cp	r13, r5
    56dc:	60 f4       	brcc	.+24     	; 0x56f6 <vfprintf+0x652>
    56de:	b7 01       	movw	r22, r14
    56e0:	80 e2       	ldi	r24, 0x20	; 32
    56e2:	90 e0       	ldi	r25, 0x00	; 0
    56e4:	2b 8b       	std	Y+19, r18	; 0x13
    56e6:	4f d2       	rcall	.+1182   	; 0x5b86 <fputc>
    56e8:	d3 94       	inc	r13
    56ea:	2b 89       	ldd	r18, Y+19	; 0x13
    56ec:	f6 cf       	rjmp	.-20     	; 0x56da <vfprintf+0x636>
    56ee:	d5 14       	cp	r13, r5
    56f0:	10 f4       	brcc	.+4      	; 0x56f6 <vfprintf+0x652>
    56f2:	5d 18       	sub	r5, r13
    56f4:	01 c0       	rjmp	.+2      	; 0x56f8 <vfprintf+0x654>
    56f6:	51 2c       	mov	r5, r1
    56f8:	24 ff       	sbrs	r18, 4
    56fa:	11 c0       	rjmp	.+34     	; 0x571e <vfprintf+0x67a>
    56fc:	b7 01       	movw	r22, r14
    56fe:	80 e3       	ldi	r24, 0x30	; 48
    5700:	90 e0       	ldi	r25, 0x00	; 0
    5702:	2b 8b       	std	Y+19, r18	; 0x13
    5704:	40 d2       	rcall	.+1152   	; 0x5b86 <fputc>
    5706:	2b 89       	ldd	r18, Y+19	; 0x13
    5708:	22 ff       	sbrs	r18, 2
    570a:	16 c0       	rjmp	.+44     	; 0x5738 <vfprintf+0x694>
    570c:	21 ff       	sbrs	r18, 1
    570e:	03 c0       	rjmp	.+6      	; 0x5716 <vfprintf+0x672>
    5710:	88 e5       	ldi	r24, 0x58	; 88
    5712:	90 e0       	ldi	r25, 0x00	; 0
    5714:	02 c0       	rjmp	.+4      	; 0x571a <vfprintf+0x676>
    5716:	88 e7       	ldi	r24, 0x78	; 120
    5718:	90 e0       	ldi	r25, 0x00	; 0
    571a:	b7 01       	movw	r22, r14
    571c:	0c c0       	rjmp	.+24     	; 0x5736 <vfprintf+0x692>
    571e:	82 2f       	mov	r24, r18
    5720:	86 78       	andi	r24, 0x86	; 134
    5722:	51 f0       	breq	.+20     	; 0x5738 <vfprintf+0x694>
    5724:	21 fd       	sbrc	r18, 1
    5726:	02 c0       	rjmp	.+4      	; 0x572c <vfprintf+0x688>
    5728:	80 e2       	ldi	r24, 0x20	; 32
    572a:	01 c0       	rjmp	.+2      	; 0x572e <vfprintf+0x68a>
    572c:	8b e2       	ldi	r24, 0x2B	; 43
    572e:	27 fd       	sbrc	r18, 7
    5730:	8d e2       	ldi	r24, 0x2D	; 45
    5732:	b7 01       	movw	r22, r14
    5734:	90 e0       	ldi	r25, 0x00	; 0
    5736:	27 d2       	rcall	.+1102   	; 0x5b86 <fputc>
    5738:	c1 16       	cp	r12, r17
    573a:	30 f4       	brcc	.+12     	; 0x5748 <vfprintf+0x6a4>
    573c:	b7 01       	movw	r22, r14
    573e:	80 e3       	ldi	r24, 0x30	; 48
    5740:	90 e0       	ldi	r25, 0x00	; 0
    5742:	21 d2       	rcall	.+1090   	; 0x5b86 <fputc>
    5744:	11 50       	subi	r17, 0x01	; 1
    5746:	f8 cf       	rjmp	.-16     	; 0x5738 <vfprintf+0x694>
    5748:	ca 94       	dec	r12
    574a:	f4 01       	movw	r30, r8
    574c:	ec 0d       	add	r30, r12
    574e:	f1 1d       	adc	r31, r1
    5750:	80 81       	ld	r24, Z
    5752:	b7 01       	movw	r22, r14
    5754:	90 e0       	ldi	r25, 0x00	; 0
    5756:	17 d2       	rcall	.+1070   	; 0x5b86 <fputc>
    5758:	c1 10       	cpse	r12, r1
    575a:	f6 cf       	rjmp	.-20     	; 0x5748 <vfprintf+0x6a4>
    575c:	55 20       	and	r5, r5
    575e:	09 f4       	brne	.+2      	; 0x5762 <vfprintf+0x6be>
    5760:	dd cc       	rjmp	.-1606   	; 0x511c <vfprintf+0x78>
    5762:	b7 01       	movw	r22, r14
    5764:	80 e2       	ldi	r24, 0x20	; 32
    5766:	90 e0       	ldi	r25, 0x00	; 0
    5768:	0e d2       	rcall	.+1052   	; 0x5b86 <fputc>
    576a:	5a 94       	dec	r5
    576c:	f7 cf       	rjmp	.-18     	; 0x575c <vfprintf+0x6b8>
    576e:	f7 01       	movw	r30, r14
    5770:	86 81       	ldd	r24, Z+6	; 0x06
    5772:	97 81       	ldd	r25, Z+7	; 0x07
    5774:	02 c0       	rjmp	.+4      	; 0x577a <vfprintf+0x6d6>
    5776:	8f ef       	ldi	r24, 0xFF	; 255
    5778:	9f ef       	ldi	r25, 0xFF	; 255
    577a:	63 96       	adiw	r28, 0x13	; 19
    577c:	cd bf       	out	0x3d, r28	; 61
    577e:	de bf       	out	0x3e, r29	; 62
    5780:	df 91       	pop	r29
    5782:	cf 91       	pop	r28
    5784:	1f 91       	pop	r17
    5786:	0f 91       	pop	r16
    5788:	ff 90       	pop	r15
    578a:	ef 90       	pop	r14
    578c:	df 90       	pop	r13
    578e:	cf 90       	pop	r12
    5790:	bf 90       	pop	r11
    5792:	af 90       	pop	r10
    5794:	9f 90       	pop	r9
    5796:	8f 90       	pop	r8
    5798:	7f 90       	pop	r7
    579a:	6f 90       	pop	r6
    579c:	5f 90       	pop	r5
    579e:	4f 90       	pop	r4
    57a0:	3f 90       	pop	r3
    57a2:	2f 90       	pop	r2
    57a4:	08 95       	ret

000057a6 <__divmodhi4>:
    57a6:	97 fb       	bst	r25, 7
    57a8:	07 2e       	mov	r0, r23
    57aa:	16 f4       	brtc	.+4      	; 0x57b0 <__divmodhi4+0xa>
    57ac:	00 94       	com	r0
    57ae:	06 d0       	rcall	.+12     	; 0x57bc <__divmodhi4_neg1>
    57b0:	77 fd       	sbrc	r23, 7
    57b2:	08 d0       	rcall	.+16     	; 0x57c4 <__divmodhi4_neg2>
    57b4:	20 d0       	rcall	.+64     	; 0x57f6 <__udivmodhi4>
    57b6:	07 fc       	sbrc	r0, 7
    57b8:	05 d0       	rcall	.+10     	; 0x57c4 <__divmodhi4_neg2>
    57ba:	3e f4       	brtc	.+14     	; 0x57ca <__divmodhi4_exit>

000057bc <__divmodhi4_neg1>:
    57bc:	90 95       	com	r25
    57be:	81 95       	neg	r24
    57c0:	9f 4f       	sbci	r25, 0xFF	; 255
    57c2:	08 95       	ret

000057c4 <__divmodhi4_neg2>:
    57c4:	70 95       	com	r23
    57c6:	61 95       	neg	r22
    57c8:	7f 4f       	sbci	r23, 0xFF	; 255

000057ca <__divmodhi4_exit>:
    57ca:	08 95       	ret

000057cc <__tablejump2__>:
    57cc:	ee 0f       	add	r30, r30
    57ce:	ff 1f       	adc	r31, r31

000057d0 <__tablejump__>:
    57d0:	05 90       	lpm	r0, Z+
    57d2:	f4 91       	lpm	r31, Z
    57d4:	e0 2d       	mov	r30, r0
    57d6:	19 94       	eijmp

000057d8 <__umulhisi3>:
    57d8:	a2 9f       	mul	r26, r18
    57da:	b0 01       	movw	r22, r0
    57dc:	b3 9f       	mul	r27, r19
    57de:	c0 01       	movw	r24, r0
    57e0:	a3 9f       	mul	r26, r19
    57e2:	70 0d       	add	r23, r0
    57e4:	81 1d       	adc	r24, r1
    57e6:	11 24       	eor	r1, r1
    57e8:	91 1d       	adc	r25, r1
    57ea:	b2 9f       	mul	r27, r18
    57ec:	70 0d       	add	r23, r0
    57ee:	81 1d       	adc	r24, r1
    57f0:	11 24       	eor	r1, r1
    57f2:	91 1d       	adc	r25, r1
    57f4:	08 95       	ret

000057f6 <__udivmodhi4>:
    57f6:	aa 1b       	sub	r26, r26
    57f8:	bb 1b       	sub	r27, r27
    57fa:	51 e1       	ldi	r21, 0x11	; 17
    57fc:	07 c0       	rjmp	.+14     	; 0x580c <__udivmodhi4_ep>

000057fe <__udivmodhi4_loop>:
    57fe:	aa 1f       	adc	r26, r26
    5800:	bb 1f       	adc	r27, r27
    5802:	a6 17       	cp	r26, r22
    5804:	b7 07       	cpc	r27, r23
    5806:	10 f0       	brcs	.+4      	; 0x580c <__udivmodhi4_ep>
    5808:	a6 1b       	sub	r26, r22
    580a:	b7 0b       	sbc	r27, r23

0000580c <__udivmodhi4_ep>:
    580c:	88 1f       	adc	r24, r24
    580e:	99 1f       	adc	r25, r25
    5810:	5a 95       	dec	r21
    5812:	a9 f7       	brne	.-22     	; 0x57fe <__udivmodhi4_loop>
    5814:	80 95       	com	r24
    5816:	90 95       	com	r25
    5818:	bc 01       	movw	r22, r24
    581a:	cd 01       	movw	r24, r26
    581c:	08 95       	ret

0000581e <do_rand>:
    581e:	8f 92       	push	r8
    5820:	9f 92       	push	r9
    5822:	af 92       	push	r10
    5824:	bf 92       	push	r11
    5826:	cf 92       	push	r12
    5828:	df 92       	push	r13
    582a:	ef 92       	push	r14
    582c:	ff 92       	push	r15
    582e:	cf 93       	push	r28
    5830:	df 93       	push	r29
    5832:	ec 01       	movw	r28, r24
    5834:	68 81       	ld	r22, Y
    5836:	79 81       	ldd	r23, Y+1	; 0x01
    5838:	8a 81       	ldd	r24, Y+2	; 0x02
    583a:	9b 81       	ldd	r25, Y+3	; 0x03
    583c:	61 15       	cp	r22, r1
    583e:	71 05       	cpc	r23, r1
    5840:	81 05       	cpc	r24, r1
    5842:	91 05       	cpc	r25, r1
    5844:	21 f4       	brne	.+8      	; 0x584e <do_rand+0x30>
    5846:	64 e2       	ldi	r22, 0x24	; 36
    5848:	79 ed       	ldi	r23, 0xD9	; 217
    584a:	8b e5       	ldi	r24, 0x5B	; 91
    584c:	97 e0       	ldi	r25, 0x07	; 7
    584e:	2d e1       	ldi	r18, 0x1D	; 29
    5850:	33 ef       	ldi	r19, 0xF3	; 243
    5852:	41 e0       	ldi	r20, 0x01	; 1
    5854:	50 e0       	ldi	r21, 0x00	; 0
    5856:	5f d2       	rcall	.+1214   	; 0x5d16 <__divmodsi4>
    5858:	49 01       	movw	r8, r18
    585a:	5a 01       	movw	r10, r20
    585c:	9b 01       	movw	r18, r22
    585e:	ac 01       	movw	r20, r24
    5860:	a7 ea       	ldi	r26, 0xA7	; 167
    5862:	b1 e4       	ldi	r27, 0x41	; 65
    5864:	74 d2       	rcall	.+1256   	; 0x5d4e <__muluhisi3>
    5866:	6b 01       	movw	r12, r22
    5868:	7c 01       	movw	r14, r24
    586a:	ac ee       	ldi	r26, 0xEC	; 236
    586c:	b4 ef       	ldi	r27, 0xF4	; 244
    586e:	a5 01       	movw	r20, r10
    5870:	94 01       	movw	r18, r8
    5872:	79 d2       	rcall	.+1266   	; 0x5d66 <__mulohisi3>
    5874:	c6 0e       	add	r12, r22
    5876:	d7 1e       	adc	r13, r23
    5878:	e8 1e       	adc	r14, r24
    587a:	f9 1e       	adc	r15, r25
    587c:	f7 fe       	sbrs	r15, 7
    587e:	06 c0       	rjmp	.+12     	; 0x588c <do_rand+0x6e>
    5880:	81 e0       	ldi	r24, 0x01	; 1
    5882:	c8 1a       	sub	r12, r24
    5884:	d1 08       	sbc	r13, r1
    5886:	e1 08       	sbc	r14, r1
    5888:	80 e8       	ldi	r24, 0x80	; 128
    588a:	f8 0a       	sbc	r15, r24
    588c:	c8 82       	st	Y, r12
    588e:	d9 82       	std	Y+1, r13	; 0x01
    5890:	ea 82       	std	Y+2, r14	; 0x02
    5892:	fb 82       	std	Y+3, r15	; 0x03
    5894:	c6 01       	movw	r24, r12
    5896:	9f 77       	andi	r25, 0x7F	; 127
    5898:	df 91       	pop	r29
    589a:	cf 91       	pop	r28
    589c:	ff 90       	pop	r15
    589e:	ef 90       	pop	r14
    58a0:	df 90       	pop	r13
    58a2:	cf 90       	pop	r12
    58a4:	bf 90       	pop	r11
    58a6:	af 90       	pop	r10
    58a8:	9f 90       	pop	r9
    58aa:	8f 90       	pop	r8
    58ac:	08 95       	ret

000058ae <rand_r>:
    58ae:	b7 cf       	rjmp	.-146    	; 0x581e <do_rand>

000058b0 <rand>:
    58b0:	80 e0       	ldi	r24, 0x00	; 0
    58b2:	90 e2       	ldi	r25, 0x20	; 32
    58b4:	b4 cf       	rjmp	.-152    	; 0x581e <do_rand>

000058b6 <srand>:
    58b6:	a0 e0       	ldi	r26, 0x00	; 0
    58b8:	b0 e0       	ldi	r27, 0x00	; 0
    58ba:	80 93 00 20 	sts	0x2000, r24
    58be:	90 93 01 20 	sts	0x2001, r25
    58c2:	a0 93 02 20 	sts	0x2002, r26
    58c6:	b0 93 03 20 	sts	0x2003, r27
    58ca:	08 95       	ret

000058cc <__ftoa_engine>:
    58cc:	28 30       	cpi	r18, 0x08	; 8
    58ce:	08 f0       	brcs	.+2      	; 0x58d2 <__ftoa_engine+0x6>
    58d0:	27 e0       	ldi	r18, 0x07	; 7
    58d2:	33 27       	eor	r19, r19
    58d4:	da 01       	movw	r26, r20
    58d6:	99 0f       	add	r25, r25
    58d8:	31 1d       	adc	r19, r1
    58da:	87 fd       	sbrc	r24, 7
    58dc:	91 60       	ori	r25, 0x01	; 1
    58de:	00 96       	adiw	r24, 0x00	; 0
    58e0:	61 05       	cpc	r22, r1
    58e2:	71 05       	cpc	r23, r1
    58e4:	39 f4       	brne	.+14     	; 0x58f4 <__ftoa_engine+0x28>
    58e6:	32 60       	ori	r19, 0x02	; 2
    58e8:	2e 5f       	subi	r18, 0xFE	; 254
    58ea:	3d 93       	st	X+, r19
    58ec:	30 e3       	ldi	r19, 0x30	; 48
    58ee:	2a 95       	dec	r18
    58f0:	e1 f7       	brne	.-8      	; 0x58ea <__ftoa_engine+0x1e>
    58f2:	08 95       	ret
    58f4:	9f 3f       	cpi	r25, 0xFF	; 255
    58f6:	30 f0       	brcs	.+12     	; 0x5904 <__ftoa_engine+0x38>
    58f8:	80 38       	cpi	r24, 0x80	; 128
    58fa:	71 05       	cpc	r23, r1
    58fc:	61 05       	cpc	r22, r1
    58fe:	09 f0       	breq	.+2      	; 0x5902 <__ftoa_engine+0x36>
    5900:	3c 5f       	subi	r19, 0xFC	; 252
    5902:	3c 5f       	subi	r19, 0xFC	; 252
    5904:	3d 93       	st	X+, r19
    5906:	91 30       	cpi	r25, 0x01	; 1
    5908:	08 f0       	brcs	.+2      	; 0x590c <__ftoa_engine+0x40>
    590a:	80 68       	ori	r24, 0x80	; 128
    590c:	91 1d       	adc	r25, r1
    590e:	df 93       	push	r29
    5910:	cf 93       	push	r28
    5912:	1f 93       	push	r17
    5914:	0f 93       	push	r16
    5916:	ff 92       	push	r15
    5918:	ef 92       	push	r14
    591a:	19 2f       	mov	r17, r25
    591c:	98 7f       	andi	r25, 0xF8	; 248
    591e:	96 95       	lsr	r25
    5920:	e9 2f       	mov	r30, r25
    5922:	96 95       	lsr	r25
    5924:	96 95       	lsr	r25
    5926:	e9 0f       	add	r30, r25
    5928:	ff 27       	eor	r31, r31
    592a:	e4 59       	subi	r30, 0x94	; 148
    592c:	f9 4f       	sbci	r31, 0xF9	; 249
    592e:	99 27       	eor	r25, r25
    5930:	33 27       	eor	r19, r19
    5932:	ee 24       	eor	r14, r14
    5934:	ff 24       	eor	r15, r15
    5936:	a7 01       	movw	r20, r14
    5938:	e7 01       	movw	r28, r14
    593a:	05 90       	lpm	r0, Z+
    593c:	08 94       	sec
    593e:	07 94       	ror	r0
    5940:	28 f4       	brcc	.+10     	; 0x594c <__ftoa_engine+0x80>
    5942:	36 0f       	add	r19, r22
    5944:	e7 1e       	adc	r14, r23
    5946:	f8 1e       	adc	r15, r24
    5948:	49 1f       	adc	r20, r25
    594a:	51 1d       	adc	r21, r1
    594c:	66 0f       	add	r22, r22
    594e:	77 1f       	adc	r23, r23
    5950:	88 1f       	adc	r24, r24
    5952:	99 1f       	adc	r25, r25
    5954:	06 94       	lsr	r0
    5956:	a1 f7       	brne	.-24     	; 0x5940 <__ftoa_engine+0x74>
    5958:	05 90       	lpm	r0, Z+
    595a:	07 94       	ror	r0
    595c:	28 f4       	brcc	.+10     	; 0x5968 <__ftoa_engine+0x9c>
    595e:	e7 0e       	add	r14, r23
    5960:	f8 1e       	adc	r15, r24
    5962:	49 1f       	adc	r20, r25
    5964:	56 1f       	adc	r21, r22
    5966:	c1 1d       	adc	r28, r1
    5968:	77 0f       	add	r23, r23
    596a:	88 1f       	adc	r24, r24
    596c:	99 1f       	adc	r25, r25
    596e:	66 1f       	adc	r22, r22
    5970:	06 94       	lsr	r0
    5972:	a1 f7       	brne	.-24     	; 0x595c <__ftoa_engine+0x90>
    5974:	05 90       	lpm	r0, Z+
    5976:	07 94       	ror	r0
    5978:	28 f4       	brcc	.+10     	; 0x5984 <__ftoa_engine+0xb8>
    597a:	f8 0e       	add	r15, r24
    597c:	49 1f       	adc	r20, r25
    597e:	56 1f       	adc	r21, r22
    5980:	c7 1f       	adc	r28, r23
    5982:	d1 1d       	adc	r29, r1
    5984:	88 0f       	add	r24, r24
    5986:	99 1f       	adc	r25, r25
    5988:	66 1f       	adc	r22, r22
    598a:	77 1f       	adc	r23, r23
    598c:	06 94       	lsr	r0
    598e:	a1 f7       	brne	.-24     	; 0x5978 <__ftoa_engine+0xac>
    5990:	05 90       	lpm	r0, Z+
    5992:	07 94       	ror	r0
    5994:	20 f4       	brcc	.+8      	; 0x599e <__ftoa_engine+0xd2>
    5996:	49 0f       	add	r20, r25
    5998:	56 1f       	adc	r21, r22
    599a:	c7 1f       	adc	r28, r23
    599c:	d8 1f       	adc	r29, r24
    599e:	99 0f       	add	r25, r25
    59a0:	66 1f       	adc	r22, r22
    59a2:	77 1f       	adc	r23, r23
    59a4:	88 1f       	adc	r24, r24
    59a6:	06 94       	lsr	r0
    59a8:	a9 f7       	brne	.-22     	; 0x5994 <__ftoa_engine+0xc8>
    59aa:	84 91       	lpm	r24, Z
    59ac:	10 95       	com	r17
    59ae:	17 70       	andi	r17, 0x07	; 7
    59b0:	41 f0       	breq	.+16     	; 0x59c2 <__ftoa_engine+0xf6>
    59b2:	d6 95       	lsr	r29
    59b4:	c7 95       	ror	r28
    59b6:	57 95       	ror	r21
    59b8:	47 95       	ror	r20
    59ba:	f7 94       	ror	r15
    59bc:	e7 94       	ror	r14
    59be:	1a 95       	dec	r17
    59c0:	c1 f7       	brne	.-16     	; 0x59b2 <__ftoa_engine+0xe6>
    59c2:	e2 e1       	ldi	r30, 0x12	; 18
    59c4:	f6 e0       	ldi	r31, 0x06	; 6
    59c6:	68 94       	set
    59c8:	15 90       	lpm	r1, Z+
    59ca:	15 91       	lpm	r17, Z+
    59cc:	35 91       	lpm	r19, Z+
    59ce:	65 91       	lpm	r22, Z+
    59d0:	95 91       	lpm	r25, Z+
    59d2:	05 90       	lpm	r0, Z+
    59d4:	7f e2       	ldi	r23, 0x2F	; 47
    59d6:	73 95       	inc	r23
    59d8:	e1 18       	sub	r14, r1
    59da:	f1 0a       	sbc	r15, r17
    59dc:	43 0b       	sbc	r20, r19
    59de:	56 0b       	sbc	r21, r22
    59e0:	c9 0b       	sbc	r28, r25
    59e2:	d0 09       	sbc	r29, r0
    59e4:	c0 f7       	brcc	.-16     	; 0x59d6 <__ftoa_engine+0x10a>
    59e6:	e1 0c       	add	r14, r1
    59e8:	f1 1e       	adc	r15, r17
    59ea:	43 1f       	adc	r20, r19
    59ec:	56 1f       	adc	r21, r22
    59ee:	c9 1f       	adc	r28, r25
    59f0:	d0 1d       	adc	r29, r0
    59f2:	7e f4       	brtc	.+30     	; 0x5a12 <__ftoa_engine+0x146>
    59f4:	70 33       	cpi	r23, 0x30	; 48
    59f6:	11 f4       	brne	.+4      	; 0x59fc <__ftoa_engine+0x130>
    59f8:	8a 95       	dec	r24
    59fa:	e6 cf       	rjmp	.-52     	; 0x59c8 <__ftoa_engine+0xfc>
    59fc:	e8 94       	clt
    59fe:	01 50       	subi	r16, 0x01	; 1
    5a00:	30 f0       	brcs	.+12     	; 0x5a0e <__ftoa_engine+0x142>
    5a02:	08 0f       	add	r16, r24
    5a04:	0a f4       	brpl	.+2      	; 0x5a08 <__ftoa_engine+0x13c>
    5a06:	00 27       	eor	r16, r16
    5a08:	02 17       	cp	r16, r18
    5a0a:	08 f4       	brcc	.+2      	; 0x5a0e <__ftoa_engine+0x142>
    5a0c:	20 2f       	mov	r18, r16
    5a0e:	23 95       	inc	r18
    5a10:	02 2f       	mov	r16, r18
    5a12:	7a 33       	cpi	r23, 0x3A	; 58
    5a14:	28 f0       	brcs	.+10     	; 0x5a20 <__ftoa_engine+0x154>
    5a16:	79 e3       	ldi	r23, 0x39	; 57
    5a18:	7d 93       	st	X+, r23
    5a1a:	2a 95       	dec	r18
    5a1c:	e9 f7       	brne	.-6      	; 0x5a18 <__ftoa_engine+0x14c>
    5a1e:	10 c0       	rjmp	.+32     	; 0x5a40 <__ftoa_engine+0x174>
    5a20:	7d 93       	st	X+, r23
    5a22:	2a 95       	dec	r18
    5a24:	89 f6       	brne	.-94     	; 0x59c8 <__ftoa_engine+0xfc>
    5a26:	06 94       	lsr	r0
    5a28:	97 95       	ror	r25
    5a2a:	67 95       	ror	r22
    5a2c:	37 95       	ror	r19
    5a2e:	17 95       	ror	r17
    5a30:	17 94       	ror	r1
    5a32:	e1 18       	sub	r14, r1
    5a34:	f1 0a       	sbc	r15, r17
    5a36:	43 0b       	sbc	r20, r19
    5a38:	56 0b       	sbc	r21, r22
    5a3a:	c9 0b       	sbc	r28, r25
    5a3c:	d0 09       	sbc	r29, r0
    5a3e:	98 f0       	brcs	.+38     	; 0x5a66 <__ftoa_engine+0x19a>
    5a40:	23 95       	inc	r18
    5a42:	7e 91       	ld	r23, -X
    5a44:	73 95       	inc	r23
    5a46:	7a 33       	cpi	r23, 0x3A	; 58
    5a48:	08 f0       	brcs	.+2      	; 0x5a4c <__ftoa_engine+0x180>
    5a4a:	70 e3       	ldi	r23, 0x30	; 48
    5a4c:	7c 93       	st	X, r23
    5a4e:	20 13       	cpse	r18, r16
    5a50:	b8 f7       	brcc	.-18     	; 0x5a40 <__ftoa_engine+0x174>
    5a52:	7e 91       	ld	r23, -X
    5a54:	70 61       	ori	r23, 0x10	; 16
    5a56:	7d 93       	st	X+, r23
    5a58:	30 f0       	brcs	.+12     	; 0x5a66 <__ftoa_engine+0x19a>
    5a5a:	83 95       	inc	r24
    5a5c:	71 e3       	ldi	r23, 0x31	; 49
    5a5e:	7d 93       	st	X+, r23
    5a60:	70 e3       	ldi	r23, 0x30	; 48
    5a62:	2a 95       	dec	r18
    5a64:	e1 f7       	brne	.-8      	; 0x5a5e <__ftoa_engine+0x192>
    5a66:	11 24       	eor	r1, r1
    5a68:	ef 90       	pop	r14
    5a6a:	ff 90       	pop	r15
    5a6c:	0f 91       	pop	r16
    5a6e:	1f 91       	pop	r17
    5a70:	cf 91       	pop	r28
    5a72:	df 91       	pop	r29
    5a74:	99 27       	eor	r25, r25
    5a76:	87 fd       	sbrc	r24, 7
    5a78:	90 95       	com	r25
    5a7a:	08 95       	ret

00005a7c <strnlen_P>:
    5a7c:	fc 01       	movw	r30, r24
    5a7e:	05 90       	lpm	r0, Z+
    5a80:	61 50       	subi	r22, 0x01	; 1
    5a82:	70 40       	sbci	r23, 0x00	; 0
    5a84:	01 10       	cpse	r0, r1
    5a86:	d8 f7       	brcc	.-10     	; 0x5a7e <strnlen_P+0x2>
    5a88:	80 95       	com	r24
    5a8a:	90 95       	com	r25
    5a8c:	8e 0f       	add	r24, r30
    5a8e:	9f 1f       	adc	r25, r31
    5a90:	08 95       	ret

00005a92 <memcmp>:
    5a92:	fb 01       	movw	r30, r22
    5a94:	dc 01       	movw	r26, r24
    5a96:	04 c0       	rjmp	.+8      	; 0x5aa0 <memcmp+0xe>
    5a98:	8d 91       	ld	r24, X+
    5a9a:	01 90       	ld	r0, Z+
    5a9c:	80 19       	sub	r24, r0
    5a9e:	21 f4       	brne	.+8      	; 0x5aa8 <memcmp+0x16>
    5aa0:	41 50       	subi	r20, 0x01	; 1
    5aa2:	50 40       	sbci	r21, 0x00	; 0
    5aa4:	c8 f7       	brcc	.-14     	; 0x5a98 <memcmp+0x6>
    5aa6:	88 1b       	sub	r24, r24
    5aa8:	99 0b       	sbc	r25, r25
    5aaa:	08 95       	ret

00005aac <memcpy>:
    5aac:	fb 01       	movw	r30, r22
    5aae:	dc 01       	movw	r26, r24
    5ab0:	02 c0       	rjmp	.+4      	; 0x5ab6 <memcpy+0xa>
    5ab2:	01 90       	ld	r0, Z+
    5ab4:	0d 92       	st	X+, r0
    5ab6:	41 50       	subi	r20, 0x01	; 1
    5ab8:	50 40       	sbci	r21, 0x00	; 0
    5aba:	d8 f7       	brcc	.-10     	; 0x5ab2 <memcpy+0x6>
    5abc:	08 95       	ret

00005abe <memset>:
    5abe:	dc 01       	movw	r26, r24
    5ac0:	01 c0       	rjmp	.+2      	; 0x5ac4 <memset+0x6>
    5ac2:	6d 93       	st	X+, r22
    5ac4:	41 50       	subi	r20, 0x01	; 1
    5ac6:	50 40       	sbci	r21, 0x00	; 0
    5ac8:	e0 f7       	brcc	.-8      	; 0x5ac2 <memset+0x4>
    5aca:	08 95       	ret

00005acc <strcat>:
    5acc:	fb 01       	movw	r30, r22
    5ace:	dc 01       	movw	r26, r24
    5ad0:	0d 90       	ld	r0, X+
    5ad2:	00 20       	and	r0, r0
    5ad4:	e9 f7       	brne	.-6      	; 0x5ad0 <strcat+0x4>
    5ad6:	11 97       	sbiw	r26, 0x01	; 1
    5ad8:	01 90       	ld	r0, Z+
    5ada:	0d 92       	st	X+, r0
    5adc:	00 20       	and	r0, r0
    5ade:	e1 f7       	brne	.-8      	; 0x5ad8 <strcat+0xc>
    5ae0:	08 95       	ret

00005ae2 <strcpy>:
    5ae2:	fb 01       	movw	r30, r22
    5ae4:	dc 01       	movw	r26, r24
    5ae6:	01 90       	ld	r0, Z+
    5ae8:	0d 92       	st	X+, r0
    5aea:	00 20       	and	r0, r0
    5aec:	e1 f7       	brne	.-8      	; 0x5ae6 <strcpy+0x4>
    5aee:	08 95       	ret

00005af0 <strncmp>:
    5af0:	fb 01       	movw	r30, r22
    5af2:	dc 01       	movw	r26, r24
    5af4:	41 50       	subi	r20, 0x01	; 1
    5af6:	50 40       	sbci	r21, 0x00	; 0
    5af8:	30 f0       	brcs	.+12     	; 0x5b06 <strncmp+0x16>
    5afa:	8d 91       	ld	r24, X+
    5afc:	01 90       	ld	r0, Z+
    5afe:	80 19       	sub	r24, r0
    5b00:	19 f4       	brne	.+6      	; 0x5b08 <strncmp+0x18>
    5b02:	00 20       	and	r0, r0
    5b04:	b9 f7       	brne	.-18     	; 0x5af4 <strncmp+0x4>
    5b06:	88 1b       	sub	r24, r24
    5b08:	99 0b       	sbc	r25, r25
    5b0a:	08 95       	ret

00005b0c <strncpy>:
    5b0c:	fb 01       	movw	r30, r22
    5b0e:	dc 01       	movw	r26, r24
    5b10:	41 50       	subi	r20, 0x01	; 1
    5b12:	50 40       	sbci	r21, 0x00	; 0
    5b14:	48 f0       	brcs	.+18     	; 0x5b28 <strncpy+0x1c>
    5b16:	01 90       	ld	r0, Z+
    5b18:	0d 92       	st	X+, r0
    5b1a:	00 20       	and	r0, r0
    5b1c:	c9 f7       	brne	.-14     	; 0x5b10 <strncpy+0x4>
    5b1e:	01 c0       	rjmp	.+2      	; 0x5b22 <strncpy+0x16>
    5b20:	1d 92       	st	X+, r1
    5b22:	41 50       	subi	r20, 0x01	; 1
    5b24:	50 40       	sbci	r21, 0x00	; 0
    5b26:	e0 f7       	brcc	.-8      	; 0x5b20 <strncpy+0x14>
    5b28:	08 95       	ret

00005b2a <strnlen>:
    5b2a:	fc 01       	movw	r30, r24
    5b2c:	61 50       	subi	r22, 0x01	; 1
    5b2e:	70 40       	sbci	r23, 0x00	; 0
    5b30:	01 90       	ld	r0, Z+
    5b32:	01 10       	cpse	r0, r1
    5b34:	d8 f7       	brcc	.-10     	; 0x5b2c <strnlen+0x2>
    5b36:	80 95       	com	r24
    5b38:	90 95       	com	r25
    5b3a:	8e 0f       	add	r24, r30
    5b3c:	9f 1f       	adc	r25, r31
    5b3e:	08 95       	ret

00005b40 <__itoa_ncheck>:
    5b40:	bb 27       	eor	r27, r27
    5b42:	4a 30       	cpi	r20, 0x0A	; 10
    5b44:	31 f4       	brne	.+12     	; 0x5b52 <__itoa_ncheck+0x12>
    5b46:	99 23       	and	r25, r25
    5b48:	22 f4       	brpl	.+8      	; 0x5b52 <__itoa_ncheck+0x12>
    5b4a:	bd e2       	ldi	r27, 0x2D	; 45
    5b4c:	90 95       	com	r25
    5b4e:	81 95       	neg	r24
    5b50:	9f 4f       	sbci	r25, 0xFF	; 255
    5b52:	01 c0       	rjmp	.+2      	; 0x5b56 <__utoa_common>

00005b54 <__utoa_ncheck>:
    5b54:	bb 27       	eor	r27, r27

00005b56 <__utoa_common>:
    5b56:	fb 01       	movw	r30, r22
    5b58:	55 27       	eor	r21, r21
    5b5a:	aa 27       	eor	r26, r26
    5b5c:	88 0f       	add	r24, r24
    5b5e:	99 1f       	adc	r25, r25
    5b60:	aa 1f       	adc	r26, r26
    5b62:	a4 17       	cp	r26, r20
    5b64:	10 f0       	brcs	.+4      	; 0x5b6a <__utoa_common+0x14>
    5b66:	a4 1b       	sub	r26, r20
    5b68:	83 95       	inc	r24
    5b6a:	50 51       	subi	r21, 0x10	; 16
    5b6c:	b9 f7       	brne	.-18     	; 0x5b5c <__utoa_common+0x6>
    5b6e:	a0 5d       	subi	r26, 0xD0	; 208
    5b70:	aa 33       	cpi	r26, 0x3A	; 58
    5b72:	08 f0       	brcs	.+2      	; 0x5b76 <__utoa_common+0x20>
    5b74:	a9 5d       	subi	r26, 0xD9	; 217
    5b76:	a1 93       	st	Z+, r26
    5b78:	00 97       	sbiw	r24, 0x00	; 0
    5b7a:	79 f7       	brne	.-34     	; 0x5b5a <__utoa_common+0x4>
    5b7c:	b1 11       	cpse	r27, r1
    5b7e:	b1 93       	st	Z+, r27
    5b80:	11 92       	st	Z+, r1
    5b82:	cb 01       	movw	r24, r22
    5b84:	b8 c0       	rjmp	.+368    	; 0x5cf6 <strrev>

00005b86 <fputc>:
    5b86:	0f 93       	push	r16
    5b88:	1f 93       	push	r17
    5b8a:	cf 93       	push	r28
    5b8c:	df 93       	push	r29
    5b8e:	18 2f       	mov	r17, r24
    5b90:	09 2f       	mov	r16, r25
    5b92:	eb 01       	movw	r28, r22
    5b94:	8b 81       	ldd	r24, Y+3	; 0x03
    5b96:	81 fd       	sbrc	r24, 1
    5b98:	03 c0       	rjmp	.+6      	; 0x5ba0 <fputc+0x1a>
    5b9a:	8f ef       	ldi	r24, 0xFF	; 255
    5b9c:	9f ef       	ldi	r25, 0xFF	; 255
    5b9e:	20 c0       	rjmp	.+64     	; 0x5be0 <fputc+0x5a>
    5ba0:	82 ff       	sbrs	r24, 2
    5ba2:	10 c0       	rjmp	.+32     	; 0x5bc4 <fputc+0x3e>
    5ba4:	4e 81       	ldd	r20, Y+6	; 0x06
    5ba6:	5f 81       	ldd	r21, Y+7	; 0x07
    5ba8:	2c 81       	ldd	r18, Y+4	; 0x04
    5baa:	3d 81       	ldd	r19, Y+5	; 0x05
    5bac:	42 17       	cp	r20, r18
    5bae:	53 07       	cpc	r21, r19
    5bb0:	7c f4       	brge	.+30     	; 0x5bd0 <fputc+0x4a>
    5bb2:	e8 81       	ld	r30, Y
    5bb4:	f9 81       	ldd	r31, Y+1	; 0x01
    5bb6:	9f 01       	movw	r18, r30
    5bb8:	2f 5f       	subi	r18, 0xFF	; 255
    5bba:	3f 4f       	sbci	r19, 0xFF	; 255
    5bbc:	28 83       	st	Y, r18
    5bbe:	39 83       	std	Y+1, r19	; 0x01
    5bc0:	10 83       	st	Z, r17
    5bc2:	06 c0       	rjmp	.+12     	; 0x5bd0 <fputc+0x4a>
    5bc4:	e8 85       	ldd	r30, Y+8	; 0x08
    5bc6:	f9 85       	ldd	r31, Y+9	; 0x09
    5bc8:	81 2f       	mov	r24, r17
    5bca:	19 95       	eicall
    5bcc:	89 2b       	or	r24, r25
    5bce:	29 f7       	brne	.-54     	; 0x5b9a <fputc+0x14>
    5bd0:	2e 81       	ldd	r18, Y+6	; 0x06
    5bd2:	3f 81       	ldd	r19, Y+7	; 0x07
    5bd4:	2f 5f       	subi	r18, 0xFF	; 255
    5bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    5bd8:	2e 83       	std	Y+6, r18	; 0x06
    5bda:	3f 83       	std	Y+7, r19	; 0x07
    5bdc:	81 2f       	mov	r24, r17
    5bde:	90 2f       	mov	r25, r16
    5be0:	df 91       	pop	r29
    5be2:	cf 91       	pop	r28
    5be4:	1f 91       	pop	r17
    5be6:	0f 91       	pop	r16
    5be8:	08 95       	ret

00005bea <sprintf>:
    5bea:	0f 93       	push	r16
    5bec:	1f 93       	push	r17
    5bee:	cf 93       	push	r28
    5bf0:	df 93       	push	r29
    5bf2:	cd b7       	in	r28, 0x3d	; 61
    5bf4:	de b7       	in	r29, 0x3e	; 62
    5bf6:	2e 97       	sbiw	r28, 0x0e	; 14
    5bf8:	cd bf       	out	0x3d, r28	; 61
    5bfa:	de bf       	out	0x3e, r29	; 62
    5bfc:	0e 89       	ldd	r16, Y+22	; 0x16
    5bfe:	1f 89       	ldd	r17, Y+23	; 0x17
    5c00:	86 e0       	ldi	r24, 0x06	; 6
    5c02:	8c 83       	std	Y+4, r24	; 0x04
    5c04:	09 83       	std	Y+1, r16	; 0x01
    5c06:	1a 83       	std	Y+2, r17	; 0x02
    5c08:	8f ef       	ldi	r24, 0xFF	; 255
    5c0a:	9f e7       	ldi	r25, 0x7F	; 127
    5c0c:	8d 83       	std	Y+5, r24	; 0x05
    5c0e:	9e 83       	std	Y+6, r25	; 0x06
    5c10:	ae 01       	movw	r20, r28
    5c12:	46 5e       	subi	r20, 0xE6	; 230
    5c14:	5f 4f       	sbci	r21, 0xFF	; 255
    5c16:	68 8d       	ldd	r22, Y+24	; 0x18
    5c18:	79 8d       	ldd	r23, Y+25	; 0x19
    5c1a:	ce 01       	movw	r24, r28
    5c1c:	01 96       	adiw	r24, 0x01	; 1
    5c1e:	42 da       	rcall	.-2940   	; 0x50a4 <vfprintf>
    5c20:	ef 81       	ldd	r30, Y+7	; 0x07
    5c22:	f8 85       	ldd	r31, Y+8	; 0x08
    5c24:	e0 0f       	add	r30, r16
    5c26:	f1 1f       	adc	r31, r17
    5c28:	10 82       	st	Z, r1
    5c2a:	2e 96       	adiw	r28, 0x0e	; 14
    5c2c:	cd bf       	out	0x3d, r28	; 61
    5c2e:	de bf       	out	0x3e, r29	; 62
    5c30:	df 91       	pop	r29
    5c32:	cf 91       	pop	r28
    5c34:	1f 91       	pop	r17
    5c36:	0f 91       	pop	r16
    5c38:	08 95       	ret

00005c3a <__ultoa_invert>:
    5c3a:	fa 01       	movw	r30, r20
    5c3c:	aa 27       	eor	r26, r26
    5c3e:	28 30       	cpi	r18, 0x08	; 8
    5c40:	51 f1       	breq	.+84     	; 0x5c96 <__ultoa_invert+0x5c>
    5c42:	20 31       	cpi	r18, 0x10	; 16
    5c44:	81 f1       	breq	.+96     	; 0x5ca6 <__ultoa_invert+0x6c>
    5c46:	e8 94       	clt
    5c48:	6f 93       	push	r22
    5c4a:	6e 7f       	andi	r22, 0xFE	; 254
    5c4c:	6e 5f       	subi	r22, 0xFE	; 254
    5c4e:	7f 4f       	sbci	r23, 0xFF	; 255
    5c50:	8f 4f       	sbci	r24, 0xFF	; 255
    5c52:	9f 4f       	sbci	r25, 0xFF	; 255
    5c54:	af 4f       	sbci	r26, 0xFF	; 255
    5c56:	b1 e0       	ldi	r27, 0x01	; 1
    5c58:	3e d0       	rcall	.+124    	; 0x5cd6 <__ultoa_invert+0x9c>
    5c5a:	b4 e0       	ldi	r27, 0x04	; 4
    5c5c:	3c d0       	rcall	.+120    	; 0x5cd6 <__ultoa_invert+0x9c>
    5c5e:	67 0f       	add	r22, r23
    5c60:	78 1f       	adc	r23, r24
    5c62:	89 1f       	adc	r24, r25
    5c64:	9a 1f       	adc	r25, r26
    5c66:	a1 1d       	adc	r26, r1
    5c68:	68 0f       	add	r22, r24
    5c6a:	79 1f       	adc	r23, r25
    5c6c:	8a 1f       	adc	r24, r26
    5c6e:	91 1d       	adc	r25, r1
    5c70:	a1 1d       	adc	r26, r1
    5c72:	6a 0f       	add	r22, r26
    5c74:	71 1d       	adc	r23, r1
    5c76:	81 1d       	adc	r24, r1
    5c78:	91 1d       	adc	r25, r1
    5c7a:	a1 1d       	adc	r26, r1
    5c7c:	20 d0       	rcall	.+64     	; 0x5cbe <__ultoa_invert+0x84>
    5c7e:	09 f4       	brne	.+2      	; 0x5c82 <__ultoa_invert+0x48>
    5c80:	68 94       	set
    5c82:	3f 91       	pop	r19
    5c84:	2a e0       	ldi	r18, 0x0A	; 10
    5c86:	26 9f       	mul	r18, r22
    5c88:	11 24       	eor	r1, r1
    5c8a:	30 19       	sub	r19, r0
    5c8c:	30 5d       	subi	r19, 0xD0	; 208
    5c8e:	31 93       	st	Z+, r19
    5c90:	de f6       	brtc	.-74     	; 0x5c48 <__ultoa_invert+0xe>
    5c92:	cf 01       	movw	r24, r30
    5c94:	08 95       	ret
    5c96:	46 2f       	mov	r20, r22
    5c98:	47 70       	andi	r20, 0x07	; 7
    5c9a:	40 5d       	subi	r20, 0xD0	; 208
    5c9c:	41 93       	st	Z+, r20
    5c9e:	b3 e0       	ldi	r27, 0x03	; 3
    5ca0:	0f d0       	rcall	.+30     	; 0x5cc0 <__ultoa_invert+0x86>
    5ca2:	c9 f7       	brne	.-14     	; 0x5c96 <__ultoa_invert+0x5c>
    5ca4:	f6 cf       	rjmp	.-20     	; 0x5c92 <__ultoa_invert+0x58>
    5ca6:	46 2f       	mov	r20, r22
    5ca8:	4f 70       	andi	r20, 0x0F	; 15
    5caa:	40 5d       	subi	r20, 0xD0	; 208
    5cac:	4a 33       	cpi	r20, 0x3A	; 58
    5cae:	18 f0       	brcs	.+6      	; 0x5cb6 <__ultoa_invert+0x7c>
    5cb0:	49 5d       	subi	r20, 0xD9	; 217
    5cb2:	31 fd       	sbrc	r19, 1
    5cb4:	40 52       	subi	r20, 0x20	; 32
    5cb6:	41 93       	st	Z+, r20
    5cb8:	02 d0       	rcall	.+4      	; 0x5cbe <__ultoa_invert+0x84>
    5cba:	a9 f7       	brne	.-22     	; 0x5ca6 <__ultoa_invert+0x6c>
    5cbc:	ea cf       	rjmp	.-44     	; 0x5c92 <__ultoa_invert+0x58>
    5cbe:	b4 e0       	ldi	r27, 0x04	; 4
    5cc0:	a6 95       	lsr	r26
    5cc2:	97 95       	ror	r25
    5cc4:	87 95       	ror	r24
    5cc6:	77 95       	ror	r23
    5cc8:	67 95       	ror	r22
    5cca:	ba 95       	dec	r27
    5ccc:	c9 f7       	brne	.-14     	; 0x5cc0 <__ultoa_invert+0x86>
    5cce:	00 97       	sbiw	r24, 0x00	; 0
    5cd0:	61 05       	cpc	r22, r1
    5cd2:	71 05       	cpc	r23, r1
    5cd4:	08 95       	ret
    5cd6:	9b 01       	movw	r18, r22
    5cd8:	ac 01       	movw	r20, r24
    5cda:	0a 2e       	mov	r0, r26
    5cdc:	06 94       	lsr	r0
    5cde:	57 95       	ror	r21
    5ce0:	47 95       	ror	r20
    5ce2:	37 95       	ror	r19
    5ce4:	27 95       	ror	r18
    5ce6:	ba 95       	dec	r27
    5ce8:	c9 f7       	brne	.-14     	; 0x5cdc <__ultoa_invert+0xa2>
    5cea:	62 0f       	add	r22, r18
    5cec:	73 1f       	adc	r23, r19
    5cee:	84 1f       	adc	r24, r20
    5cf0:	95 1f       	adc	r25, r21
    5cf2:	a0 1d       	adc	r26, r0
    5cf4:	08 95       	ret

00005cf6 <strrev>:
    5cf6:	dc 01       	movw	r26, r24
    5cf8:	fc 01       	movw	r30, r24
    5cfa:	67 2f       	mov	r22, r23
    5cfc:	71 91       	ld	r23, Z+
    5cfe:	77 23       	and	r23, r23
    5d00:	e1 f7       	brne	.-8      	; 0x5cfa <strrev+0x4>
    5d02:	32 97       	sbiw	r30, 0x02	; 2
    5d04:	04 c0       	rjmp	.+8      	; 0x5d0e <strrev+0x18>
    5d06:	7c 91       	ld	r23, X
    5d08:	6d 93       	st	X+, r22
    5d0a:	70 83       	st	Z, r23
    5d0c:	62 91       	ld	r22, -Z
    5d0e:	ae 17       	cp	r26, r30
    5d10:	bf 07       	cpc	r27, r31
    5d12:	c8 f3       	brcs	.-14     	; 0x5d06 <strrev+0x10>
    5d14:	08 95       	ret

00005d16 <__divmodsi4>:
    5d16:	05 2e       	mov	r0, r21
    5d18:	97 fb       	bst	r25, 7
    5d1a:	16 f4       	brtc	.+4      	; 0x5d20 <__divmodsi4+0xa>
    5d1c:	00 94       	com	r0
    5d1e:	0f d0       	rcall	.+30     	; 0x5d3e <__negsi2>
    5d20:	57 fd       	sbrc	r21, 7
    5d22:	05 d0       	rcall	.+10     	; 0x5d2e <__divmodsi4_neg2>
    5d24:	24 d0       	rcall	.+72     	; 0x5d6e <__udivmodsi4>
    5d26:	07 fc       	sbrc	r0, 7
    5d28:	02 d0       	rcall	.+4      	; 0x5d2e <__divmodsi4_neg2>
    5d2a:	46 f4       	brtc	.+16     	; 0x5d3c <__divmodsi4_exit>
    5d2c:	08 c0       	rjmp	.+16     	; 0x5d3e <__negsi2>

00005d2e <__divmodsi4_neg2>:
    5d2e:	50 95       	com	r21
    5d30:	40 95       	com	r20
    5d32:	30 95       	com	r19
    5d34:	21 95       	neg	r18
    5d36:	3f 4f       	sbci	r19, 0xFF	; 255
    5d38:	4f 4f       	sbci	r20, 0xFF	; 255
    5d3a:	5f 4f       	sbci	r21, 0xFF	; 255

00005d3c <__divmodsi4_exit>:
    5d3c:	08 95       	ret

00005d3e <__negsi2>:
    5d3e:	90 95       	com	r25
    5d40:	80 95       	com	r24
    5d42:	70 95       	com	r23
    5d44:	61 95       	neg	r22
    5d46:	7f 4f       	sbci	r23, 0xFF	; 255
    5d48:	8f 4f       	sbci	r24, 0xFF	; 255
    5d4a:	9f 4f       	sbci	r25, 0xFF	; 255
    5d4c:	08 95       	ret

00005d4e <__muluhisi3>:
    5d4e:	44 dd       	rcall	.-1400   	; 0x57d8 <__umulhisi3>
    5d50:	a5 9f       	mul	r26, r21
    5d52:	90 0d       	add	r25, r0
    5d54:	b4 9f       	mul	r27, r20
    5d56:	90 0d       	add	r25, r0
    5d58:	a4 9f       	mul	r26, r20
    5d5a:	80 0d       	add	r24, r0
    5d5c:	91 1d       	adc	r25, r1
    5d5e:	11 24       	eor	r1, r1
    5d60:	08 95       	ret

00005d62 <__mulshisi3>:
    5d62:	b7 ff       	sbrs	r27, 7
    5d64:	f4 cf       	rjmp	.-24     	; 0x5d4e <__muluhisi3>

00005d66 <__mulohisi3>:
    5d66:	f3 df       	rcall	.-26     	; 0x5d4e <__muluhisi3>
    5d68:	82 1b       	sub	r24, r18
    5d6a:	93 0b       	sbc	r25, r19
    5d6c:	08 95       	ret

00005d6e <__udivmodsi4>:
    5d6e:	a1 e2       	ldi	r26, 0x21	; 33
    5d70:	1a 2e       	mov	r1, r26
    5d72:	aa 1b       	sub	r26, r26
    5d74:	bb 1b       	sub	r27, r27
    5d76:	fd 01       	movw	r30, r26
    5d78:	0d c0       	rjmp	.+26     	; 0x5d94 <__udivmodsi4_ep>

00005d7a <__udivmodsi4_loop>:
    5d7a:	aa 1f       	adc	r26, r26
    5d7c:	bb 1f       	adc	r27, r27
    5d7e:	ee 1f       	adc	r30, r30
    5d80:	ff 1f       	adc	r31, r31
    5d82:	a2 17       	cp	r26, r18
    5d84:	b3 07       	cpc	r27, r19
    5d86:	e4 07       	cpc	r30, r20
    5d88:	f5 07       	cpc	r31, r21
    5d8a:	20 f0       	brcs	.+8      	; 0x5d94 <__udivmodsi4_ep>
    5d8c:	a2 1b       	sub	r26, r18
    5d8e:	b3 0b       	sbc	r27, r19
    5d90:	e4 0b       	sbc	r30, r20
    5d92:	f5 0b       	sbc	r31, r21

00005d94 <__udivmodsi4_ep>:
    5d94:	66 1f       	adc	r22, r22
    5d96:	77 1f       	adc	r23, r23
    5d98:	88 1f       	adc	r24, r24
    5d9a:	99 1f       	adc	r25, r25
    5d9c:	1a 94       	dec	r1
    5d9e:	69 f7       	brne	.-38     	; 0x5d7a <__udivmodsi4_loop>
    5da0:	60 95       	com	r22
    5da2:	70 95       	com	r23
    5da4:	80 95       	com	r24
    5da6:	90 95       	com	r25
    5da8:	9b 01       	movw	r18, r22
    5daa:	ac 01       	movw	r20, r24
    5dac:	bd 01       	movw	r22, r26
    5dae:	cf 01       	movw	r24, r30
    5db0:	08 95       	ret

00005db2 <_exit>:
    5db2:	f8 94       	cli

00005db4 <__stop_program>:
    5db4:	ff cf       	rjmp	.-2      	; 0x5db4 <__stop_program>
